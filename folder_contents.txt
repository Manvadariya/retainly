--- Starting Scan of Folder: D:\SDPProject\retainly\lib ---

--- Directory: D:\SDPProject\retainly\lib ---

=========================================
File Path: D:\SDPProject\retainly\lib\main.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:share_handler/share_handler.dart';
import 'dart:io';
import 'src/app.dart';
import 'src/ui/widgets/card/add_text_card_modal.dart';
import 'src/ui/widgets/card/add_image_card_modal.dart';
import 'src/ui/widgets/card/add_link_card_modal.dart';

final GlobalKey<NavigatorState> globalNavigatorKey =
    GlobalKey<NavigatorState>();

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Start app first so navigator is available, then hook share handling
  // Wrap with RepaintBoundary to isolate rebuild issues
  runApp(RepaintBoundary(child: RetainlyApp(navigatorKey: globalNavigatorKey)));

  // Defer init to next frame to ensure navigator is attached
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    final handler = ShareHandlerPlatform.instance;

    // Initial share (cold start)
    final initial = await handler.getInitialSharedMedia();
    if (initial != null) {
      _handleSharedMedia(initial);
    }

    // Stream (warm start)
    handler.sharedMediaStream.listen((SharedMedia media) {
      _handleSharedMedia(media);
    });
  });
}

void _handleSharedMedia(SharedMedia media) async {
  final nav = globalNavigatorKey.currentState;
  if (nav == null) return;

  // Handle text content (plain text or URL)
  if (media.content != null && media.content!.isNotEmpty) {
    final text = media.content!.trim();
    final lower = text.toLowerCase();
    final isLikelyUrl =
        lower.startsWith('http://') ||
        lower.startsWith('https://') ||
        (Uri.tryParse(text)?.hasScheme ?? false);

    if (isLikelyUrl) {
      // URL content - open Link Card Modal
      nav.push(
        MaterialPageRoute(
          fullscreenDialog: true,
          builder: (_) =>
              AddLinkCardModal(initialUrl: text, autofocusSave: true),
        ),
      );
    } else {
      // Plain text content - open Text Card Modal
      nav.push(
        MaterialPageRoute(
          fullscreenDialog: true,
          builder: (_) =>
              AddTextCardModal(initialText: text, autofocusSave: true),
        ),
      );
    }
  }
  // Handle image attachments
  else if (media.attachments != null && media.attachments!.isNotEmpty) {
    // Try to find an image attachment
    final firstImage = media.attachments!.firstWhere(
      (a) => a?.type == SharedAttachmentType.image && a?.path != null,
      orElse: () => null,
    );

    final path = firstImage?.path;
    if (path != null && File(path).existsSync()) {
      // Image found - open Image Card Modal
      nav.push(
        MaterialPageRoute(
          fullscreenDialog: true,
          builder: (_) =>
              AddImageCardModal(imagePath: path, autofocusSave: true),
        ),
      );
    } else {
      // Image attachment declared but file not accessible
      _showUnsupportedTypeMessage(nav.context, "Image file not accessible");
    }
  }
  // No supported content found
  else {
    _showUnsupportedTypeMessage(nav.context, "Unsupported share type");
  }
}

// Helper function to show error messages for unsupported share types
void _showUnsupportedTypeMessage(BuildContext context, String message) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: Colors.redAccent,
      behavior: SnackBarBehavior.floating,
      duration: const Duration(seconds: 3),
    ),
  );
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\app.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'ui/screens/splash_screen.dart';
import 'ui/screens/landing_screen.dart';
import 'ui/screens/home_screen.dart';
import 'ui/screens/card_detail_screen.dart';
import 'ui/theme/app_theme.dart';

class RetainlyApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  const RetainlyApp({super.key, this.navigatorKey});

  @override
  Widget build(BuildContext context) {
    return MaterialApp(
      navigatorKey: navigatorKey,
      title: 'Retainly',
      theme: AppTheme.darkTheme,
      darkTheme: AppTheme.darkTheme,
      themeMode: ThemeMode.dark,
      debugShowCheckedModeBanner: false,
      initialRoute: '/',
      routes: {
        '/': (context) => const SplashScreen(),
        '/landing': (context) => const LandingScreen(),
        '/home': (context) => const HomeScreen(),
      },
      onGenerateRoute: (settings) {
        if (settings.name == '/cardDetail') {
          final cardId = settings.arguments as int;
          return AppTheme.slideAndFadeTransition<dynamic>(
            settings: settings,
            page: CardDetailScreen(cardId: cardId),
          );
        }
        return null;
      },
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\bloc ---
--- Directory: D:\SDPProject\retainly\lib\src\bloc\add_card ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:io';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:html/parser.dart' as parser;
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';
import 'add_card_event.dart';
import 'add_card_state.dart';
import '../../utils/image_storage.dart';

class AddCardBloc extends Bloc<AddCardEvent, AddCardState> {
  final CardRepository cardRepository;

  AddCardBloc({required this.cardRepository}) : super(const AddCardIdle()) {
    on<AddTextCardRequested>(_onAddTextCardRequested);
    on<AddImageCardRequested>(_onAddImageCardRequested);
    on<AddLinkCardRequested>(_onAddLinkCardRequested);
    on<FetchTitleRequested>(_onFetchTitleRequested);
  }

  Future<void> _onAddTextCardRequested(
    AddTextCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardSaving());

    try {
      final now = DateTime.now().millisecondsSinceEpoch;
      final card = CardEntity(
        type: 'text',
        content: event
            .content, // Using content as both title and body for simple notes
        body: event.content,
        createdAt: now,
        updatedAt: now,
      );

      final cardId = await cardRepository.addCard(card);
      emit(AddCardSuccess(cardId));
    } catch (e) {
      emit(AddCardFailure(e.toString()));
    }
  }

  Future<void> _onAddImageCardRequested(
    AddImageCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardSaving());

    try {
      // Persist image and thumbnail
      final storage = ImageStorage();
      final input = File(event.imagePath);
      final (original, thumbnail) = await storage.saveImageWithThumbnail(input);

      final now = DateTime.now().millisecondsSinceEpoch;
      final card = CardEntity(
        type: 'image',
        content: event.caption?.trim().isNotEmpty == true
            ? event.caption!.trim()
            : 'Image',
        body: null,
        imagePath: original.path, // store original path
        createdAt: now,
        updatedAt: now,
      );
      final cardId = await cardRepository.addCard(card);
      emit(AddCardSuccess(cardId));
    } catch (e) {
      emit(AddCardFailure(e.toString()));
    }
  }

  Future<void> _onAddLinkCardRequested(
    AddLinkCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardSaving());

    try {
      final now = DateTime.now().millisecondsSinceEpoch;
      final card = CardEntity(
        type: 'link',
        content: event.title.trim(),
        url: event.url.trim(),
        createdAt: now,
        updatedAt: now,
      );

      final cardId = await cardRepository.addCard(card);
      emit(AddCardSuccess(cardId));
    } catch (e) {
      emit(AddCardFailure(e.toString()));
    }
  }

  Future<void> _onFetchTitleRequested(
    FetchTitleRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const TitleFetching());

    try {
      // Normalize URL and ensure scheme
      String raw = event.url.trim();
      if (raw.isEmpty) {
        emit(const AddCardFailure('Empty URL'));
        return;
      }

      if (!raw.startsWith('http://') && !raw.startsWith('https://')) {
        raw = 'https://$raw';
      }

      final uri = Uri.tryParse(raw);
      if (uri == null) {
        emit(const AddCardFailure('Invalid URL'));
        return;
      }

      final client = http.Client();
      http.Response response;
      try {
        response = await client
            .get(
              uri,
              headers: const {
                'User-Agent':
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
                'Accept':
                    'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Cache-Control': 'no-cache',
              },
            )
            .timeout(const Duration(seconds: 10));
      } on TimeoutException {
        client.close();
        emit(const AddCardFailure('Connection timed out while fetching title'));
        return;
      } on SocketException catch (e) {
        client.close();
        emit(AddCardFailure('Network error: ${e.message}'));
        return;
      } catch (e) {
        client.close();
        emit(AddCardFailure('Request failed: $e'));
        return;
      }
      client.close();

      if (response.statusCode == 200) {
        var document = parser.parse(response.body);
        var titleElements = document.getElementsByTagName('title');

        if (titleElements.isNotEmpty) {
          String title = titleElements.first.text.trim();
          emit(TitleFetched(title));
        } else {
          // Try to find meta tag with og:title
          var metaTags = document.getElementsByTagName('meta');
          var ogTitle = metaTags.firstWhere(
            (element) => element.attributes['property'] == 'og:title',
            orElse: () => metaTags.firstWhere(
              (element) => element.attributes['name'] == 'title',
              orElse: () => document.createElement('meta'),
            ),
          );

          if (ogTitle.attributes.containsKey('content') &&
              ogTitle.attributes['content']!.isNotEmpty) {
            emit(TitleFetched(ogTitle.attributes['content']!));
          } else {
            // Fallback to URL without protocol and www
            String fallbackTitle = raw
                .replaceAll(RegExp(r'^https?://'), '')
                .replaceAll(RegExp(r'^www\.'), '');

            // If there's a path, just use the domain
            if (fallbackTitle.contains('/')) {
              fallbackTitle = fallbackTitle.split('/').first;
            }

            emit(TitleFetched(fallbackTitle));
          }
        }
      } else {
        emit(
          AddCardFailure('Could not load page: HTTP ${response.statusCode}'),
        );
      }
    } catch (e) {
      emit(AddCardFailure('Failed to fetch title: ${e.toString()}'));
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_event.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';

abstract class AddCardEvent extends Equatable {
  const AddCardEvent();

  @override
  List<Object> get props => [];
}

class AddTextCardRequested extends AddCardEvent {
  final String content;
  final List<String> tags;

  const AddTextCardRequested({required this.content, this.tags = const []});

  @override
  List<Object> get props => [content, tags];
}

class AddImageCardRequested extends AddCardEvent {
  final String imagePath; // temp file path
  final String? caption;

  const AddImageCardRequested({required this.imagePath, this.caption});

  @override
  List<Object> get props => [imagePath, caption ?? ''];
}

class AddLinkCardRequested extends AddCardEvent {
  final String url;
  final String title;

  const AddLinkCardRequested({required this.url, required this.title});

  @override
  List<Object> get props => [url, title];
}

class FetchTitleRequested extends AddCardEvent {
  final String url;

  const FetchTitleRequested({required this.url});

  @override
  List<Object> get props => [url];
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_state.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';

abstract class AddCardState extends Equatable {
  const AddCardState();

  @override
  List<Object> get props => [];
}

class AddCardIdle extends AddCardState {
  const AddCardIdle();
}

class AddCardSaving extends AddCardState {
  const AddCardSaving();
}

class AddCardSuccess extends AddCardState {
  final int cardId;

  const AddCardSuccess(this.cardId);

  @override
  List<Object> get props => [cardId];
}

class AddCardFailure extends AddCardState {
  final String error;

  const AddCardFailure(this.error);

  @override
  List<Object> get props => [error];
}

class TitleFetching extends AddCardState {
  const TitleFetching();
}

class TitleFetched extends AddCardState {
  final String title;

  const TitleFetched(this.title);

  @override
  List<Object> get props => [title];
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\bloc\main_grid ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:async';
import '../../data/repository/card_repository.dart';
import 'main_grid_event.dart';
import 'main_grid_state.dart';

class MainGridBloc extends Bloc<MainGridEvent, MainGridState> {
  final CardRepository _cardRepository;
  static const int _pageSize = 20;
  MainGridBloc({required CardRepository cardRepository})
    : _cardRepository = cardRepository,
      super(const MainGridInitial()) {
    on<LoadCards>(_onLoadCards);
    on<LoadMoreCards>(_onLoadMoreCards);
    on<CardAdded>(_onCardAdded);
    on<CardDeleted>(_onCardDeleted);
    on<SearchCards>(_onSearchCards);
    on<SearchQueryChanged>(_onSearchQueryChanged);
    on<ClearSearch>(_onClearSearch);
  }

  @override
  Future<void> close() {
    return super.close();
  }

  Future<void> _onLoadCards(
    LoadCards event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: true));
      final cards = await _cardRepository.getAllCards(limit: _pageSize);
      final hasReachedMax = cards.length < _pageSize;

      emit(MainGridLoaded(cards: cards, hasReachedMax: hasReachedMax));
    } catch (e) {
      emit(MainGridError('Failed to load cards: ${e.toString()}'));
    }
  }

  Future<void> _onLoadMoreCards(
    LoadMoreCards event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    // Don't load more if already reached max or is showing search results
    if (currentState.hasReachedMax || currentState.isSearchResult) return;

    try {
      // Show loading state but keep current cards
      // Could add a "loadingMore" flag to state if needed for UI

      final moreCards = await _cardRepository.getAllCards(
        offset: currentState.cards.length,
        limit: _pageSize,
      );

      final hasReachedMax = moreCards.length < _pageSize;

      emit(
        currentState.copyWith(
          cards: [...currentState.cards, ...moreCards],
          hasReachedMax: hasReachedMax,
        ),
      );
    } catch (e) {
      // Keep current cards but show error
      emit(MainGridError('Failed to load more cards: ${e.toString()}'));
    }
  }

  Future<void> _onCardAdded(
    CardAdded event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    // If showing search results, don't update unless card matches search
    if (currentState.isSearchResult && currentState.searchQuery != null) {
      final query = currentState.searchQuery!.toLowerCase();
      final content = event.card.content.toLowerCase();
      final body = event.card.body?.toLowerCase() ?? '';

      if (content.contains(query) || body.contains(query)) {
        emit(currentState.copyWith(cards: [event.card, ...currentState.cards]));
      }
    } else {
      // For normal view, add card to the top
      emit(currentState.copyWith(cards: [event.card, ...currentState.cards]));
    }
  }

  Future<void> _onCardDeleted(
    CardDeleted event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    try {
      await _cardRepository.deleteCard(event.cardId);

      final updatedCards = currentState.cards
          .where((card) => card.id != event.cardId)
          .toList();

      emit(currentState.copyWith(cards: updatedCards));
    } catch (e) {
      emit(MainGridError('Failed to delete card: ${e.toString()}'));
    }
  }

  Future<void> _onSearchCards(
    SearchCards event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: false));

      final searchResults = await _cardRepository.searchCards(event.query);

      emit(
        MainGridLoaded(
          cards: searchResults,
          hasReachedMax: true, // No pagination for search results
          searchQuery: event.query,
          isSearchResult: true,
        ),
      );
    } catch (e) {
      emit(MainGridError('Search failed: ${e.toString()}'));
    }
  }

  Future<void> _onClearSearch(
    ClearSearch event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: false));

      final cards = await _cardRepository.getAllCards(limit: _pageSize);
      final hasReachedMax = cards.length < _pageSize;

      emit(
        MainGridLoaded(
          cards: cards,
          hasReachedMax: hasReachedMax,
          searchQuery: null,
          isSearchResult: false,
        ),
      );
    } catch (e) {
      emit(MainGridError('Failed to load cards: ${e.toString()}'));
    }
  }

  Future<void> _onSearchQueryChanged(
    SearchQueryChanged event,
    Emitter<MainGridState> emit,
  ) async {
    final query = event.query.trim();

    // If query is empty, clear search
    if (query.isEmpty) {
      add(const ClearSearch());
      return;
    }

    // Only perform search if query is at least 2 characters
    if (query.length >= 2) {
      try {
        // Show loading state but maintain previous cards if available
        if (state is MainGridLoaded) {
          emit(
            (state as MainGridLoaded).copyWith(
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        } else {
          emit(MainGridLoading(isFirstLoad: false));
        }

        final searchResults = await _cardRepository.searchCards(query);

        if (state is MainGridLoaded) {
          emit(
            (state as MainGridLoaded).copyWith(
              cards: searchResults,
              hasReachedMax: true, // No pagination for search results
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        } else {
          emit(
            MainGridLoaded(
              cards: searchResults,
              hasReachedMax: true,
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        }
      } catch (e) {
        // Don't emit error state for live search - just keep current state
        if (state is! MainGridLoaded) {
          // If we don't have any cards to show, we must show an error
          emit(MainGridError('Search failed: ${e.toString()}'));
        }
        print('Search query changed error: ${e.toString()}');
      }
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_event.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';
import '../../data/card_entity.dart';

abstract class MainGridEvent extends Equatable {
  const MainGridEvent();

  @override
  List<Object?> get props => [];
}

// Event to load initial cards
class LoadCards extends MainGridEvent {
  final bool refresh;

  const LoadCards({this.refresh = false});

  @override
  List<Object?> get props => [refresh];
}

// Event to load more cards (pagination)
class LoadMoreCards extends MainGridEvent {
  const LoadMoreCards();
}

// Event when card is added
class CardAdded extends MainGridEvent {
  final CardEntity card;

  const CardAdded(this.card);

  @override
  List<Object?> get props => [card];
}

// Event when card is deleted
class CardDeleted extends MainGridEvent {
  final int cardId;

  const CardDeleted(this.cardId);

  @override
  List<Object?> get props => [cardId];
}

// Event for searching cards
class SearchCards extends MainGridEvent {
  final String query;

  const SearchCards(this.query);

  @override
  List<Object?> get props => [query];
}

// Event when search query changes
class SearchQueryChanged extends MainGridEvent {
  final String query;

  const SearchQueryChanged(this.query);

  @override
  List<Object?> get props => [query];
}

// Event to clear search and show all cards
class ClearSearch extends MainGridEvent {
  const ClearSearch();
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_state.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';
import '../../data/card_entity.dart';

abstract class MainGridState extends Equatable {
  const MainGridState();

  @override
  List<Object?> get props => [];
}

class MainGridInitial extends MainGridState {
  const MainGridInitial();
}

class MainGridLoading extends MainGridState {
  final bool isFirstLoad;

  const MainGridLoading({this.isFirstLoad = true});

  @override
  List<Object?> get props => [isFirstLoad];
}

class MainGridLoaded extends MainGridState {
  final List<CardEntity> cards;
  final bool hasReachedMax;
  final String? searchQuery;
  final bool isSearchResult;

  const MainGridLoaded({
    required this.cards,
    this.hasReachedMax = false,
    this.searchQuery,
    this.isSearchResult = false,
  });

  @override
  List<Object?> get props => [
    cards,
    hasReachedMax,
    searchQuery,
    isSearchResult,
  ];

  MainGridLoaded copyWith({
    List<CardEntity>? cards,
    bool? hasReachedMax,
    String? searchQuery,
    bool? isSearchResult,
  }) {
    return MainGridLoaded(
      cards: cards ?? this.cards,
      hasReachedMax: hasReachedMax ?? this.hasReachedMax,
      searchQuery: searchQuery ?? this.searchQuery,
      isSearchResult: isSearchResult ?? this.isSearchResult,
    );
  }
}

class MainGridError extends MainGridState {
  final String message;

  const MainGridError(this.message);

  @override
  List<Object?> get props => [message];
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\data ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\data\card_dao.dart
=========================================
--- Content Start ---
part of 'database.dart';

@DriftAccessor(tables: [Cards])
class CardDao extends DatabaseAccessor<AppDatabase> with _$CardDaoMixin {
  CardDao(super.db);

  Future<int> insertCard(CardEntity card) async {
    return into(cards).insert(card.toCompanion());
  }

  Future<List<CardEntity>> getAllCards({int offset = 0, int limit = 40}) async {
    final query =
        (select(cards)
              ..orderBy([(t) => OrderingTerm.desc(t.createdAt)])
              ..limit(limit, offset: offset))
            .get();
    final rows = await query;
    return rows.map((e) => e.toEntity()).toList(growable: false);
  }

  Future<List<CardEntity>> searchCards(String query) async {
    final like = '%${query.replaceAll('%', '\\%').replaceAll('_', '\\_')}%';
    final rows =
        await (select(cards)
              ..where(
                (t) =>
                    t.content.like(like) |
                    (t.body.isNotNull() & t.body.like(like)) |
                    (t.url.isNotNull() & t.url.like(like)),
              )
              ..orderBy([(t) => OrderingTerm.desc(t.createdAt)])
              ..limit(100))
            .get();
    return rows.map((e) => e.toEntity()).toList(growable: false);
  }

  Future<void> deleteCard(int id) async {
    await (delete(cards)..where((t) => t.id.equals(id))).go();
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\card_entity.dart
=========================================
--- Content Start ---
// A simple plain Dart model representing a Card record in the local DB.
// Keeping it independent of Drift types makes it easy to test and use in UI.

class CardEntity {
  final int? id;
  final String type; // "text", "image", or "link"
  final String content; // title or short text
  final String? body; // full note text (nullable)
  final String? imagePath; // local file path (nullable)
  final String? url; // original URL if link (nullable)
  final int createdAt; // epoch millis
  final int updatedAt; // epoch millis

  const CardEntity({
    this.id,
    required this.type,
    required this.content,
    this.body,
    this.imagePath,
    this.url,
    required this.createdAt,
    required this.updatedAt,
  });

  CardEntity copyWith({
    int? id,
    String? type,
    String? content,
    String? body,
    String? imagePath,
    String? url,
    int? createdAt,
    int? updatedAt,
  }) {
    return CardEntity(
      id: id ?? this.id,
      type: type ?? this.type,
      content: content ?? this.content,
      body: body ?? this.body,
      imagePath: imagePath ?? this.imagePath,
      url: url ?? this.url,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\database.dart
=========================================
--- Content Start ---
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'card_entity.dart';

part 'database.g.dart';
part 'card_dao.dart';

// Drift table definition for cards
class Cards extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get type => text()();
  TextColumn get content => text()();
  TextColumn get body => text().nullable()();
  TextColumn get imagePath => text().nullable()();
  TextColumn get url => text().nullable()();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
}

@DriftDatabase(tables: [Cards], daos: [CardDao])
class AppDatabase extends _$AppDatabase {
  AppDatabase._internal(QueryExecutor e) : super(e);

  static AppDatabase? _instance;

  factory AppDatabase() =>
      _instance ??= AppDatabase._internal(_openConnection());

  @override
  int get schemaVersion => 1;
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    try {
      // For mobile platforms
      if (Platform.isAndroid || Platform.isIOS) {
        final dir = await getApplicationDocumentsDirectory();
        final dbPath = '${dir.path}${Platform.pathSeparator}retainly.db';
        final file = File(dbPath);
        return NativeDatabase(file);
      }
    } catch (e) {
      // Handle case when path_provider doesn't work or platform isn't supported
      // Fallback to a temporary location - don't use in production
      final file = File('retainly.db');
      return NativeDatabase(file);
    }

    // Fallback for web, desktop, or any other platform
    final file = File('retainly.db');
    return NativeDatabase(file);
  });
}

// Mapping helpers between Drift row and CardEntity
extension CardMapper on Card {
  CardEntity toEntity() => CardEntity(
    id: id,
    type: type,
    content: content,
    body: body,
    imagePath: imagePath,
    url: url,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );
}

extension CardCompanionMapper on CardEntity {
  CardsCompanion toCompanion() => CardsCompanion.insert(
    type: type,
    content: content,
    body: Value(body),
    imagePath: Value(imagePath),
    url: Value(url),
    createdAt: createdAt,
    updatedAt: updatedAt,
  );
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\database.g.dart
=========================================
--- Content Start ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $CardsTable extends Cards with TableInfo<$CardsTable, Card> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CardsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bodyMeta = const VerificationMeta('body');
  @override
  late final GeneratedColumn<String> body = GeneratedColumn<String>(
    'body',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _urlMeta = const VerificationMeta('url');
  @override
  late final GeneratedColumn<String> url = GeneratedColumn<String>(
    'url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    type,
    content,
    body,
    imagePath,
    url,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cards';
  @override
  VerificationContext validateIntegrity(
    Insertable<Card> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('body')) {
      context.handle(
        _bodyMeta,
        body.isAcceptableOrUnknown(data['body']!, _bodyMeta),
      );
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('url')) {
      context.handle(
        _urlMeta,
        url.isAcceptableOrUnknown(data['url']!, _urlMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Card map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Card(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      body: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}body'],
      ),
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}url'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CardsTable createAlias(String alias) {
    return $CardsTable(attachedDatabase, alias);
  }
}

class Card extends DataClass implements Insertable<Card> {
  final int id;
  final String type;
  final String content;
  final String? body;
  final String? imagePath;
  final String? url;
  final int createdAt;
  final int updatedAt;
  const Card({
    required this.id,
    required this.type,
    required this.content,
    this.body,
    this.imagePath,
    this.url,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['type'] = Variable<String>(type);
    map['content'] = Variable<String>(content);
    if (!nullToAbsent || body != null) {
      map['body'] = Variable<String>(body);
    }
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || url != null) {
      map['url'] = Variable<String>(url);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  CardsCompanion toCompanion(bool nullToAbsent) {
    return CardsCompanion(
      id: Value(id),
      type: Value(type),
      content: Value(content),
      body: body == null && nullToAbsent ? const Value.absent() : Value(body),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      url: url == null && nullToAbsent ? const Value.absent() : Value(url),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Card.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Card(
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      content: serializer.fromJson<String>(json['content']),
      body: serializer.fromJson<String?>(json['body']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      url: serializer.fromJson<String?>(json['url']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String>(type),
      'content': serializer.toJson<String>(content),
      'body': serializer.toJson<String?>(body),
      'imagePath': serializer.toJson<String?>(imagePath),
      'url': serializer.toJson<String?>(url),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  Card copyWith({
    int? id,
    String? type,
    String? content,
    Value<String?> body = const Value.absent(),
    Value<String?> imagePath = const Value.absent(),
    Value<String?> url = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => Card(
    id: id ?? this.id,
    type: type ?? this.type,
    content: content ?? this.content,
    body: body.present ? body.value : this.body,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    url: url.present ? url.value : this.url,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Card copyWithCompanion(CardsCompanion data) {
    return Card(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      content: data.content.present ? data.content.value : this.content,
      body: data.body.present ? data.body.value : this.body,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      url: data.url.present ? data.url.value : this.url,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Card(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('content: $content, ')
          ..write('body: $body, ')
          ..write('imagePath: $imagePath, ')
          ..write('url: $url, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    type,
    content,
    body,
    imagePath,
    url,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Card &&
          other.id == this.id &&
          other.type == this.type &&
          other.content == this.content &&
          other.body == this.body &&
          other.imagePath == this.imagePath &&
          other.url == this.url &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CardsCompanion extends UpdateCompanion<Card> {
  final Value<int> id;
  final Value<String> type;
  final Value<String> content;
  final Value<String?> body;
  final Value<String?> imagePath;
  final Value<String?> url;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const CardsCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.content = const Value.absent(),
    this.body = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.url = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  CardsCompanion.insert({
    this.id = const Value.absent(),
    required String type,
    required String content,
    this.body = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.url = const Value.absent(),
    required int createdAt,
    required int updatedAt,
  }) : type = Value(type),
       content = Value(content),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Card> custom({
    Expression<int>? id,
    Expression<String>? type,
    Expression<String>? content,
    Expression<String>? body,
    Expression<String>? imagePath,
    Expression<String>? url,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (content != null) 'content': content,
      if (body != null) 'body': body,
      if (imagePath != null) 'image_path': imagePath,
      if (url != null) 'url': url,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  CardsCompanion copyWith({
    Value<int>? id,
    Value<String>? type,
    Value<String>? content,
    Value<String?>? body,
    Value<String?>? imagePath,
    Value<String?>? url,
    Value<int>? createdAt,
    Value<int>? updatedAt,
  }) {
    return CardsCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      content: content ?? this.content,
      body: body ?? this.body,
      imagePath: imagePath ?? this.imagePath,
      url: url ?? this.url,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (body.present) {
      map['body'] = Variable<String>(body.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (url.present) {
      map['url'] = Variable<String>(url.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CardsCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('content: $content, ')
          ..write('body: $body, ')
          ..write('imagePath: $imagePath, ')
          ..write('url: $url, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $CardsTable cards = $CardsTable(this);
  late final CardDao cardDao = CardDao(this as AppDatabase);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [cards];
}

typedef $$CardsTableCreateCompanionBuilder =
    CardsCompanion Function({
      Value<int> id,
      required String type,
      required String content,
      Value<String?> body,
      Value<String?> imagePath,
      Value<String?> url,
      required int createdAt,
      required int updatedAt,
    });
typedef $$CardsTableUpdateCompanionBuilder =
    CardsCompanion Function({
      Value<int> id,
      Value<String> type,
      Value<String> content,
      Value<String?> body,
      Value<String?> imagePath,
      Value<String?> url,
      Value<int> createdAt,
      Value<int> updatedAt,
    });

class $$CardsTableFilterComposer extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get url => $composableBuilder(
    column: $table.url,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );
}

class $$CardsTableOrderingComposer
    extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get url => $composableBuilder(
    column: $table.url,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$CardsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get body =>
      $composableBuilder(column: $table.body, builder: (column) => column);

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get url =>
      $composableBuilder(column: $table.url, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);
}

class $$CardsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CardsTable,
          Card,
          $$CardsTableFilterComposer,
          $$CardsTableOrderingComposer,
          $$CardsTableAnnotationComposer,
          $$CardsTableCreateCompanionBuilder,
          $$CardsTableUpdateCompanionBuilder,
          (Card, BaseReferences<_$AppDatabase, $CardsTable, Card>),
          Card,
          PrefetchHooks Function()
        > {
  $$CardsTableTableManager(_$AppDatabase db, $CardsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CardsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CardsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CardsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String?> body = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> url = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
              }) => CardsCompanion(
                id: id,
                type: type,
                content: content,
                body: body,
                imagePath: imagePath,
                url: url,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String type,
                required String content,
                Value<String?> body = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> url = const Value.absent(),
                required int createdAt,
                required int updatedAt,
              }) => CardsCompanion.insert(
                id: id,
                type: type,
                content: content,
                body: body,
                imagePath: imagePath,
                url: url,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map((e) => (e.readTable(table), BaseReferences(db, table, e)))
              .toList(),
          prefetchHooksCallback: null,
        ),
      );
}

typedef $$CardsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CardsTable,
      Card,
      $$CardsTableFilterComposer,
      $$CardsTableOrderingComposer,
      $$CardsTableAnnotationComposer,
      $$CardsTableCreateCompanionBuilder,
      $$CardsTableUpdateCompanionBuilder,
      (Card, BaseReferences<_$AppDatabase, $CardsTable, Card>),
      Card,
      PrefetchHooks Function()
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$CardsTableTableManager get cards =>
      $$CardsTableTableManager(_db, _db.cards);
}

mixin _$CardDaoMixin on DatabaseAccessor<AppDatabase> {
  $CardsTable get cards => attachedDatabase.cards;
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\data\repository ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\data\repository\card_repository.dart
=========================================
--- Content Start ---
import '../../data/card_entity.dart';
import '../../data/database.dart';
import '../../utils/image_storage.dart';

/// Repository to abstract database access for cards
class CardRepository {
  final AppDatabase _database;
  final ImageStorage _imageStorage;

  CardRepository({AppDatabase? database, ImageStorage? imageStorage})
    : _database = database ?? AppDatabase(),
      _imageStorage = imageStorage ?? ImageStorage();

  Future<int> addCard(CardEntity card) {
    return _database.cardDao.insertCard(card);
  }

  Future<List<CardEntity>> getAllCards({int offset = 0, int limit = 40}) {
    return _database.cardDao.getAllCards(offset: offset, limit: limit);
  }

  Future<List<CardEntity>> searchCards(String query) {
    return _database.cardDao.searchCards(query);
  }

  Future<void> deleteCard(int id) async {
    // First, get the card to check for associated files
    final cards = await _database.cardDao.getAllCards();
    final card = cards.firstWhere(
      (c) => c.id == id,
      orElse: () => throw Exception('Card not found'),
    );

    // Delete any associated files
    if (card.imagePath != null && !card.imagePath!.startsWith('http')) {
      await _imageStorage.deleteImagePair(card.imagePath!);
    }

    // Delete the database record
    return _database.cardDao.deleteCard(id);
  }

  /// Create a sample card for testing
  Future<int> createSampleCard() {
    final now = DateTime.now().millisecondsSinceEpoch;
    final card = CardEntity(
      type: 'text',
      content: 'Sample Note',
      body: 'This is a sample note created for testing the database.',
      createdAt: now,
      updatedAt: now,
    );
    return addCard(card);
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui ---
--- Directory: D:\SDPProject\retainly\lib\src\ui\screens ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\add_card_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class AddCardScreen extends StatefulWidget {
  const AddCardScreen({super.key});

  @override
  State<AddCardScreen> createState() => _AddCardScreenState();
}

class _AddCardScreenState extends State<AddCardScreen> {
  final _formKey = GlobalKey<FormState>();
  final _repository = CardRepository();

  String _title = '';
  String _content = '';
  String _type = 'text'; // Default type
  bool _isSubmitting = false;

  void _submitForm() async {
    if (_formKey.currentState?.validate() ?? false) {
      _formKey.currentState?.save();

      setState(() {
        _isSubmitting = true;
      });

      try {
        final now = DateTime.now().millisecondsSinceEpoch;
        final card = CardEntity(
          type: _type,
          content: _title,
          body: _content,
          createdAt: now,
          updatedAt: now,
        );

        await _repository.addCard(card);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Card added successfully')),
          );
          Navigator.pop(context, true); // Return success
        }
      } catch (e) {
        setState(() {
          _isSubmitting = false;
        });

        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text('Failed to add card: $e')));
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Add Card')),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            DropdownButtonFormField<String>(
              value: _type,
              decoration: const InputDecoration(labelText: 'Card Type'),
              items: const [
                DropdownMenuItem(value: 'text', child: Text('Text Note')),
                DropdownMenuItem(value: 'link', child: Text('Link')),
              ],
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _type = value;
                  });
                }
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(labelText: 'Title'),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Please enter a title';
                }
                return null;
              },
              onSaved: (value) {
                _title = value?.trim() ?? '';
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(
                labelText: 'Content',
                alignLabelWithHint: true,
              ),
              maxLines: 5,
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Please enter content';
                }
                return null;
              },
              onSaved: (value) {
                _content = value?.trim() ?? '';
              },
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isSubmitting ? null : _submitForm,
              child: _isSubmitting
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Save Card'),
            ),
          ],
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\card_detail_screen.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:share_plus/share_plus.dart';
import 'package:video_player/video_player.dart';
import 'package:url_launcher/url_launcher.dart' as url_launcher;

import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class CardDetailScreen extends StatefulWidget {
  final int cardId;

  const CardDetailScreen({super.key, required this.cardId});

  @override
  State<CardDetailScreen> createState() => _CardDetailScreenState();
}

class _CardDetailScreenState extends State<CardDetailScreen>
    with SingleTickerProviderStateMixin {
  late Future<CardEntity?> _cardFuture;
  VideoPlayerController? _videoController;
  final CardRepository _repository = CardRepository();
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _cardFuture = _loadCard();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeIn),
    );
    _animationController.forward();
  }

  Future<CardEntity?> _loadCard() async {
    try {
      final cards = await _repository.getAllCards();
      return cards.firstWhere((card) => card.id == widget.cardId);
    } catch (e) {
      return null;
    }
  }

  @override
  void dispose() {
    _videoController?.dispose();
    _animationController.dispose();
    super.dispose();
  }

  void _initVideoPlayer(String path) {
    if (_videoController != null) {
      _videoController!.dispose();
    }

    if (path.startsWith('http')) {
      _videoController = VideoPlayerController.networkUrl(Uri.parse(path));
    } else {
      _videoController = VideoPlayerController.file(File(path));
    }

    _videoController!.initialize().then((_) {
      if (mounted) setState(() {});
      _videoController!.play();
    });
  }

  void _showDeleteConfirmation(CardEntity card) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E1E),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text(
          'Delete Card',
          style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        content: Text(
          'Are you sure you want to delete "${card.content}"?',
          style: const TextStyle(color: Colors.white70),
          textAlign: TextAlign.center,
        ),
        actions: [
          TextButton(
            style: TextButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            ),
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL', style: TextStyle(color: Colors.grey)),
          ),
          TextButton(
            style: TextButton.styleFrom(
              backgroundColor: Colors.red.withOpacity(0.2),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            onPressed: () async {
              if (card.id != null) {
                await _repository.deleteCard(card.id!);
                if (mounted) {
                  Navigator.of(context).pop(); // Close dialog
                  Navigator.of(context).pop(true); // Go back with result
                }
              }
            },
            child: const Text(
              'DELETE',
              style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _shareCard(CardEntity card) async {
    bool success = true;
    try {
      switch (card.type) {
        case 'text':
          await Share.share(card.body ?? card.content);
          break;
        case 'image':
          if (card.imagePath != null) {
            if (card.imagePath!.startsWith('http')) {
              // For network image, share the URL
              await Share.share('Check out this image: ${card.imagePath}');
            } else {
              // For local image, share the file
              await Share.shareXFiles([
                XFile(card.imagePath!),
              ], text: card.content);
            }
          } else {
            success = false;
          }
          break;
        case 'video':
          if (card.imagePath != null) {
            if (card.imagePath!.startsWith('http')) {
              // For network video, share the URL
              await Share.share('Check out this video: ${card.imagePath}');
            } else {
              // For local video, share the file
              await Share.shareXFiles([
                XFile(card.imagePath!),
              ], text: card.content);
            }
          } else {
            success = false;
          }
          break;
        case 'link':
          if (card.url != null) {
            await Share.share('${card.content}: ${card.url}');
          } else {
            success = false;
          }
          break;
      }

      // Show success message
      if (mounted && success) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Card shared successfully'),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Failed to share card'),
            backgroundColor: Colors.red.shade700,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  String _getFormattedDate(DateTime date) {
    return '${date.day} ${_getMonthName(date.month)} ${date.year}, ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _getMonthName(int month) {
    const months = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    return months[month - 1];
  }

  String _getCardTypeTitle(String type) {
    switch (type) {
      case 'text':
        return 'Text Card';
      case 'image':
        return 'Image Card';
      case 'video':
        return 'Video Card';
      case 'link':
        return 'Link Card';
      default:
        return 'Card';
    }
  }

  @override
  Widget build(BuildContext context) {
    // Check if we're on a tablet
    final isTablet = MediaQuery.of(context).size.width > 600;

    return FadeTransition(
      opacity: _fadeAnimation,
      child: FutureBuilder<CardEntity?>(
        future: _cardFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Scaffold(
              appBar: AppBar(
                backgroundColor: const Color(0xFF1E1E1E),
                elevation: 0,
              ),
              backgroundColor: const Color(0xFF121212),
              body: const Center(
                child: CircularProgressIndicator(
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.orangeAccent,
                  ),
                ),
              ),
            );
          }

          if (snapshot.hasError || !snapshot.hasData || snapshot.data == null) {
            return Scaffold(
              appBar: AppBar(
                title: const Text('Error'),
                backgroundColor: const Color(0xFF1E1E1E),
                elevation: 0,
              ),
              backgroundColor: const Color(0xFF121212),
              body: Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.error_outline,
                      size: 64,
                      color: Colors.grey[700],
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Card not found',
                      style: TextStyle(
                        fontSize: isTablet ? 22 : 18,
                        color: Colors.grey[400],
                      ),
                    ),
                    const SizedBox(height: 24),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.orangeAccent,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(
                          horizontal: 24,
                          vertical: 12,
                        ),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Go Back'),
                    ),
                  ],
                ),
              ),
            );
          }

          final card = snapshot.data!;
          final createdDate = DateTime.fromMillisecondsSinceEpoch(
            card.createdAt,
          );
          final formattedDate = _getFormattedDate(createdDate);

          // Initialize video player if it's a video card
          if (card.type == 'video' &&
              card.imagePath != null &&
              _videoController == null) {
            _initVideoPlayer(card.imagePath!);
          }

          return Scaffold(
            appBar: AppBar(
              backgroundColor: const Color(0xFF1E1E1E),
              elevation: 0,
              centerTitle: true,
              title: Text(
                _getCardTypeTitle(card.type),
                style: TextStyle(
                  fontSize: isTablet ? 20 : 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              actions: [
                IconButton(
                  icon: const Icon(Icons.share, color: Colors.white),
                  tooltip: 'Share card',
                  onPressed: () => _shareCard(card),
                ),
                IconButton(
                  icon: const Icon(Icons.delete, color: Colors.red),
                  tooltip: 'Delete card',
                  onPressed: () => _showDeleteConfirmation(card),
                ),
                const SizedBox(width: 8), // Add some padding to the right
              ],
            ),
            backgroundColor: const Color(0xFF121212),
            body: Hero(
              tag: 'card-${card.id ?? card.createdAt}',
              child: SafeArea(
                child: Column(
                  children: [
                    Expanded(child: _buildCardDetailContent(card, isTablet)),
                    _buildFooter(formattedDate),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildFooter(String formattedDate) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: const Color(0xFF1A1A1A),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, -1),
          ),
        ],
      ),
      child: Row(
        children: [
          const Icon(Icons.access_time, size: 16, color: Colors.grey),
          const SizedBox(width: 8),
          Text(
            'Created on $formattedDate',
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  Widget _buildCardDetailContent(CardEntity card, bool isTablet) {
    switch (card.type) {
      case 'text':
        return _buildTextDetail(card, isTablet);
      case 'image':
        return _buildImageDetail(card, isTablet);
      case 'video':
        return _buildVideoDetail(card, isTablet);
      case 'link':
        return _buildLinkDetail(card, isTablet);
      default:
        return _buildTextDetail(card, isTablet);
    }
  }

  Widget _buildTextDetail(CardEntity card, bool isTablet) {
    final double titleSize = isTablet ? 28 : 24;
    final double bodySize = isTablet ? 20 : 18;

    return SingleChildScrollView(
      physics: const BouncingScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            card.content,
            style: TextStyle(
              fontSize: titleSize,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 16),
          Container(
            height: 1,
            color: Colors.grey.withOpacity(0.2),
            margin: const EdgeInsets.symmetric(vertical: 16),
          ),
          if (card.body != null)
            SelectableText(
              card.body!,
              style: TextStyle(
                fontSize: bodySize,
                height: 1.4,
                color: Colors.white,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildImageDetail(CardEntity card, bool isTablet) {
    if (card.imagePath == null) {
      return const Center(child: Text('No image available'));
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 24 : 20,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        ),
        Expanded(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.4),
                  blurRadius: 8,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: card.imagePath!.startsWith('http')
                  ? PhotoView(
                      imageProvider: NetworkImage(card.imagePath!),
                      minScale: PhotoViewComputedScale.contained,
                      maxScale: PhotoViewComputedScale.covered * 2,
                      backgroundDecoration: const BoxDecoration(
                        color: Colors.black,
                      ),
                    )
                  : PhotoView(
                      imageProvider: FileImage(File(card.imagePath!)),
                      minScale: PhotoViewComputedScale.contained,
                      maxScale: PhotoViewComputedScale.covered * 2,
                      backgroundDecoration: const BoxDecoration(
                        color: Colors.black,
                      ),
                    ),
            ),
          ),
        ),
        if (card.body != null && card.body!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 16 : 14,
                color: Colors.white70,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildVideoDetail(CardEntity card, bool isTablet) {
    if (card.imagePath == null || _videoController == null) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.orangeAccent),
        ),
      );
    }

    if (!_videoController!.value.isInitialized) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.orangeAccent),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 24 : 20,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        ),
        Expanded(
          child: Center(
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.4),
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: AspectRatio(
                  aspectRatio: _videoController!.value.aspectRatio,
                  child: Stack(
                    alignment: Alignment.bottomCenter,
                    children: [
                      VideoPlayer(_videoController!),
                      _ControlsOverlay(controller: _videoController!),
                      VideoProgressIndicator(
                        _videoController!,
                        allowScrubbing: true,
                        colors: const VideoProgressColors(
                          playedColor: Colors.orangeAccent,
                          bufferedColor: Colors.white24,
                          backgroundColor: Colors.white10,
                        ),
                        padding: const EdgeInsets.all(16.0),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
        if (card.body != null && card.body!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 16 : 14,
                color: Colors.white70,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLinkDetail(CardEntity card, bool isTablet) {
    return SingleChildScrollView(
      physics: const BouncingScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 28 : 24,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 20),
          if (card.url != null) ...[
            GestureDetector(
              onTap: () => _launchUrl(card.url!),
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: const Color(0xFF2A2A2A),
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: Colors.purpleAccent.withOpacity(0.2),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(Icons.link, color: Colors.purpleAccent),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'URL',
                            style: TextStyle(color: Colors.grey, fontSize: 12),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            card.url!,
                            style: const TextStyle(
                              color: Colors.blueAccent,
                              decoration: TextDecoration.underline,
                              fontSize: 16,
                            ),
                          ),
                        ],
                      ),
                    ),
                    Container(
                      padding: const EdgeInsets.all(8),
                      decoration: BoxDecoration(
                        color: Colors.blueAccent.withOpacity(0.2),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.open_in_new,
                        color: Colors.blueAccent,
                        size: 20,
                      ),
                    ),
                  ],
                ),
              ),
            ),
            const SizedBox(height: 24),
          ],
          if (card.imagePath != null) ...[
            Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.3),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: card.imagePath!.startsWith('http')
                    ? Image.network(
                        card.imagePath!,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) =>
                            _buildErrorImage(),
                      )
                    : Image.file(
                        File(card.imagePath!),
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) =>
                            _buildErrorImage(),
                      ),
              ),
            ),
            const SizedBox(height: 24),
          ],
          if (card.body != null && card.body!.isNotEmpty) ...[
            const Divider(color: Colors.grey, height: 32),
            Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 18 : 16,
                color: Colors.white,
                height: 1.5,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildErrorImage() {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        color: const Color(0xFF2A2A2A),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.broken_image, color: Colors.grey[400], size: 48),
            const SizedBox(height: 12),
            Text(
              'Image not available',
              style: TextStyle(color: Colors.grey[400]),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _launchUrl(String urlString) async {
    try {
      final url = Uri.parse(urlString);
      if (await url_launcher.canLaunchUrl(url)) {
        await url_launcher.launchUrl(url);
      }
    } catch (e) {
      // Show error
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Could not open URL'),
            backgroundColor: Colors.red.shade700,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }
}

class _ControlsOverlay extends StatefulWidget {
  const _ControlsOverlay({required this.controller});

  final VideoPlayerController controller;

  @override
  State<_ControlsOverlay> createState() => _ControlsOverlayState();
}

class _ControlsOverlayState extends State<_ControlsOverlay> {
  bool _hideControls = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        setState(() {
          _hideControls = !_hideControls;
        });
      },
      child: AnimatedOpacity(
        opacity: _hideControls ? 0.0 : 1.0,
        duration: const Duration(milliseconds: 300),
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black.withOpacity(0.0),
                Colors.black.withOpacity(0.5),
              ],
            ),
          ),
          child: Center(
            child: IconButton(
              onPressed: () {
                setState(() {
                  widget.controller.value.isPlaying
                      ? widget.controller.pause()
                      : widget.controller.play();
                });
              },
              icon: Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.black38,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 2,
                    ),
                  ],
                ),
                child: Icon(
                  widget.controller.value.isPlaying
                      ? Icons.pause
                      : Icons.play_arrow,
                  size: 32.0,
                  color: Colors.white,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\home_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:async';
import '../theme/app_theme.dart';
import '../../bloc/main_grid/main_grid_bloc.dart';
import '../../bloc/main_grid/main_grid_event.dart';
import '../../data/repository/card_repository.dart';
import '../widgets/grid/main_grid_view.dart';
import '../widgets/card/add_text_card_modal.dart';
import '../widgets/card/add_image_card_modal.dart';
import '../widgets/card/add_link_card_modal.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  late final MainGridBloc _mainGridBloc;
  final TextEditingController _searchController = TextEditingController();
  int _selectedIndex = 0;
  Timer? _searchDebounceTimer;

  // Define the navigation items
  final List<_NavItem> _navItems = const [
    _NavItem(label: 'Everything', icon: Icons.grid_view_rounded),
    _NavItem(label: 'Spaces', icon: Icons.folder_rounded),
    _NavItem(label: 'Serendipity', icon: Icons.auto_awesome),
  ];

  @override
  void initState() {
    super.initState();
    // Initialize BLoC with repository
    _mainGridBloc = MainGridBloc(cardRepository: CardRepository());

    // Setup search controller listener
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _mainGridBloc.close(); // Clean up the BLoC when screen is disposed
    super.dispose();
  }

  void _onSearchChanged() {
    // Cancel previous debounce timer
    _searchDebounceTimer?.cancel();

    final query = _searchController.text;

    // Debounce search for 300ms to avoid excessive DB queries
    _searchDebounceTimer = Timer(const Duration(milliseconds: 300), () {
      _mainGridBloc.add(SearchQueryChanged(query));
    });
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => _mainGridBloc,
      child: Scaffold(
        backgroundColor:
            AppTheme.scaffoldBackgroundColor, // Material 3 dark theme
        appBar: _buildAppBar(),
        body: const MainGridView(),
        bottomNavigationBar: _buildBottomNavBar(),
        floatingActionButton: AnimatedScale(
          scale: _searchController.text.isEmpty ? 1.0 : 0.0,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
          child: FloatingActionButton.extended(
            onPressed: () {
              // Add haptic feedback
              HapticFeedback.mediumImpact();
              _addNewCard(context);
            },
            backgroundColor: AppTheme.primaryColor,
            elevation: 6,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
            ),
            icon: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: const Icon(
                Icons.add,
                key: ValueKey('add-icon'),
                color: Colors.white,
              ),
            ),
            label: const Text('Create'),
          ),
        ),
      ),
    );
  }

  PreferredSizeWidget _buildAppBar() {
    return AppBar(
      backgroundColor: AppTheme.surfaceVariantColor,
      elevation: 0,
      title: const Text(
        'Retainly',
        style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
      ),
      actions: [
        IconButton(
          icon: const Icon(Icons.notifications_outlined, color: Colors.white70),
          onPressed: () {
            // Show notification placeholder
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Notifications coming soon!'),
                duration: Duration(seconds: 1),
                behavior: SnackBarBehavior.floating,
              ),
            );
          },
        ),
        const SizedBox(width: 8),
      ],
      bottom: PreferredSize(
        preferredSize: const Size.fromHeight(65),
        child: Padding(
          padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
          child: _buildSearchBar(),
        ),
      ),
    );
  }

  Widget _buildSearchBar() {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor.withOpacity(0.7),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black12.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: _searchController,
        style: const TextStyle(color: Colors.white),
        textInputAction: TextInputAction.search,
        decoration: InputDecoration(
          hintText: 'Search cards...',
          hintStyle: TextStyle(color: Colors.grey[400]),
          prefixIcon: const Icon(Icons.search, color: AppTheme.primaryColor),
          suffixIcon: _searchController.text.isNotEmpty
              ? IconButton(
                  icon: Container(
                    decoration: BoxDecoration(
                      color: Colors.grey.withOpacity(0.3),
                      shape: BoxShape.circle,
                    ),
                    padding: const EdgeInsets.all(2),
                    child: const Icon(
                      Icons.close,
                      color: Colors.white70,
                      size: 14,
                    ),
                  ),
                  onPressed: () {
                    _searchController.clear();
                    _mainGridBloc.add(const ClearSearch());
                    FocusScope.of(context).unfocus();
                  },
                )
              : null,
          filled: true,
          fillColor: Colors.transparent,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          contentPadding: const EdgeInsets.symmetric(vertical: 12.0),
        ),
        onSubmitted: (value) {
          if (value.isNotEmpty) {
            FocusScope.of(context).unfocus();
          }
        },
      ),
    );
  }

  Widget _buildBottomNavBar() {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.surfaceVariantColor,
        boxShadow: const [
          BoxShadow(
            color: Colors.black26,
            blurRadius: 8,
            offset: Offset(0, -2),
          ),
        ],
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: List.generate(_navItems.length, (index) {
              final isSelected = index == _selectedIndex;

              return InkWell(
                onTap: () {
                  HapticFeedback.lightImpact();
                  setState(() => _selectedIndex = index);
                },
                borderRadius: BorderRadius.circular(12),
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? AppTheme.primaryColor.withOpacity(0.2)
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        _navItems[index].icon,
                        color: isSelected ? AppTheme.primaryColor : Colors.grey,
                      ),
                      const SizedBox(height: 4),
                      Text(
                        _navItems[index].label,
                        style: TextStyle(
                          color: isSelected
                              ? AppTheme.primaryColor
                              : Colors.grey,
                          fontSize: 12,
                          fontWeight: isSelected
                              ? FontWeight.w600
                              : FontWeight.normal,
                        ),
                      ),
                    ],
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Future<void> _addNewCard(BuildContext context) async {
    final action = await showModalBottomSheet<_FabAction>(
      context: context,
      backgroundColor: const Color(0xFF1A1A1A),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (_) => _FabOptionsSheet(),
    );

    if (action == _FabAction.text) {
      final result = await showModalBottomSheet<bool>(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) => const AddTextCardModal(),
      );
      if (result == true) {
        _mainGridBloc.add(const LoadCards(refresh: true));
      }
    } else if (action == _FabAction.image) {
      // Ask for image source
      final source = await showModalBottomSheet<ImageSource>(
        context: context,
        backgroundColor: const Color(0xFF1A1A1A),
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
        ),
        builder: (_) => _ImageSourceSheet(),
      );
      if (source != null) {
        final picker = ImagePicker();
        final picked = await picker.pickImage(source: source, imageQuality: 95);
        if (picked != null) {
          final file = File(picked.path);
          final result = await showModalBottomSheet<bool>(
            context: context,
            isScrollControlled: true,
            backgroundColor: Colors.transparent,
            builder: (_) => AddImageCardModal(imageFile: file),
          );
          if (result == true) {
            _mainGridBloc.add(const LoadCards(refresh: true));
          }
        }
      }
    } else if (action == _FabAction.link) {
      final result = await showModalBottomSheet<bool>(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) => const AddLinkCardModal(),
      );
      if (result == true) {
        _mainGridBloc.add(const LoadCards(refresh: true));
      }
    }
  }
}

enum _FabAction { text, image, link }

class _FabOptionsSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              border: Border(
                bottom: BorderSide(
                  color: AppTheme.dividerColor.withOpacity(0.5),
                  width: 1,
                ),
              ),
            ),
            child: const Center(
              child: Text(
                'Create New Card',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),

          // Card options
          _buildOptionItem(
            context,
            icon: Icons.text_snippet,
            title: 'Text Card',
            subtitle: 'Create a card with formatted text',
            action: _FabAction.text,
            color: Colors.blue,
          ),
          _buildOptionItem(
            context,
            icon: Icons.image,
            title: 'Image Card',
            subtitle: 'Upload an image with optional caption',
            action: _FabAction.image,
            color: Colors.green,
          ),
          _buildOptionItem(
            context,
            icon: Icons.link,
            title: 'Link Card',
            subtitle: 'Save a link with preview',
            action: _FabAction.link,
            color: Colors.purple,
          ),

          // Bottom padding
          const SizedBox(height: 8),
        ],
      ),
    );
  }

  Widget _buildOptionItem(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required _FabAction action,
    required Color color,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () {
            HapticFeedback.mediumImpact();
            Navigator.of(context).pop(action);
          },
          borderRadius: BorderRadius.circular(12),
          child: Ink(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: AppTheme.surfaceVariantColor,
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, color: color, size: 24),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        subtitle,
                        style: TextStyle(color: Colors.grey[400], fontSize: 12),
                      ),
                    ],
                  ),
                ),
                const Icon(
                  Icons.arrow_forward_ios,
                  color: Colors.grey,
                  size: 16,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _ImageSourceSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              border: Border(
                bottom: BorderSide(
                  color: AppTheme.dividerColor.withOpacity(0.5),
                  width: 1,
                ),
              ),
            ),
            child: const Center(
              child: Text(
                'Select Image Source',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),

          // Source options with grid layout
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildSourceOption(
                  context,
                  icon: Icons.photo_library,
                  label: 'Gallery',
                  source: ImageSource.gallery,
                  color: Colors.blue,
                ),
                _buildSourceOption(
                  context,
                  icon: Icons.photo_camera,
                  label: 'Camera',
                  source: ImageSource.camera,
                  color: Colors.green,
                ),
              ],
            ),
          ),

          // Bottom padding
          const SizedBox(height: 16),
        ],
      ),
    );
  }

  Widget _buildSourceOption(
    BuildContext context, {
    required IconData icon,
    required String label,
    required ImageSource source,
    required Color color,
  }) {
    return InkWell(
      onTap: () {
        HapticFeedback.mediumImpact();
        Navigator.of(context).pop(source);
      },
      borderRadius: BorderRadius.circular(16),
      child: Container(
        width: 120,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: AppTheme.surfaceVariantColor,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color.withOpacity(0.3), width: 1),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: color.withOpacity(0.2),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: color, size: 32),
            ),
            const SizedBox(height: 12),
            Text(
              label,
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Helper class for navigation items
class _NavItem {
  final String label;
  final IconData icon;

  const _NavItem({required this.label, required this.icon});
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\landing_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';

class LandingScreen extends StatelessWidget {
  const LandingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Spacer(),
              const Icon(Icons.lock_outline, size: 80),
              const SizedBox(height: 24),
              Text(
                'Retainly',
                style: Theme.of(context).textTheme.headlineLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              Text(
                'A minimal, secure place to retain the things that matter.',
                style: Theme.of(context).textTheme.bodyLarge,
                textAlign: TextAlign.center,
              ),
              const Spacer(),
              SizedBox(
                height: 48,
                child: FilledButton(
                  onPressed: () => Navigator.of(context).pushNamed('/home'),
                  child: const Text('Open Vault'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\splash_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'landing_screen.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _fade;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );
    _fade = CurvedAnimation(parent: _controller, curve: Curves.easeIn);
    _controller.forward();

    Future.delayed(const Duration(seconds: 2), () {
      if (!mounted) return;
      Navigator.of(context).pushReplacement(
        PageRouteBuilder(
          settings: const RouteSettings(name: '/landing'),
          pageBuilder: (context, animation, secondaryAnimation) =>
              const LandingScreen(),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(opacity: animation, child: child);
          },
          transitionDuration: const Duration(milliseconds: 400),
        ),
      );
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: FadeTransition(
          opacity: _fade,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              Icon(Icons.lock_outline, size: 72),
              SizedBox(height: 16),
              Text('Retainly', style: TextStyle(fontSize: 20)),
            ],
          ),
        ),
      ),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\theme ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\theme\app_theme.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';

class AppTheme {
  // Define our color palette
  static const Color primaryColor = Color(0xFFFF6A00);
  static const Color surfaceColor = Color(0xFF121212);
  static const Color surfaceVariantColor = Color(0xFF1C1C1E);
  static const Color onSurfaceColor = Colors.white70;
  static const Color onPrimaryColor = Colors.white;
  static const Color errorColor = Color(0xFFCF6679);
  static const Color cardColor = Color(0xFF1C1C1E);
  static const Color scaffoldBackgroundColor = Color(0xFF121212);
  static const Color dividerColor = Color(0xFF383838);

  // Material 3 light theme (not used, but included for completeness)
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.light(
        primary: primaryColor,
        onPrimary: Colors.white,
        secondary: primaryColor.withOpacity(0.8),
        onSecondary: Colors.white,
        surface: Colors.white,
        onSurface: Colors.black87,
        background: const Color(0xFFF5F5F5),
        error: const Color(0xFFB00020),
      ),
    );
  }

  // Material 3 dark theme
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: const ColorScheme.dark(
        primary: primaryColor,
        onPrimary: onPrimaryColor,
        secondary: primaryColor,
        onSecondary: onPrimaryColor,
        surface: surfaceColor,
        onSurface: onSurfaceColor,
        background: scaffoldBackgroundColor,
        error: errorColor,
      ),
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      cardColor: cardColor,
      dividerColor: dividerColor,

      // Text themes
      textTheme: const TextTheme(
        bodyLarge: TextStyle(color: onSurfaceColor, fontSize: 16),
        bodyMedium: TextStyle(color: onSurfaceColor, fontSize: 14),
        bodySmall: TextStyle(color: onSurfaceColor, fontSize: 12),
        titleLarge: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 22,
        ),
        titleMedium: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.w500,
          fontSize: 16,
        ),
        titleSmall: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
      ),

      // AppBar theme
      appBarTheme: const AppBarTheme(
        backgroundColor: surfaceVariantColor,
        elevation: 0,
        centerTitle: true,
        titleTextStyle: TextStyle(
          color: Colors.white,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: Colors.white),
      ),

      // Card theme
      cardTheme: CardThemeData(
        color: cardColor,
        elevation: 2,
        shadowColor: Colors.black.withOpacity(0.2),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        clipBehavior: Clip.antiAlias,
      ),

      // Button themes
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: primaryColor,
          foregroundColor: onPrimaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          textStyle: const TextStyle(fontWeight: FontWeight.w600),
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          textStyle: const TextStyle(fontWeight: FontWeight.w600),
        ),
      ),

      // Input decoration theme
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surfaceColor,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: primaryColor, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
        hintStyle: TextStyle(color: onSurfaceColor.withOpacity(0.6)),
        labelStyle: TextStyle(color: onSurfaceColor.withOpacity(0.8)),
        errorStyle: const TextStyle(color: errorColor),
      ),

      // Floating action button theme
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: primaryColor,
        foregroundColor: onPrimaryColor,
        shape: CircleBorder(),
      ),

      // Dialog theme
      dialogTheme: DialogThemeData(
        backgroundColor: surfaceVariantColor,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        titleTextStyle: const TextStyle(
          color: Colors.white,
          fontSize: 18,
          fontWeight: FontWeight.bold,
        ),
        contentTextStyle: const TextStyle(color: onSurfaceColor, fontSize: 14),
      ),

      // Bottom sheet theme
      bottomSheetTheme: const BottomSheetThemeData(
        backgroundColor: surfaceVariantColor,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
        ),
      ),

      // Snackbar theme
      snackBarTheme: SnackBarThemeData(
        backgroundColor: surfaceVariantColor,
        contentTextStyle: const TextStyle(color: onSurfaceColor),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),

      // Divider theme
      dividerTheme: const DividerThemeData(
        color: dividerColor,
        thickness: 1,
        space: 1,
      ),

      // Icon theme
      iconTheme: const IconThemeData(color: onSurfaceColor, size: 24),

      // List tile theme
      listTileTheme: const ListTileThemeData(
        iconColor: primaryColor,
        textColor: onSurfaceColor,
      ),

      // Slider theme
      sliderTheme: SliderThemeData(
        activeTrackColor: primaryColor,
        thumbColor: primaryColor,
        overlayColor: primaryColor.withOpacity(0.2),
        valueIndicatorColor: primaryColor,
        valueIndicatorTextStyle: const TextStyle(color: onPrimaryColor),
      ),
    );
  }

  // Page transition builders
  static PageRouteBuilder<T> fadeTransition<T>({
    required Widget page,
    required RouteSettings settings,
  }) {
    return PageRouteBuilder<T>(
      settings: settings,
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
      transitionDuration: const Duration(milliseconds: 220),
    );
  }

  static PageRouteBuilder<T> slideAndFadeTransition<T>({
    required Widget page,
    required RouteSettings settings,
  }) {
    return PageRouteBuilder<T>(
      settings: settings,
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        const begin = Offset(0.0, 0.05);
        const end = Offset.zero;
        const curve = Curves.easeOutCubic;

        var tween = Tween(
          begin: begin,
          end: end,
        ).chain(CurveTween(curve: curve));

        return SlideTransition(
          position: animation.drive(tween),
          child: FadeTransition(opacity: animation, child: child),
        );
      },
      transitionDuration: const Duration(milliseconds: 220),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card_grid_widget.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card_list_widget.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class CardListWidget extends StatefulWidget {
  const CardListWidget({super.key});

  @override
  CardListWidgetState createState() => CardListWidgetState();
}

class CardListWidgetState extends State<CardListWidget> {
  final _repository = CardRepository();
  List<CardEntity> _cards = [];
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadCards();
  }

  Future<void> _loadCards() async {
    try {
      setState(() {
        _isLoading = true;
        _error = null;
      });

      final cards = await _repository.getAllCards();

      setState(() {
        _cards = cards;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = 'Failed to load cards: $e';
        _isLoading = false;
      });
    }
  }

  // Make _loadCards method public so it can be called from outside
  void refreshCards() {
    _loadCards();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(_error!, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 16),
            ElevatedButton(onPressed: _loadCards, child: const Text('Retry')),
          ],
        ),
      );
    }

    if (_cards.isEmpty) {
      return const Center(
        child: Text('No cards yet. Add a card using the + button.'),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: _cards.length,
      itemBuilder: (context, index) {
        final card = _cards[index];
        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: ListTile(
            title: Text(card.content),
            subtitle: Text(card.body ?? 'No content'),
            trailing: Text(
              DateTime.fromMillisecondsSinceEpoch(
                card.createdAt,
              ).toString().split('.')[0],
            ),
          ),
        );
      },
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\card ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_card_options_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_image_card_modal.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';

class AddImageCardModal extends StatefulWidget {
  final File? imageFile;
  final String? imagePath;
  final bool autofocusSave;
  const AddImageCardModal({
    super.key,
    this.imageFile,
    this.imagePath,
    this.autofocusSave = false,
  });

  @override
  State<AddImageCardModal> createState() => _AddImageCardModalState();
}

class _AddImageCardModalState extends State<AddImageCardModal> {
  final _captionController = TextEditingController();
  File? _fileToShow;

  @override
  void initState() {
    super.initState();
    if (widget.imageFile != null) {
      _fileToShow = widget.imageFile;
    } else if (widget.imagePath != null) {
      _fileToShow = File(widget.imagePath!);
    }
  }

  @override
  void dispose() {
    _captionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => AddCardBloc(cardRepository: CardRepository()),
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is AddCardSuccess) {
            Navigator.of(context).pop(true);
          } else if (state is AddCardFailure) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(SnackBar(content: Text('Failed: ${state.error}')));
          }
        },
        builder: (context, state) {
          return Material(
            // Use actual color instead of transparent for Material widget with TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Row(
                    children: [
                      const Text(
                        'Image Preview',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      const Spacer(),
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  if (_fileToShow != null)
                    AspectRatio(
                      aspectRatio: 1,
                      child: ClipRRect(
                        borderRadius: BorderRadius.circular(12),
                        child: Image.file(_fileToShow!, fit: BoxFit.cover),
                      ),
                    ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _captionController,
                    style: const TextStyle(color: Colors.white),
                    decoration: InputDecoration(
                      hintText: 'Add a caption (optional)',
                      hintStyle: TextStyle(color: Colors.grey[400]),
                      filled: true,
                      fillColor: const Color(0xFF262626),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none,
                      ),
                      contentPadding: const EdgeInsets.all(14),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text(
                          'CANCEL',
                          style: TextStyle(color: Colors.grey),
                        ),
                      ),
                      const SizedBox(width: 12),
                      ElevatedButton(
                        autofocus: widget.autofocusSave,
                        onPressed: state is AddCardSaving
                            ? null
                            : () {
                                context.read<AddCardBloc>().add(
                                  AddImageCardRequested(
                                    imagePath: _fileToShow?.path ?? '',
                                    caption:
                                        _captionController.text.trim().isEmpty
                                        ? null
                                        : _captionController.text.trim(),
                                  ),
                                );
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.orangeAccent,
                          foregroundColor: Colors.white,
                        ),
                        child: state is AddCardSaving
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(
                                    Colors.white,
                                  ),
                                ),
                              )
                            : const Text('SAVE'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_link_card_modal.dart
=========================================
--- Content Start ---
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';

class AddLinkCardModal extends StatefulWidget {
  final String? initialUrl;
  final String? initialTitle;
  final bool autofocusSave;
  const AddLinkCardModal({
    super.key,
    this.initialUrl,
    this.initialTitle,
    this.autofocusSave = false,
  });

  @override
  State<AddLinkCardModal> createState() => _AddLinkCardModalState();
}

class _AddLinkCardModalState extends State<AddLinkCardModal> {
  late final TextEditingController _urlController;
  late final TextEditingController _titleController;
  final _formKey = GlobalKey<FormState>();
  late final AddCardBloc _addCardBloc;

  bool _isUrlValid = false;
  bool _isFetching = false;
  String? _fetchError;
  Timer? _debounceTimer;

  @override
  void initState() {
    super.initState();
    _addCardBloc = AddCardBloc(cardRepository: CardRepository());
    _urlController = TextEditingController(text: widget.initialUrl ?? '');
    _titleController = TextEditingController(text: widget.initialTitle ?? '');
    _urlController.addListener(_onUrlChanged);
    if (widget.initialUrl != null && widget.initialUrl!.trim().isNotEmpty) {
      _isUrlValid = _isValidUrl(widget.initialUrl!);
    }
  }

  @override
  void dispose() {
    _debounceTimer?.cancel();
    _urlController.removeListener(_onUrlChanged);
    _urlController.dispose();
    _titleController.dispose();
    _addCardBloc.close();
    super.dispose();
  }

  void _onUrlChanged() {
    final url = _urlController.text.trim();
    final isValid = _isValidUrl(url);

    if (isValid != _isUrlValid) {
      setState(() {
        _isUrlValid = isValid;
        _fetchError = null;
      });

      // Only fetch if URL is valid
      if (isValid) {
        // Debounce the fetch operation
        _debounceTimer?.cancel();
        _debounceTimer = Timer(const Duration(milliseconds: 500), () {
          _fetchTitle();
        });
      }
    }
  }

  bool _isValidUrl(String url) {
    if (url.isEmpty) return false;

    // Simple URL validation using RegExp
    final RegExp urlRegExp = RegExp(
      r'^(https?:\/\/)?'
      r'(www\.)?'
      r'[-a-zA-Z0-9@:%._\+~#=]{1,256}'
      r'\.[a-zA-Z0-9()]{1,6}'
      r'([-a-zA-Z0-9()@:%_\+.~#?&//=]*)',
      caseSensitive: false,
      multiLine: false,
    );

    return urlRegExp.hasMatch(url);
  }

  Future<void> _fetchTitle() async {
    if (!_isUrlValid || _isFetching) return;

    setState(() {
      _isFetching = true;
      _fetchError = null;
    });

    try {
      final url = _urlController.text.trim();
      // URL normalization - ensure it starts with http:// or https://
      String normalizedUrl = url;
      if (!normalizedUrl.startsWith('http://') &&
          !normalizedUrl.startsWith('https://')) {
        normalizedUrl = 'https://$normalizedUrl';
      }

      // Update the URL field with normalized URL
      if (normalizedUrl != url) {
        _urlController.text = normalizedUrl;
      }

      // Add event to fetch title
      _addCardBloc.add(FetchTitleRequested(url: normalizedUrl));
    } catch (e) {
      setState(() {
        _fetchError = 'Failed to fetch title: ${e.toString()}';
        _isFetching = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _addCardBloc,
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is TitleFetched) {
            _titleController.text = state.title;
            setState(() {
              _isFetching = false;
            });
          } else if (state is AddCardFailure) {
            setState(() {
              _fetchError = state.error;
              _isFetching = false;
            });
          } else if (state is AddCardSuccess) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(content: Text('Link saved successfully')),
            );
            Navigator.of(context).pop(true);
          }
        },
        builder: (context, state) {
          return Material(
            // Don't use transparent color for Material widget when using TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Title bar
                    Row(
                      children: [
                        const Text(
                          'New Link Card',
                          style: TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        const Spacer(),
                        IconButton(
                          icon: const Icon(Icons.close, color: Colors.grey),
                          onPressed: () => Navigator.of(context).pop(),
                        ),
                      ],
                    ),

                    const SizedBox(height: 16),

                    // URL input field
                    TextFormField(
                      controller: _urlController,
                      autofocus: true,
                      keyboardType: TextInputType.url,
                      textInputAction: TextInputAction.next,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: 'Enter URL (https://example.com)',
                        hintStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                        suffixIcon: _isFetching
                            ? Container(
                                width: 24,
                                height: 24,
                                padding: const EdgeInsets.all(12),
                                child: const CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(
                                    Colors.white,
                                  ),
                                ),
                              )
                            : IconButton(
                                icon: Icon(
                                  Icons.refresh,
                                  color: _isUrlValid
                                      ? Colors.orangeAccent
                                      : Colors.grey,
                                ),
                                onPressed: _isUrlValid && !_isFetching
                                    ? _fetchTitle
                                    : null,
                                tooltip: 'Fetch page title',
                              ),
                        errorText: _fetchError,
                        errorMaxLines: 2,
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter a URL';
                        }
                        if (!_isValidUrl(value.trim())) {
                          return 'Please enter a valid URL';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 16),

                    // Title input field
                    TextFormField(
                      controller: _titleController,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        labelText: 'Title',
                        labelStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter a title';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 24),

                    // Action buttons
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          style: TextButton.styleFrom(
                            foregroundColor: Colors.grey,
                          ),
                          child: const Text('CANCEL'),
                        ),

                        const SizedBox(width: 16),

                        ElevatedButton(
                          autofocus: widget.autofocusSave,
                          onPressed:
                              (_isUrlValid &&
                                  !_isFetching &&
                                  state is! AddCardSaving)
                              ? () {
                                  if (_formKey.currentState?.validate() ??
                                      false) {
                                    final url = _urlController.text.trim();
                                    final title = _titleController.text.trim();

                                    _addCardBloc.add(
                                      AddLinkCardRequested(
                                        url: url,
                                        title: title,
                                      ),
                                    );
                                  }
                                }
                              : null,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.orangeAccent,
                            foregroundColor: Colors.white,
                          ),
                          child: state is AddCardSaving
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(
                                      Colors.white,
                                    ),
                                  ),
                                )
                              : const Text('SAVE'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_text_card_modal.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';

class AddTextCardModal extends StatefulWidget {
  final String? initialText;
  final bool autofocusSave;
  const AddTextCardModal({
    super.key,
    this.initialText,
    this.autofocusSave = false,
  });

  @override
  State<AddTextCardModal> createState() => _AddTextCardModalState();
}

class _AddTextCardModalState extends State<AddTextCardModal> {
  late final TextEditingController _textController;
  final _formKey = GlobalKey<FormState>();
  final List<String> _tags = [];
  final _tagController = TextEditingController();
  bool _isSaveEnabled = false;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController(text: widget.initialText ?? '');
    _textController.addListener(_validateInput);
    if (widget.initialText != null && widget.initialText!.trim().isNotEmpty) {
      _isSaveEnabled = true;
    }
  }

  @override
  void dispose() {
    _textController.removeListener(_validateInput);
    _textController.dispose();
    _tagController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final isValid = _textController.text.trim().length >= 2;
    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  void _addTag() {
    final tag = _tagController.text.trim();
    if (tag.isNotEmpty && !_tags.contains(tag)) {
      setState(() {
        _tags.add(tag);
        _tagController.clear();
      });
    }
  }

  void _removeTag(String tag) {
    setState(() {
      _tags.remove(tag);
    });
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => AddCardBloc(cardRepository: CardRepository()),
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is AddCardSuccess) {
            Navigator.of(context).pop(true);
          } else if (state is AddCardFailure) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(SnackBar(content: Text('Failed: ${state.error}')));
          }
        },
        builder: (context, state) {
          return Material(
            // Use actual color instead of transparent for Material widget with TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Title bar with close button
                    Row(
                      children: [
                        const Text(
                          'New Text Card',
                          style: TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        const Spacer(),
                        IconButton(
                          icon: const Icon(Icons.close, color: Colors.grey),
                          onPressed: () => Navigator.of(context).pop(),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),

                    // Note content input
                    TextFormField(
                      controller: _textController,
                      autofocus: true,
                      maxLines: 5,
                      minLines: 3,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: 'What\'s on your mind?',
                        hintStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().length < 2) {
                          return 'Please enter at least 2 characters';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 16),

                    // Tags input
                    Row(
                      children: [
                        Expanded(
                          child: TextFormField(
                            controller: _tagController,
                            style: const TextStyle(color: Colors.white),
                            decoration: InputDecoration(
                              hintText: 'Add a tag (optional)',
                              hintStyle: TextStyle(color: Colors.grey[400]),
                              filled: true,
                              fillColor: const Color(0xFF262626),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(
                                horizontal: 16,
                                vertical: 12,
                              ),
                              suffixIcon: IconButton(
                                icon: const Icon(
                                  Icons.add_circle,
                                  color: Colors.grey,
                                ),
                                onPressed: _addTag,
                              ),
                            ),
                            onFieldSubmitted: (_) => _addTag(),
                          ),
                        ),
                      ],
                    ),

                    // Tags display
                    if (_tags.isNotEmpty)
                      Container(
                        margin: const EdgeInsets.only(top: 12),
                        height: 32,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          itemCount: _tags.length,
                          itemBuilder: (context, index) {
                            return Container(
                              margin: const EdgeInsets.only(right: 8),
                              child: Chip(
                                backgroundColor: Colors.orangeAccent
                                    .withOpacity(0.3),
                                label: Text(
                                  _tags[index],
                                  style: const TextStyle(color: Colors.white),
                                ),
                                deleteIconColor: Colors.white70,
                                onDeleted: () => _removeTag(_tags[index]),
                              ),
                            );
                          },
                        ),
                      ),

                    const SizedBox(height: 24),

                    // Action buttons
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        // Cancel button
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          style: TextButton.styleFrom(
                            foregroundColor: Colors.grey,
                          ),
                          child: const Text('CANCEL'),
                        ),

                        const SizedBox(width: 16),

                        // Save button
                        ElevatedButton(
                          autofocus: widget.autofocusSave,
                          onPressed: _isSaveEnabled && state is! AddCardSaving
                              ? () {
                                  if (_formKey.currentState?.validate() ??
                                      false) {
                                    context.read<AddCardBloc>().add(
                                      AddTextCardRequested(
                                        content: _textController.text.trim(),
                                        tags: _tags,
                                      ),
                                    );
                                  }
                                }
                              : null,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.orangeAccent,
                            disabledBackgroundColor: Colors.grey,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(
                              horizontal: 24,
                              vertical: 12,
                            ),
                          ),
                          child: state is AddCardSaving
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(
                                      Colors.white,
                                    ),
                                  ),
                                )
                              : const Text('SAVE'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\card_tile.dart
=========================================
--- Content Start ---


--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\grid ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\card_tile.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'dart:ui';
import 'dart:math' as math;
import 'package:animations/animations.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../../data/card_entity.dart';
import '../../../data/repository/card_repository.dart';
import '../../../ui/screens/card_detail_screen.dart';
import '../../../ui/theme/app_theme.dart';
import '../../../ui/widgets/overlay/card_preview_overlay.dart';

class CardTile extends StatefulWidget {
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const CardTile({super.key, required this.card, this.onTap, this.onDelete});

  @override
  State<CardTile> createState() => _CardTileState();
}

class _CardTileState extends State<CardTile>
    with SingleTickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 120),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.98).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  // Show card preview overlay on long press
  void _showCardPreview(BuildContext context) {
    showCardPreviewOverlay(
      context: context,
      card: widget.card,
      onEdit: () {
        // For now, just open the detail screen which has edit functionality
        if (widget.card.id != null) {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (_) => CardDetailScreen(cardId: widget.card.id!),
            ),
          );
        }
      },
      cardRepository: CardRepository(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _scaleAnimation,
      builder: (context, child) {
        return Transform.scale(scale: _scaleAnimation.value, child: child);
      },
      child: OpenContainer(
        transitionType: ContainerTransitionType.fadeThrough,
        transitionDuration: const Duration(milliseconds: 300),
        closedShape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16.0),
        ),
        closedColor: AppTheme.surfaceVariantColor,
        closedElevation: 2,
        openElevation: 0,
        openBuilder: (context, _) => widget.card.id != null
            ? CardDetailScreen(cardId: widget.card.id!)
            : const SizedBox(),
        closedBuilder: (context, openContainer) {
          final VoidCallback opener = openContainer;
          return GestureDetector(
            onTapDown: (_) => _scaleController.forward(),
            onTapUp: (_) => _scaleController.reverse(),
            onTapCancel: () => _scaleController.reverse(),
            onLongPress: () => _showCardPreview(context),
            child: Material(
              color: Colors.transparent,
              child: InkWell(
                onTap: widget.onTap ?? opener,
                borderRadius: BorderRadius.circular(16),
                splashColor: Colors.white10,
                highlightColor: Colors.white10,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Thumbnail area with better aspect ratio
                    AspectRatio(
                      aspectRatio: 4 / 3,
                      child: Container(
                        decoration: BoxDecoration(
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                          color: Colors.black,
                        ),
                        child: ClipRRect(
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                          child: Stack(
                            fit: StackFit.expand,
                            children: [
                              // Thumbnail or placeholder
                              _buildThumbnail(),

                              // Gradient overlay for better readability
                              Positioned.fill(
                                child: DecoratedBox(
                                  decoration: BoxDecoration(
                                    gradient: LinearGradient(
                                      begin: Alignment.topCenter,
                                      end: Alignment.bottomCenter,
                                      colors: [
                                        Colors.transparent,
                                        Colors.black.withOpacity(0.6),
                                      ],
                                      stops: const [0.7, 1.0],
                                    ),
                                  ),
                                ),
                              ),

                              // Card type indicator
                              Positioned(
                                top: 8,
                                left: 8,
                                child: _buildTypeIndicator(),
                              ),

                              // Play icon overlay for videos
                              if (widget.card.type == 'video')
                                const Center(
                                  child: CircleAvatar(
                                    backgroundColor: Colors.black45,
                                    radius: 24,
                                    child: Icon(
                                      Icons.play_arrow,
                                      color: Colors.white,
                                      size: 32,
                                    ),
                                  ),
                                ),

                              // Delete button (top-right)
                              if (widget.onDelete != null)
                                Positioned(
                                  top: 8,
                                  right: 8,
                                  child: GestureDetector(
                                    onTap: widget.onDelete,
                                    child: Container(
                                      padding: const EdgeInsets.all(6),
                                      decoration: BoxDecoration(
                                        color: Colors.black.withOpacity(0.6),
                                        shape: BoxShape.circle,
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.black.withOpacity(
                                              0.3,
                                            ),
                                            blurRadius: 4,
                                          ),
                                        ],
                                      ),
                                      child: const Icon(
                                        Icons.delete_outline,
                                        size: 16,
                                        color: Colors.white,
                                      ),
                                    ),
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ),
                    ),

                    // Content info area
                    Padding(
                      padding: const EdgeInsets.all(12),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            widget.card.content,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: const TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.w500,
                              fontSize: 15,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Row(
                            children: [
                              _buildTypeIcon(),
                              const SizedBox(width: 6),
                              Text(
                                _getFormattedDate(),
                                style: TextStyle(
                                  color: Colors.grey[400],
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildThumbnail() {
    // Don't use setState at all during build - we'll just render directly
    // The loading state will be updated separately after the widget is built

    // For images
    if (widget.card.type == 'image' && widget.card.imagePath != null) {
      return _buildImageWidget(widget.card.imagePath!);
    }

    // For videos (just showing thumbnail)
    if (widget.card.type == 'video' && widget.card.imagePath != null) {
      return _buildImageWidget(widget.card.imagePath!);
    }

    // For links with preview image
    if (widget.card.type == 'link' && widget.card.url != null) {
      if (widget.card.imagePath != null) {
        return _buildImageWidget(widget.card.imagePath!);
      }

      // Link without image - placeholder with link icon
      return _buildPlaceholderWithIcon(Icons.link);
    }

    // For text cards - show text snippet on gradient background
    if (widget.card.type == 'text') {
      return Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              AppTheme.primaryColor.withOpacity(0.7),
              AppTheme.primaryColor,
            ],
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              widget.card.body?.substring(
                    0,
                    widget.card.body!.length > 50
                        ? 50
                        : widget.card.body!.length,
                  ) ??
                  widget.card.content,
              maxLines: 4,
              textAlign: TextAlign.center,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 15,
                fontWeight: FontWeight.w400,
              ),
            ),
          ),
        ),
      );
    }

    // Default placeholder
    return _buildPlaceholderWithIcon(Icons.note);
  }

  Widget _buildImageWidget(String path) {
    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.cover,
        placeholder: (context, url) => _buildShimmerEffect(),
        errorWidget: (context, url, error) =>
            _buildPlaceholderWithIcon(Icons.broken_image),
        fadeInDuration: const Duration(milliseconds: 300),
      );
    }

    // Local file
    try {
      return Image.file(
        File(path),
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return _buildPlaceholderWithIcon(Icons.broken_image);
        },
      );
    } catch (e) {
      return _buildPlaceholderWithIcon(Icons.broken_image);
    }
  }

  Widget _buildShimmerEffect() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[800]!,
      highlightColor: Colors.grey[700]!,
      child: Container(color: Colors.grey[800]),
    );
  }

  Widget _buildPlaceholderWithIcon(IconData icon) {
    return Container(
      color: AppTheme.surfaceVariantColor,
      child: Center(child: Icon(icon, size: 42, color: Colors.grey[400])),
    );
  }

  String _getFormattedDate() {
    final date = DateTime.fromMillisecondsSinceEpoch(widget.card.createdAt);
    final now = DateTime.now();

    // Today
    if (date.year == now.year &&
        date.month == now.month &&
        date.day == now.day) {
      return 'Today ${_formatTime(date)}';
    }

    // Yesterday
    final yesterday = now.subtract(const Duration(days: 1));
    if (date.year == yesterday.year &&
        date.month == yesterday.month &&
        date.day == yesterday.day) {
      return 'Yesterday ${_formatTime(date)}';
    }

    // Within a week
    if (now.difference(date).inDays < 7) {
      return '${_getDayName(date)} ${_formatTime(date)}';
    }

    // Older
    return '${date.day}/${date.month}/${date.year}';
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  String _getDayName(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Mon';
      case 2:
        return 'Tue';
      case 3:
        return 'Wed';
      case 4:
        return 'Thu';
      case 5:
        return 'Fri';
      case 6:
        return 'Sat';
      case 7:
        return 'Sun';
      default:
        return '';
    }
  }

  Widget _buildTypeIndicator() {
    Color backgroundColor;
    String label;

    switch (widget.card.type) {
      case 'image':
        backgroundColor = Colors.blue.withOpacity(0.8);
        label = 'IMAGE';
        break;
      case 'video':
        backgroundColor = Colors.red.withOpacity(0.8);
        label = 'VIDEO';
        break;
      case 'link':
        backgroundColor = Colors.purple.withOpacity(0.8);
        label = 'LINK';
        break;
      case 'text':
        backgroundColor = AppTheme.primaryColor.withOpacity(0.8);
        label = 'TEXT';
        break;
      default:
        backgroundColor = Colors.grey.withOpacity(0.8);
        label = 'NOTE';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 3),
        ],
      ),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildTypeIcon() {
    IconData iconData;
    Color iconColor;

    switch (widget.card.type) {
      case 'image':
        iconData = Icons.image_outlined;
        iconColor = Colors.blue;
        break;
      case 'video':
        iconData = Icons.videocam_outlined;
        iconColor = Colors.red;
        break;
      case 'link':
        iconData = Icons.link;
        iconColor = Colors.purple;
        break;
      case 'text':
        iconData = Icons.text_snippet_outlined;
        iconColor = AppTheme.primaryColor;
        break;
      default:
        iconData = Icons.note_outlined;
        iconColor = Colors.grey;
    }

    return Icon(iconData, size: 12, color: iconColor);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\card_tile_new.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'dart:ui';
import 'package:animations/animations.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../../data/card_entity.dart';
import '../../../ui/screens/card_detail_screen.dart';
import '../../../ui/theme/app_theme.dart';

class CardTile extends StatefulWidget {
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const CardTile({super.key, required this.card, this.onTap, this.onDelete});

  @override
  State<CardTile> createState() => _CardTileState();
}

class _CardTileState extends State<CardTile>
    with SingleTickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 120),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.98).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Create a stateless wrapper around OpenContainer to avoid setState during build
    return _StatelessCardWrapper(
      scaleAnimation: _scaleAnimation,
      scaleController: _scaleController,
      card: widget.card,
      onTap: widget.onTap,
      onDelete: widget.onDelete,
    );
  }
}

// Stateless wrapper to avoid setState during build issues
class _StatelessCardWrapper extends StatelessWidget {
  final Animation<double> scaleAnimation;
  final AnimationController scaleController;
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const _StatelessCardWrapper({
    required this.scaleAnimation,
    required this.scaleController,
    required this.card,
    this.onTap,
    this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: scaleAnimation,
      builder: (context, child) {
        return Transform.scale(scale: scaleAnimation.value, child: child);
      },
      child: _buildOpenContainer(context),
    );
  }

  Widget _buildOpenContainer(BuildContext context) {
    return OpenContainer(
      transitionType: ContainerTransitionType.fadeThrough,
      transitionDuration: const Duration(milliseconds: 300),
      closedShape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16.0),
      ),
      closedColor: AppTheme.surfaceVariantColor,
      closedElevation: 2,
      openElevation: 0,
      openBuilder: (context, _) {
        if (card.id != null) {
          return CardDetailScreen(cardId: card.id!);
        }
        return const SizedBox();
      },
      closedBuilder: (context, openContainer) {
        return GestureDetector(
          onTapDown: (_) => scaleController.forward(),
          onTapUp: (_) => scaleController.reverse(),
          onTapCancel: () => scaleController.reverse(),
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: onTap ?? openContainer,
              borderRadius: BorderRadius.circular(16),
              splashColor: Colors.white10,
              highlightColor: Colors.white10,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Thumbnail area with better aspect ratio
                  AspectRatio(
                    aspectRatio: 4 / 3,
                    child: Container(
                      decoration: BoxDecoration(
                        borderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(16),
                          topRight: Radius.circular(16),
                        ),
                        color: Colors.black,
                      ),
                      child: ClipRRect(
                        borderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(16),
                          topRight: Radius.circular(16),
                        ),
                        child: Stack(
                          fit: StackFit.expand,
                          children: [
                            // Thumbnail or placeholder
                            _buildThumbnail(),

                            // Gradient overlay for better readability
                            Positioned.fill(
                              child: DecoratedBox(
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    begin: Alignment.topCenter,
                                    end: Alignment.bottomCenter,
                                    colors: [
                                      Colors.transparent,
                                      Colors.black.withOpacity(0.6),
                                    ],
                                    stops: const [0.7, 1.0],
                                  ),
                                ),
                              ),
                            ),

                            // Card type indicator (top-left corner)
                            Positioned(
                              top: 8,
                              left: 8,
                              child: _buildTypeIndicator(),
                            ),

                            // Play icon overlay for videos
                            if (card.type == 'video')
                              const Center(
                                child: CircleAvatar(
                                  backgroundColor: Colors.black45,
                                  radius: 24,
                                  child: Icon(
                                    Icons.play_arrow,
                                    color: Colors.white,
                                    size: 32,
                                  ),
                                ),
                              ),

                            // Delete button (positioned in top-right corner)
                            if (onDelete != null)
                              Positioned(
                                top: 8,
                                right: 8,
                                child: GestureDetector(
                                  onTap: onDelete,
                                  child: Container(
                                    padding: const EdgeInsets.all(6),
                                    decoration: BoxDecoration(
                                      color: Colors.black.withOpacity(0.6),
                                      shape: BoxShape.circle,
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black.withOpacity(0.3),
                                          blurRadius: 4,
                                        ),
                                      ],
                                    ),
                                    child: const Icon(
                                      Icons.delete_outline,
                                      size: 16,
                                      color: Colors.white,
                                    ),
                                  ),
                                ),
                              ),
                          ],
                        ),
                      ),
                    ),
                  ),

                  // Content info area with better styling
                  Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Card title with ellipsis
                        Text(
                          card.content,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w500,
                            fontSize: 15,
                          ),
                        ),

                        // Optional subtext (date)
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            _buildTypeIcon(),
                            const SizedBox(width: 6),
                            Text(
                              _getFormattedDate(),
                              style: TextStyle(
                                color: Colors.grey[400],
                                fontSize: 12,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildThumbnail() {
    // For images
    if (card.type == 'image' && card.imagePath != null) {
      return _buildImageWidget(card.imagePath!);
    }

    // For videos (just showing thumbnail)
    if (card.type == 'video' && card.imagePath != null) {
      return _buildImageWidget(card.imagePath!);
    }

    // For links with preview image
    if (card.type == 'link' && card.url != null) {
      if (card.imagePath != null) {
        return _buildImageWidget(card.imagePath!);
      }

      // Link without image - placeholder with link icon
      return _buildPlaceholderWithIcon(Icons.link);
    }

    // For text cards - show text snippet on gradient background
    if (card.type == 'text') {
      return Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              AppTheme.primaryColor.withOpacity(0.7),
              AppTheme.primaryColor,
            ],
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body?.substring(
                    0,
                    card.body!.length > 50 ? 50 : card.body!.length,
                  ) ??
                  card.content,
              maxLines: 4,
              textAlign: TextAlign.center,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 15,
                fontWeight: FontWeight.w400,
              ),
            ),
          ),
        ),
      );
    }

    // Default placeholder
    return _buildPlaceholderWithIcon(Icons.note);
  }

  Widget _buildImageWidget(String path) {
    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.cover,
        placeholder: (context, url) => _buildShimmerEffect(),
        errorWidget: (context, url, error) =>
            _buildPlaceholderWithIcon(Icons.broken_image),
        fadeInDuration: const Duration(milliseconds: 300),
      );
    }

    // Local file
    try {
      return Image.file(
        File(path),
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return _buildPlaceholderWithIcon(Icons.broken_image);
        },
      );
    } catch (e) {
      return _buildPlaceholderWithIcon(Icons.broken_image);
    }
  }

  Widget _buildShimmerEffect() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[800]!,
      highlightColor: Colors.grey[700]!,
      child: Container(color: Colors.grey[800]),
    );
  }

  Widget _buildPlaceholderWithIcon(IconData icon) {
    return Container(
      color: AppTheme.surfaceVariantColor,
      child: Center(child: Icon(icon, size: 42, color: Colors.grey[400])),
    );
  }

  String _getFormattedDate() {
    final date = DateTime.fromMillisecondsSinceEpoch(card.createdAt);
    final now = DateTime.now();

    // Today
    if (date.year == now.year &&
        date.month == now.month &&
        date.day == now.day) {
      return 'Today ${_formatTime(date)}';
    }

    // Yesterday
    final yesterday = now.subtract(const Duration(days: 1));
    if (date.year == yesterday.year &&
        date.month == yesterday.month &&
        date.day == yesterday.day) {
      return 'Yesterday ${_formatTime(date)}';
    }

    // Within a week
    if (now.difference(date).inDays < 7) {
      return '${_getDayName(date)} ${_formatTime(date)}';
    }

    // Older
    return '${date.day}/${date.month}/${date.year}';
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  String _getDayName(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Mon';
      case 2:
        return 'Tue';
      case 3:
        return 'Wed';
      case 4:
        return 'Thu';
      case 5:
        return 'Fri';
      case 6:
        return 'Sat';
      case 7:
        return 'Sun';
      default:
        return '';
    }
  }

  Widget _buildTypeIndicator() {
    Color backgroundColor;
    String label;

    switch (card.type) {
      case 'image':
        backgroundColor = Colors.blue.withOpacity(0.8);
        label = 'IMAGE';
        break;
      case 'video':
        backgroundColor = Colors.red.withOpacity(0.8);
        label = 'VIDEO';
        break;
      case 'link':
        backgroundColor = Colors.purple.withOpacity(0.8);
        label = 'LINK';
        break;
      case 'text':
        backgroundColor = AppTheme.primaryColor.withOpacity(0.8);
        label = 'TEXT';
        break;
      default:
        backgroundColor = Colors.grey.withOpacity(0.8);
        label = 'NOTE';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 3),
        ],
      ),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildTypeIcon() {
    IconData iconData;
    Color iconColor;

    switch (card.type) {
      case 'image':
        iconData = Icons.image_outlined;
        iconColor = Colors.blue;
        break;
      case 'video':
        iconData = Icons.videocam_outlined;
        iconColor = Colors.red;
        break;
      case 'link':
        iconData = Icons.link;
        iconColor = Colors.purple;
        break;
      case 'text':
        iconData = Icons.text_snippet_outlined;
        iconColor = AppTheme.primaryColor;
        break;
      default:
        iconData = Icons.note_outlined;
        iconColor = Colors.grey;
    }

    return Icon(iconData, size: 12, color: iconColor);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\focusable_card_tile.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\main_grid_view.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shimmer/shimmer.dart';

import '../../../bloc/main_grid/main_grid_bloc.dart';
import '../../../bloc/main_grid/main_grid_event.dart';
import '../../../bloc/main_grid/main_grid_state.dart';
import '../../../data/card_entity.dart';
import '../../../ui/theme/app_theme.dart';
// Use the new implementation to fix setState during build issues
import 'card_tile_new.dart';

class MainGridView extends StatefulWidget {
  const MainGridView({super.key});

  @override
  State<MainGridView> createState() => _MainGridViewState();
}

class _MainGridViewState extends State<MainGridView> {
  final _scrollController = ScrollController();
  bool _isBottomLoading = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_isNearBottom && !_isBottomLoading) {
      setState(() => _isBottomLoading = true);
      context.read<MainGridBloc>().add(const LoadMoreCards());
      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) setState(() => _isBottomLoading = false);
      });
    }
  }

  bool get _isNearBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.offset;
    // Load more when reached 80% of the scroll
    return currentScroll >= (maxScroll * 0.8);
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<MainGridBloc, MainGridState>(
      builder: (context, state) {
        if (state is MainGridInitial) {
          // Trigger loading when first built
          context.read<MainGridBloc>().add(const LoadCards());
          return _buildLoadingView();
        } else if (state is MainGridLoading && state.isFirstLoad) {
          return _buildLoadingView();
        } else if (state is MainGridError) {
          return _buildErrorView(state.message);
        } else if (state is MainGridLoaded) {
          return _buildGridView(state);
        }

        // Fallback for any other state
        return _buildLoadingView();
      },
    );
  }

  Widget _buildLoadingView() {
    // Calculate columns based on screen width (3 columns for tablets, 4 for large screens)
    final width = MediaQuery.of(context).size.width;
    final crossAxisCount = width > 1200
        ? 4
        : width > 600
        ? 3
        : 2;

    return Container(
      color: AppTheme.surfaceColor,
      child: CustomScrollView(
        slivers: [
          // Shimmer header
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 4),
              child: Shimmer.fromColors(
                baseColor: AppTheme.cardColor,
                highlightColor: AppTheme.cardColor.withOpacity(0.5),
                child: Container(
                  height: 48,
                  decoration: BoxDecoration(
                    color: Colors.white24,
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
          ),

          // Shimmer grid of loading cards
          SliverPadding(
            padding: const EdgeInsets.all(12.0),
            sliver: SliverGrid(
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                childAspectRatio: 0.7,
                mainAxisSpacing: 12.0,
                crossAxisSpacing: 12.0,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  return Shimmer.fromColors(
                    baseColor: AppTheme.cardColor,
                    highlightColor: AppTheme.cardColor.withOpacity(0.5),
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.white24,
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                  );
                },
                childCount:
                    crossAxisCount * 4, // Show 4 rows of shimmering cards
              ),
            ),
          ),

          // Add loading indicator at bottom
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Center(
                child: Column(
                  children: [
                    const SizedBox(
                      width: 32,
                      height: 32,
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(
                          AppTheme.primaryColor,
                        ),
                        strokeWidth: 2.5,
                      ),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Loading your cards...',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ),

          // Bottom padding for navigation
          const SliverToBoxAdapter(child: SizedBox(height: 80)),
        ],
      ),
    );
  }

  Widget _buildErrorView(String message) {
    return Container(
      color: AppTheme.surfaceColor,
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Animated error icon with a subtle bounce effect
              TweenAnimationBuilder<double>(
                tween: Tween<double>(begin: 0.0, end: 1.0),
                duration: const Duration(milliseconds: 500),
                curve: Curves.elasticOut,
                builder: (context, value, child) {
                  return Transform.scale(
                    scale: value,
                    child: Container(
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: AppTheme.errorColor.withOpacity(0.2),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.error_outline_rounded,
                        color: AppTheme.errorColor,
                        size: 48,
                      ),
                    ),
                  );
                },
              ),
              const SizedBox(height: 24),
              Text(
                'Error',
                style: Theme.of(
                  context,
                ).textTheme.titleLarge?.copyWith(color: AppTheme.errorColor),
              ),
              const SizedBox(height: 8),
              Text(
                message,
                style: Theme.of(
                  context,
                ).textTheme.bodyMedium?.copyWith(color: Colors.white70),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              ElevatedButton.icon(
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppTheme.primaryColor,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                  elevation: 4,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                ),
                onPressed: () {
                  // Add a small haptic feedback if available
                  HapticFeedback.mediumImpact();
                  context.read<MainGridBloc>().add(const LoadCards());
                },
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGridView(MainGridLoaded state) {
    final cards = state.cards;
    // Calculate columns based on screen width (3 columns for tablets, 4 for large screens)
    final width = MediaQuery.of(context).size.width;
    final crossAxisCount = width > 1200
        ? 4
        : width > 600
        ? 3
        : 2;

    if (cards.isEmpty) {
      return _buildEmptyView(state.isSearchResult);
    }

    return Container(
      color: AppTheme.surfaceColor,
      child: RefreshIndicator(
        color: AppTheme.primaryColor,
        backgroundColor: AppTheme.surfaceVariantColor,
        onRefresh: () async {
          context.read<MainGridBloc>().add(const LoadCards(refresh: true));
          // Wait for refresh to complete
          await Future.delayed(const Duration(milliseconds: 800));
        },
        child: CustomScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          controller: _scrollController,
          slivers: [
            // Search indicator if showing search results
            if (state.isSearchResult && state.searchQuery != null)
              SliverToBoxAdapter(
                child: Container(
                  color: AppTheme.surfaceVariantColor,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16.0,
                    vertical: 12.0,
                  ),
                  margin: const EdgeInsets.only(bottom: 8),
                  child: Row(
                    children: [
                      Icon(
                        Icons.search,
                        color: AppTheme.primaryColor,
                        size: 18,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          'Results for "${state.searchQuery}"',
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(
                          Icons.close,
                          color: Colors.white70,
                          size: 18,
                        ),
                        onPressed: () => context.read<MainGridBloc>().add(
                          const ClearSearch(),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

            // Grid of cards with improved spacing
            SliverPadding(
              padding: const EdgeInsets.all(12.0),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: crossAxisCount,
                  childAspectRatio: 0.7, // Card aspect ratio (more vertical)
                  mainAxisSpacing: 12.0,
                  crossAxisSpacing: 12.0,
                ),
                delegate: SliverChildBuilderDelegate(
                  (context, index) => _buildCardItem(cards[index]),
                  childCount: cards.length,
                ),
              ),
            ),

            // Shimmer loading indicator for pagination
            if (!state.hasReachedMax && cards.isNotEmpty)
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 20.0),
                  child: Center(
                    child: Shimmer.fromColors(
                      baseColor: Colors.grey[800]!,
                      highlightColor: Colors.grey[700]!,
                      child: Column(
                        children: [
                          Container(
                            width: 160,
                            height: 12,
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          const SizedBox(height: 8),
                          Container(
                            width: 120,
                            height: 12,
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),

            // Bottom padding to ensure cards are above bottom navigation bar
            const SliverToBoxAdapter(child: SizedBox(height: 80)),
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyView(bool isSearchResult) {
    return Container(
      color: Theme.of(context).scaffoldBackgroundColor,
      child: Center(
        child: AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          switchInCurve: Curves.easeInOut,
          switchOutCurve: Curves.easeInOut,
          child: Column(
            key: ValueKey<bool>(isSearchResult),
            mainAxisSize: MainAxisSize.min,
            children: [
              AnimatedScale(
                scale: 1.0,
                duration: const Duration(milliseconds: 300),
                curve: Curves.elasticOut,
                child: isSearchResult
                    ? Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.search_off,
                          color: AppTheme.primaryColor,
                          size: 64,
                        ),
                      )
                    : Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.photo_library,
                          color: AppTheme.primaryColor,
                          size: 64,
                        ),
                      ),
              ),

              const SizedBox(height: 24),

              Text(
                isSearchResult ? 'No results found' : 'No media cards yet.',
                style: Theme.of(context).textTheme.titleLarge,
              ),

              const SizedBox(height: 12),

              Text(
                isSearchResult
                    ? 'Try a different search term'
                    : 'Tap + to create one.',
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodyMedium,
              ),

              if (isSearchResult) ...[
                const SizedBox(height: 32),
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.primaryColor,
                    foregroundColor: AppTheme.onPrimaryColor,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 24,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                  onPressed: () =>
                      context.read<MainGridBloc>().add(const ClearSearch()),
                  icon: const Icon(Icons.clear),
                  label: const Text('Clear Search'),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCardItem(CardEntity card) {
    return CardTile(
      card: card,
      onTap: () {
        if (card.id != null) {
          Navigator.pushNamed(context, '/cardDetail', arguments: card.id).then((
            result,
          ) {
            if (result == true) {
              // Refresh the grid if card was deleted
              context.read<MainGridBloc>().add(const LoadCards(refresh: true));
            }
          });
        }
      },
      onDelete: () {
        _showDeleteConfirmation(card);
      },
    );
  }

  void _showDeleteConfirmation(CardEntity card) {
    // Get the bloc reference before the dialog
    final mainGridBloc = BlocProvider.of<MainGridBloc>(context);

    showDialog(
      context: context,
      builder: (dialogContext) {
        return BlocProvider.value(
          value: mainGridBloc,
          child: Builder(
            builder: (builderContext) {
              // Ensure we have a proper Material widget ancestor
              return Material(
                type: MaterialType.transparency,
                child: AlertDialog(
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  backgroundColor: AppTheme.surfaceVariantColor,
                  title: const Text(
                    'Delete Card',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  content: Text(
                    'Are you sure you want to delete "${card.content}"?',
                    style: const TextStyle(color: Colors.white70),
                    textAlign: TextAlign.center,
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(dialogContext).pop(),
                      style: TextButton.styleFrom(foregroundColor: Colors.grey),
                      child: const Text('CANCEL'),
                    ),
                    ElevatedButton(
                      onPressed: () {
                        if (card.id != null) {
                          // Use the builderContext which has access to the provided bloc
                          builderContext.read<MainGridBloc>().add(
                            CardDeleted(card.id!),
                          );
                        }
                        Navigator.of(dialogContext).pop();
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.redAccent,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('DELETE'),
                    ),
                  ],
                ),
              );
            },
          ),
        );
      },
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\modals ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_image_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_link_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_text_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\overlay ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\overlay\card_preview_overlay.dart
=========================================
--- Content Start ---
import 'dart:ui';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:intl/intl.dart';
import '../../../data/card_entity.dart';
import '../../../data/repository/card_repository.dart';
import '../../../ui/theme/app_theme.dart';

/// Shows a fullscreen preview overlay when a card is long-pressed
class CardPreviewOverlay extends StatelessWidget {
  final CardEntity card;
  final VoidCallback onEdit;
  final CardRepository cardRepository;

  const CardPreviewOverlay({
    super.key,
    required this.card,
    required this.onEdit,
    required this.cardRepository,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      type: MaterialType.transparency,
      child: GestureDetector(
        onTap: () => Navigator.of(context).pop(),
        child: Stack(
          children: [
            // Blurred background
            BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
              child: Container(
                color: Colors.black.withOpacity(0.4),
                width: double.infinity,
                height: double.infinity,
              ),
            ),

            // Main content with dismiss behavior
            Center(
              child: GestureDetector(
                onTap: () {},
                child: DismissibleCardPreview(
                  card: card,
                  onDismissed: () => Navigator.of(context).pop(),
                  onEdit: onEdit,
                  cardRepository: cardRepository,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class DismissibleCardPreview extends StatelessWidget {
  final CardEntity card;
  final VoidCallback? onDismissed;
  final VoidCallback onEdit;
  final CardRepository cardRepository;

  const DismissibleCardPreview({
    super.key,
    required this.card,
    this.onDismissed,
    required this.onEdit,
    required this.cardRepository,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      // Avoid triggering tap on the parent overlay
      onTap: () {},
      child: Dismissible(
        key: Key('preview-${card.id}'),
        direction: DismissDirection.down,
        onDismissed: (_) {
          if (onDismissed != null) {
            onDismissed!();
          }
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Card Preview Content
            Hero(
              tag: 'card-${card.id}',
              child: Container(
                constraints: BoxConstraints(
                  maxWidth: MediaQuery.of(context).size.width * 0.85,
                  maxHeight: MediaQuery.of(context).size.height * 0.7,
                ),
                decoration: BoxDecoration(
                  color: AppTheme.surfaceVariantColor,
                  borderRadius: BorderRadius.circular(24),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 15,
                      offset: const Offset(0, 5),
                    ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(24),
                  child: _buildCardPreview(context),
                ),
              ),
            ),

            const SizedBox(height: 20),

            // Actions Row
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Edit button
                ElevatedButton.icon(
                  onPressed: () {
                    Navigator.of(context).pop();
                    onEdit();
                  },
                  icon: const Icon(Icons.edit),
                  label: const Text('Edit'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.primaryColor,
                    foregroundColor: AppTheme.onPrimaryColor,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 20,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                ),

                const SizedBox(width: 16),

                // Delete button
                OutlinedButton.icon(
                  onPressed: () => _showDeleteConfirmation(context),
                  icon: const Icon(Icons.delete),
                  label: const Text('Delete'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: Colors.red.shade600,
                    side: BorderSide(color: Colors.red.shade600),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 20,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                ),
              ],
            ),

            const SizedBox(height: 16),

            // Created date
            Text(
              'Created: ${DateFormat('MMM d, yyyy').format(DateTime.fromMillisecondsSinceEpoch(card.createdAt))}',
              style: TextStyle(color: Colors.grey.shade400, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }

  // Build the appropriate preview based on card type
  Widget _buildCardPreview(BuildContext context) {
    switch (card.type) {
      case 'text':
        return _buildTextCardPreview(context);
      case 'image':
        return _buildImageCardPreview(context);
      case 'link':
        return _buildLinkCardPreview(context);
      default:
        return _buildTextCardPreview(context);
    }
  }

  // Text card preview
  Widget _buildTextCardPreview(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      child: SingleChildScrollView(
        child: Text(
          card.content,
          style: const TextStyle(
            fontSize: 18,
            color: Colors.white,
            height: 1.5,
          ),
        ),
      ),
    );
  }

  // Image card preview
  Widget _buildImageCardPreview(BuildContext context) {
    final imagePath = card.imagePath;

    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.7,
      ),
      child: SingleChildScrollView(
        physics: const ClampingScrollPhysics(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Image
            if (imagePath != null && imagePath.isNotEmpty)
              _buildImageWidget(imagePath)
            else
              const SizedBox(
                height: 240,
                child: Center(
                  child: Icon(
                    Icons.image_not_supported,
                    size: 64,
                    color: Colors.grey,
                  ),
                ),
              ),

            // Caption if any
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                card.content,
                style: const TextStyle(color: Colors.white, fontSize: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Helper method to build image widget based on path
  Widget _buildImageWidget(String path) {
    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.contain,
        width: double.infinity,
        placeholder: (context, url) =>
            const Center(child: CircularProgressIndicator()),
        errorWidget: (context, url, error) => const Center(
          child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
        ),
      );
    }

    // Local file
    try {
      return Image.file(
        File(path),
        fit: BoxFit.contain,
        width: double.infinity,
        errorBuilder: (context, error, stackTrace) {
          return const Center(
            child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
          );
        },
      );
    } catch (e) {
      return const Center(
        child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
      );
    }
  }

  // Link card preview
  Widget _buildLinkCardPreview(BuildContext context) {
    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.5,
      ),
      width: double.infinity,
      child: SingleChildScrollView(
        physics: const ClampingScrollPhysics(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Link icon or placeholder
            Container(
              height: 120,
              color: Colors.grey.shade800,
              child: const Center(
                child: Icon(Icons.link, size: 48, color: Colors.white54),
              ),
            ),

            // Content and URL
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Content as title
                  Text(
                    card.content,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),

                  const SizedBox(height: 8),

                  // URL - clickable
                  if (card.url != null && card.url!.isNotEmpty)
                    GestureDetector(
                      onTap: () {
                        // You can add URL launching functionality here
                        // using url_launcher package
                      },
                      child: Text(
                        card.url!,
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.blue.shade300,
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Show delete confirmation dialog
  void _showDeleteConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (dialogContext) => Material(
        type: MaterialType.transparency,
        child: AlertDialog(
          backgroundColor: AppTheme.surfaceVariantColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          title: const Text(
            'Delete Card',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          content: Text(
            'Are you sure you want to delete "${card.content.length > 30 ? card.content.substring(0, 30) + '...' : card.content}"?',
            style: const TextStyle(color: Colors.white70),
            textAlign: TextAlign.center,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              style: TextButton.styleFrom(foregroundColor: Colors.grey),
              child: const Text('CANCEL'),
            ),
            ElevatedButton(
              onPressed: () {
                Navigator.of(dialogContext).pop();
                _deleteCard(context);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.redAccent,
                foregroundColor: Colors.white,
              ),
              child: const Text('DELETE'),
            ),
          ],
        ),
      ),
    );
  }

  // Delete the card
  void _deleteCard(BuildContext context) async {
    if (card.id == null) return;

    try {
      await cardRepository.deleteCard(card.id!);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Card deleted successfully'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.of(context).pop(); // Close the preview overlay
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error deleting card: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

// Helper function to show the card preview overlay
void showCardPreviewOverlay({
  required BuildContext context,
  required CardEntity card,
  required VoidCallback onEdit,
  required CardRepository cardRepository,
}) {
  showGeneralDialog(
    context: context,
    barrierDismissible: true,
    barrierColor: Colors.black54,
    barrierLabel: 'Dismiss',
    transitionDuration: const Duration(milliseconds: 200),
    pageBuilder: (context, animation1, animation2) {
      return CardPreviewOverlay(
        card: card,
        onEdit: onEdit,
        cardRepository: cardRepository,
      );
    },
    transitionBuilder: (context, animation, secondaryAnimation, child) {
      return FadeTransition(
        opacity: animation,
        child: ScaleTransition(
          scale: CurvedAnimation(
            parent: animation,
            curve: Curves.easeOut,
          ).drive(Tween<double>(begin: 0.95, end: 1.0)),
          child: child,
        ),
      );
    },
  );
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\utils ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\utils\image_storage.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart';
import 'package:image/image.dart' as img;

class ImageStorage {
  ImageStorage();

  Future<Directory> _imagesDir() async {
    final dir = await getApplicationDocumentsDirectory();
    final images = Directory('${dir.path}/images');
    if (!await images.exists()) {
      await images.create(recursive: true);
    }
    return images;
  }

  Future<(File original, File thumbnail)> saveImageWithThumbnail(
    File input,
  ) async {
    final images = await _imagesDir();
    final id = const Uuid().v4();

    final bytes = await input.readAsBytes();
    final decoded = img.decodeImage(bytes);
    if (decoded == null) {
      throw Exception('Unsupported image format');
    }

    // Save original as JPEG
    final originalPath = '${images.path}/$id.jpg';
    final originalBytes = img.encodeJpg(decoded, quality: 90);
    final originalFile = await File(
      originalPath,
    ).writeAsBytes(originalBytes, flush: true);

    // Thumbnail max width 400
    final resized = decoded.width > 400
        ? img.copyResize(decoded, width: 400)
        : decoded;
    final thumbPath = '${images.path}/${id}_thumb.jpg';
    final thumbBytes = img.encodeJpg(resized, quality: 80);
    final thumbFile = await File(
      thumbPath,
    ).writeAsBytes(thumbBytes, flush: true);

    return (originalFile, thumbFile);
  }

  Future<void> deleteImagePair(String originalPath) async {
    try {
      final file = File(originalPath);
      if (await file.exists()) {
        await file.delete();
      }
      final thumbPath = originalPath.replaceFirst(
        RegExp(r'(\.jpg|\.jpeg|\.png)\$'),
        '_thumb.jpg',
      );
      final thumb = File(thumbPath);
      if (await thumb.exists()) {
        await thumb.delete();
      }
    } catch (_) {
      // ignore
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\utils\shared_content_manager.dart
=========================================
--- Content Start ---


--- Content End ---

