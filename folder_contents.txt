--- Starting Scan of Folder: D:\SDPProject\retainly\lib ---

--- Directory: D:\SDPProject\retainly\lib ---

=========================================
File Path: D:\SDPProject\retainly\lib\main.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:share_handler/share_handler.dart';
import 'dart:io';
import 'src/app.dart';
import 'src/ui/widgets/card/add_text_card_modal.dart';
import 'src/ui/widgets/card/add_image_card_modal.dart';
import 'src/ui/widgets/card/add_link_card_modal.dart';

final GlobalKey<NavigatorState> globalNavigatorKey =
    GlobalKey<NavigatorState>();

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Start app first so navigator is available, then hook share handling
  // Wrap with RepaintBoundary to isolate rebuild issues
  runApp(RepaintBoundary(child: RetainlyApp(navigatorKey: globalNavigatorKey)));

  // Defer init to next frame to ensure navigator is attached
  WidgetsBinding.instance.addPostFrameCallback((_) async {
    final handler = ShareHandlerPlatform.instance;

    // Initial share (cold start)
    final initial = await handler.getInitialSharedMedia();
    if (initial != null) {
      _handleSharedMedia(initial);
    }

    // Stream (warm start)
    handler.sharedMediaStream.listen((SharedMedia media) {
      _handleSharedMedia(media);
    });
  });
}

void _handleSharedMedia(SharedMedia media) async {
  final nav = globalNavigatorKey.currentState;
  if (nav == null) {
    print('Share handler: Navigator not available');
    return;
  }

  print('Share handler: Received shared media');

  // Ensure we're on a stable context before showing any UI
  await Future.delayed(const Duration(milliseconds: 500));

  // Handle text content (plain text or URL)
  if (media.content != null && media.content!.isNotEmpty) {
    final text = media.content!.trim();
    print(
      'Share handler: Received text content: \"${text.length > 50 ? text.substring(0, 50) + '...' : text}\"',
    );

    final lower = text.toLowerCase();
    final isLikelyUrl =
        lower.startsWith('http://') ||
        lower.startsWith('https://') ||
        (Uri.tryParse(text)?.hasScheme ?? false);

    if (isLikelyUrl) {
      // URL content - open Link Card Modal
      print('Share handler: Opening Link Card Modal with URL: $text');
      WidgetsBinding.instance.addPostFrameCallback((_) {
        nav
            .push(
              MaterialPageRoute(
                fullscreenDialog: true,
                builder: (_) =>
                    AddLinkCardModal(initialUrl: text, autofocusSave: true),
              ),
            )
            .then((value) {
              print('Share handler: Link modal closed with result: $value');
            });
      });
    } else {
      // Plain text content - open Text Card Modal
      print('Share handler: Opening Text Card Modal');
      WidgetsBinding.instance.addPostFrameCallback((_) {
        nav
            .push(
              MaterialPageRoute(
                fullscreenDialog: true,
                builder: (_) =>
                    AddTextCardModal(initialText: text, autofocusSave: true),
              ),
            )
            .then((value) {
              print('Share handler: Text modal closed with result: $value');
            });
      });
    }
  }
  // Handle image attachments
  else if (media.attachments != null && media.attachments!.isNotEmpty) {
    print('Share handler: Received ${media.attachments!.length} attachment(s)');

    // Try to find an image attachment
    final firstImage = media.attachments!.firstWhere(
      (a) => a?.type == SharedAttachmentType.image && a?.path != null,
      orElse: () => null,
    );

    if (firstImage == null) {
      print('Share handler: No valid image attachment found');
      _showUnsupportedTypeMessage(
        nav.context,
        "No valid image found in shared content",
      );
      return;
    }

    final path = firstImage.path;
    print('Share handler: Image path from attachment: $path');

    try {
      final file = File(path);
      final exists = await file.exists();

      if (exists) {
        final fileSize = await file.length();
        print('Share handler: File exists at path, size: $fileSize bytes');

        // Image found - open Image Card Modal with slight delay to ensure UI stability
        WidgetsBinding.instance.addPostFrameCallback((_) {
          nav
              .push(
                MaterialPageRoute(
                  fullscreenDialog: true,
                  builder: (_) =>
                      AddImageCardModal(imagePath: path, autofocusSave: true),
                ),
              )
              .then((value) {
                // Log the result of the modal closing
                print('Share handler: Image modal closed with result: $value');
              });
        });
      } else {
        print('Share handler: File does not exist at path: $path');
        _showUnsupportedTypeMessage(
          nav.context,
          "Image file not found at specified location",
        );
      }
    } catch (e) {
      print('Share handler: Error accessing image file: $e');
      _showUnsupportedTypeMessage(
        nav.context,
        "Error accessing image: ${e.toString()}",
      );
    }
  }
  // No supported content found
  else {
    print('Share handler: No supported content found in shared media');
    _showUnsupportedTypeMessage(nav.context, "Unsupported share type");
  }
}

// Helper function to show error messages for unsupported share types
void _showUnsupportedTypeMessage(BuildContext context, String message) {
  ScaffoldMessenger.of(context).showSnackBar(
    SnackBar(
      content: Text(message),
      backgroundColor: Colors.redAccent,
      behavior: SnackBarBehavior.floating,
      duration: const Duration(seconds: 3),
    ),
  );
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\app.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import 'data/database.dart';
import 'data/repository/card_repository.dart';
import 'data/repository/space_repository.dart';
import 'ui/screens/splash_screen.dart';
import 'ui/screens/landing_screen.dart';
import 'ui/screens/home_screen.dart';
import 'ui/screens/card_detail_screen.dart';
import 'ui/theme/app_theme.dart';

class RetainlyApp extends StatelessWidget {
  final GlobalKey<NavigatorState>? navigatorKey;
  const RetainlyApp({super.key, this.navigatorKey});

  @override
  Widget build(BuildContext context) {
    return MultiRepositoryProvider(
      providers: [
        RepositoryProvider<CardRepository>(
          create: (context) => CardRepository(),
        ),
        RepositoryProvider<SpaceRepository>(
          create: (context) => SpaceRepository(),
        ),
      ],
      child: MaterialApp(
        navigatorKey: navigatorKey,
        title: 'Retainly',
        theme: AppTheme.darkTheme,
        darkTheme: AppTheme.darkTheme,
        themeMode: ThemeMode.dark,
        debugShowCheckedModeBanner: false,
        initialRoute: '/',
        routes: {
          '/': (context) => const SplashScreen(),
          '/landing': (context) => const LandingScreen(),
          '/home': (context) => const HomeScreen(),
        },
        onGenerateRoute: (settings) {
          if (settings.name == '/cardDetail') {
            final cardId = settings.arguments as int;
            return AppTheme.slideAndFadeTransition<dynamic>(
              settings: settings,
              page: CardDetailScreen(cardId: cardId),
            );
          }
          return null;
        },
      ),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\bloc ---
--- Directory: D:\SDPProject\retainly\lib\src\bloc\add_card ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:io';
import 'dart:async';
import 'package:http/http.dart' as http;
import 'package:html/parser.dart' as parser;
import 'package:path/path.dart' as path;
import 'package:path_provider/path_provider.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';
import '../../services/youtube_service.dart';
import 'add_card_event.dart';
import 'add_card_state.dart';
import '../../utils/image_storage.dart';
import '../../utils/url_utils.dart';

class AddCardBloc extends Bloc<AddCardEvent, AddCardState> {
  final CardRepository cardRepository;

  AddCardBloc({required this.cardRepository}) : super(const AddCardIdle()) {
    on<AddTextCardRequested>(_onAddTextCardRequested);
    on<AddImageCardRequested>(_onAddImageCardRequested);
    on<AddLinkCardRequested>(_onAddLinkCardRequested);
    on<FetchTitleRequested>(_onFetchTitleRequested);
    on<AddNewCard>(_onAddNewCard);
  }

  Future<void> _onAddTextCardRequested(
    AddTextCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardLoading());

    try {
      final now = DateTime.now().millisecondsSinceEpoch;
      final card = CardEntity(
        type: 'text',
        content: event
            .content, // Using content as both title and body for simple notes
        body: event.content,
        spaceId: event.spaceId, // Add to space if specified
        createdAt: now,
        updatedAt: now,
      );

      final cardId = await cardRepository.addCard(card);
      emit(AddCardSuccess(cardId));
    } catch (e) {
      emit(AddCardError(e.toString()));
    }
  }

  Future<void> _onAddImageCardRequested(
    AddImageCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardLoading());

    try {
      print('AddCardBloc: Processing image from path: ${event.imagePath}');
      // Verify file exists and is readable
      final input = File(event.imagePath);
      if (!await input.exists()) {
        throw Exception(
          'Image file does not exist at path: ${event.imagePath}',
        );
      }

      final fileSize = await input.length();
      if (fileSize <= 0) {
        throw Exception('Image file is empty (0 bytes)');
      }

      print('AddCardBloc: File exists with size: $fileSize bytes');

      // Persist image and thumbnail
      final storage = ImageStorage();
      final (original, thumbnail) = await storage.saveImageWithThumbnail(input);

      final now = DateTime.now().millisecondsSinceEpoch;
      final card = CardEntity(
        type: 'image',
        content: event.caption?.trim().isNotEmpty == true
            ? event.caption!.trim()
            : 'Image',
        body: null,
        imagePath: original.path, // store original path
        spaceId: event.spaceId, // Add to space if specified
        createdAt: now,
        updatedAt: now,
      );
      print(
        'AddCardBloc: Created card entity with image path: ${original.path}',
      );

      final cardId = await cardRepository.addCard(card);
      print('AddCardBloc: Successfully saved card with ID: $cardId');

      emit(AddCardSuccess(cardId));
    } catch (e) {
      print('AddCardBloc: Error adding image card: $e');
      emit(AddCardError(e.toString()));
    }
  }

  Future<void> _onAddLinkCardRequested(
    AddLinkCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardLoading());

    try {
      final url = event.url.trim();
      final youtubeService = YouTubeService(
  apiKey: 'REDACTED_API_KEY',
      );

      // Check if this is a YouTube URL
      if (youtubeService.isYoutubeUrl(url)) {
        print('AddCardBloc: Detected YouTube URL: $url');
        await _handleYoutubeCard(event, emit, youtubeService);
      } else {
        // Handle regular link
        await _handleRegularLinkCard(event, emit);
      }
    } catch (e) {
      print('AddCardBloc: Error in _onAddLinkCardRequested: $e');
      emit(AddCardError(e.toString()));
    }
  }

  /// Handle a regular link card (non-YouTube)
  Future<void> _handleRegularLinkCard(
    AddLinkCardRequested event,
    Emitter<AddCardState> emit,
  ) async {
    final url = event.url.trim();

    // Attempt to fetch webpage title if not provided
    String title = event.title.trim();
    if (title.isEmpty) {
      try {
        // Create a YouTubeService instance just for web page title fetching
        final youtubeService = YouTubeService(
          apiKey: 'REDACTED_API_KEY',
        );
        final fetchedTitle = await youtubeService.fetchWebPageTitle(url);
        if (fetchedTitle != null && fetchedTitle.isNotEmpty) {
          title = fetchedTitle;
          print('AddCardBloc: Fetched web page title: $title');
        } else {
          title = url; // Use URL as fallback title
        }
      } catch (e) {
        print('AddCardBloc: Error fetching web page title: $e');
        title = url; // Use URL as fallback title
      }
    }

    final now = DateTime.now().millisecondsSinceEpoch;
    final card = CardEntity(
      type: 'link',
      content: title, // Use fetched title or provided title
      url: url,
      spaceId: event.spaceId, // Add to space if specified
      createdAt: now,
      updatedAt: now,
    );

    final cardId = await cardRepository.addCard(card);
    emit(AddCardSuccess(cardId));
  }

  /// Handle a YouTube link card with thumbnail and transcript
  Future<void> _handleYoutubeCard(
    AddLinkCardRequested event,
    Emitter<AddCardState> emit,
    YouTubeService youtubeService,
  ) async {
    final url = event.url.trim();
    final videoId = youtubeService.extractVideoId(url);

    if (videoId == null) {
      print('AddCardBloc: Could not extract video ID from YouTube URL: $url');
      // Fall back to regular link handling
      await _handleRegularLinkCard(event, emit);
      return;
    }

    print('AddCardBloc: Extracted YouTube video ID: $videoId');

    // Attempt to fetch video title if not provided
    String title = event.title.trim();
    if (title.isEmpty) {
      try {
        final fetchedTitle = await youtubeService.fetchYouTubeTitle(videoId);
        if (fetchedTitle != null && fetchedTitle.isNotEmpty) {
          title = fetchedTitle;
          print('AddCardBloc: Fetched YouTube title: $title');
        } else {
          title = 'YouTube Video';
        }
      } catch (e) {
        print('AddCardBloc: Error fetching YouTube title: $e');
        title = 'YouTube Video';
      }
    }

    // Attempt to fetch thumbnail
    String? thumbnailPath;
    try {
      thumbnailPath = await youtubeService.fetchThumbnail(videoId);
      print('AddCardBloc: Fetched YouTube thumbnail: $thumbnailPath');
    } catch (e) {
      print('AddCardBloc: Error fetching YouTube thumbnail: $e');
      // Continue without thumbnail
    }

    // Attempt to fetch transcript
    String? transcript;
    try {
      transcript = await youtubeService.fetchTranscript(videoId);
      if (transcript != null) {
        print(
          'AddCardBloc: Fetched YouTube transcript (${transcript.length} chars)',
        );
      } else {
        print('AddCardBloc: No transcript available for video ID: $videoId');
      }
    } catch (e) {
      print('AddCardBloc: Error fetching YouTube transcript: $e');
      // Continue without transcript
    }

    // Create and save card with YouTube data
    final now = DateTime.now().millisecondsSinceEpoch;
    final card = CardEntity(
      type: 'link',
      content: title, // Use fetched title or provided title
      url: event.url.trim(),
      imagePath: thumbnailPath, // Add thumbnail path if available
      transcript: transcript, // Add transcript if available
      spaceId: event.spaceId, // Add to space if specified
      createdAt: now,
      updatedAt: now,
    );

    final cardId = await cardRepository.addCard(card);
    print('AddCardBloc: Saved YouTube card with ID: $cardId');
    emit(AddCardSuccess(cardId));
  }

  Future<void> _onFetchTitleRequested(
    FetchTitleRequested event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const TitleFetching());

    try {
      // Use the URL utils class for URL normalization
      String raw = event.url.trim();
      if (raw.isEmpty) {
        emit(const AddCardError('Empty URL'));
        return;
      }

      // Enhanced URL normalization with UrlUtils
      String normalizedUrl = UrlUtils.normalizeUrl(raw);
      print('Normalized URL for fetching: $normalizedUrl');

      final uri = Uri.tryParse(normalizedUrl);
      if (uri == null) {
        emit(const AddCardError('Invalid URL'));
        return;
      }

      // Create a fallback title immediately (we'll use this if fetching fails)
      String fallbackTitle = uri.host;

      // If host includes www, remove it
      fallbackTitle = fallbackTitle.replaceAll(RegExp(r'^www\.'), '');

      final client = http.Client();
      http.Response? response;
      try {
        print('Attempting HTTP request to $uri');
        response = await client
            .get(
              uri,
              headers: const {
                'User-Agent':
                    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
                'Accept':
                    'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.9',
                'Cache-Control': 'no-cache',
              },
            )
            .timeout(const Duration(seconds: 5));

        print('Got response with status code: ${response.statusCode}');
      } on TimeoutException {
        client.close();
        print('Timeout fetching title from URL: $raw');
        emit(TitleFetched(fallbackTitle));
        return;
      } on SocketException catch (e) {
        client.close();
        print('Network error fetching title: ${e.message}');
        emit(TitleFetched(fallbackTitle));
        return;
      } catch (e) {
        client.close();
        print('Request failed fetching title: $e');
        emit(TitleFetched(fallbackTitle));
        return;
      }
      client.close();

      if (response.statusCode == 200) {
        try {
          var document = parser.parse(response.body);
          var titleElements = document.getElementsByTagName('title');

          if (titleElements.isNotEmpty) {
            String title = titleElements.first.text.trim();
            if (title.isNotEmpty) {
              print('Found title tag: $title');
              emit(TitleFetched(title));
              return;
            }
          }

          // Try to find meta tag with og:title
          var metaTags = document.getElementsByTagName('meta');
          var ogTitle = metaTags.firstWhere(
            (element) => element.attributes['property'] == 'og:title',
            orElse: () => metaTags.firstWhere(
              (element) => element.attributes['name'] == 'title',
              orElse: () => document.createElement('meta'),
            ),
          );

          if (ogTitle.attributes.containsKey('content') &&
              ogTitle.attributes['content']!.isNotEmpty) {
            print('Found og:title: ${ogTitle.attributes['content']}');
            emit(TitleFetched(ogTitle.attributes['content']!));
            return;
          }
        } catch (e) {
          print('Error parsing HTML: $e');
        }
      }

      // If we got here, we need to use the fallback
      print('Using fallback title: $fallbackTitle');
      emit(TitleFetched(fallbackTitle));
    } catch (e) {
      print('Unexpected error in _onFetchTitleRequested: $e');
      // Don't fail completely, use domain name
      final domain = event.url
          .replaceAll(RegExp(r'^https?://'), '')
          .replaceAll(RegExp(r'^www\.'), '')
          .split('/')
          .first;
      emit(TitleFetched(domain));
    }
  }

  Future<void> _onAddNewCard(
    AddNewCard event,
    Emitter<AddCardState> emit,
  ) async {
    emit(const AddCardLoading());

    try {
      final cardId = await cardRepository.addCard(event.card);
      emit(AddCardSuccess(cardId));
    } catch (e) {
      emit(AddCardError(e.toString()));
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_event.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';
import '../../data/card_entity.dart';

abstract class AddCardEvent extends Equatable {
  const AddCardEvent();

  @override
  List<Object?> get props => [];
}

class AddTextCardRequested extends AddCardEvent {
  final String content;
  final List<String> tags;
  final int? spaceId;

  const AddTextCardRequested({
    required this.content,
    this.tags = const [],
    this.spaceId,
  });

  @override
  List<Object?> get props => [content, tags, spaceId];
}

class AddImageCardRequested extends AddCardEvent {
  final String imagePath; // temp file path
  final String? caption;
  final int? spaceId;

  const AddImageCardRequested({
    required this.imagePath,
    this.caption,
    this.spaceId,
  });

  @override
  List<Object?> get props => [imagePath, caption ?? '', spaceId];
}

class AddLinkCardRequested extends AddCardEvent {
  final String url;
  final String title;
  final int? spaceId;

  const AddLinkCardRequested({
    required this.url,
    required this.title,
    this.spaceId,
  });

  @override
  List<Object?> get props => [url, title, spaceId];
}

class FetchTitleRequested extends AddCardEvent {
  final String url;

  const FetchTitleRequested({required this.url});

  @override
  List<Object> get props => [url];
}

// New event to directly add a CardEntity object
class AddNewCard extends AddCardEvent {
  final CardEntity card;

  const AddNewCard(this.card);

  @override
  List<Object?> get props => [card];
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\add_card\add_card_state.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';

abstract class AddCardState extends Equatable {
  const AddCardState();

  @override
  List<Object> get props => [];
}

class AddCardIdle extends AddCardState {
  const AddCardIdle();
}

// Renamed from AddCardSaving to make it more explicit in modal files
class AddCardLoading extends AddCardState {
  const AddCardLoading();
}

class AddCardSuccess extends AddCardState {
  final int cardId;

  const AddCardSuccess(this.cardId);

  @override
  List<Object> get props => [cardId];
}

// Renamed from AddCardFailure to make it more explicit in modal files
class AddCardError extends AddCardState {
  final String message;

  const AddCardError(this.message);

  @override
  List<Object> get props => [message];
}

class TitleFetching extends AddCardState {
  const TitleFetching();
}

class TitleFetched extends AddCardState {
  final String title;

  const TitleFetched(this.title);

  @override
  List<Object> get props => [title];
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\bloc\main_grid ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:async';
import '../../data/repository/card_repository.dart';
import 'main_grid_event.dart';
import 'main_grid_state.dart';

class MainGridBloc extends Bloc<MainGridEvent, MainGridState> {
  final CardRepository _cardRepository;
  static const int _pageSize = 20;
  MainGridBloc({required CardRepository cardRepository})
    : _cardRepository = cardRepository,
      super(const MainGridInitial()) {
    on<LoadCards>(_onLoadCards);
    on<LoadMoreCards>(_onLoadMoreCards);
    on<CardAdded>(_onCardAdded);
    on<CardDeleted>(_onCardDeleted);
    on<SearchCards>(_onSearchCards);
    on<SearchQueryChanged>(_onSearchQueryChanged);
    on<ClearSearch>(_onClearSearch);
  }

  @override
  Future<void> close() {
    return super.close();
  }

  Future<void> _onLoadCards(
    LoadCards event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: true));
      final cards = await _cardRepository.getAllCards(limit: _pageSize);
      final hasReachedMax = cards.length < _pageSize;

      emit(MainGridLoaded(cards: cards, hasReachedMax: hasReachedMax));
    } catch (e) {
      emit(MainGridError('Failed to load cards: ${e.toString()}'));
    }
  }

  Future<void> _onLoadMoreCards(
    LoadMoreCards event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    // Don't load more if already reached max or is showing search results
    if (currentState.hasReachedMax || currentState.isSearchResult) return;

    try {
      // Show loading state but keep current cards
      // Could add a "loadingMore" flag to state if needed for UI

      final moreCards = await _cardRepository.getAllCards(
        offset: currentState.cards.length,
        limit: _pageSize,
      );

      final hasReachedMax = moreCards.length < _pageSize;

      emit(
        currentState.copyWith(
          cards: [...currentState.cards, ...moreCards],
          hasReachedMax: hasReachedMax,
        ),
      );
    } catch (e) {
      // Keep current cards but show error
      emit(MainGridError('Failed to load more cards: ${e.toString()}'));
    }
  }

  Future<void> _onCardAdded(
    CardAdded event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    // If showing search results, don't update unless card matches search
    if (currentState.isSearchResult && currentState.searchQuery != null) {
      final query = currentState.searchQuery!.toLowerCase();
      final content = event.card.content.toLowerCase();
      final body = event.card.body?.toLowerCase() ?? '';

      if (content.contains(query) || body.contains(query)) {
        emit(currentState.copyWith(cards: [event.card, ...currentState.cards]));
      }
    } else {
      // For normal view, add card to the top
      emit(currentState.copyWith(cards: [event.card, ...currentState.cards]));
    }
  }

  Future<void> _onCardDeleted(
    CardDeleted event,
    Emitter<MainGridState> emit,
  ) async {
    if (state is! MainGridLoaded) return;
    final currentState = state as MainGridLoaded;

    try {
      await _cardRepository.deleteCard(event.cardId);

      final updatedCards = currentState.cards
          .where((card) => card.id != event.cardId)
          .toList();

      emit(currentState.copyWith(cards: updatedCards));
    } catch (e) {
      emit(MainGridError('Failed to delete card: ${e.toString()}'));
    }
  }

  Future<void> _onSearchCards(
    SearchCards event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: false));

      final searchResults = await _cardRepository.searchCards(event.query);

      emit(
        MainGridLoaded(
          cards: searchResults,
          hasReachedMax: true, // No pagination for search results
          searchQuery: event.query,
          isSearchResult: true,
        ),
      );
    } catch (e) {
      emit(MainGridError('Search failed: ${e.toString()}'));
    }
  }

  Future<void> _onClearSearch(
    ClearSearch event,
    Emitter<MainGridState> emit,
  ) async {
    try {
      emit(MainGridLoading(isFirstLoad: false));

      final cards = await _cardRepository.getAllCards(limit: _pageSize);
      final hasReachedMax = cards.length < _pageSize;

      emit(
        MainGridLoaded(
          cards: cards,
          hasReachedMax: hasReachedMax,
          searchQuery: null,
          isSearchResult: false,
        ),
      );
    } catch (e) {
      emit(MainGridError('Failed to load cards: ${e.toString()}'));
    }
  }

  Future<void> _onSearchQueryChanged(
    SearchQueryChanged event,
    Emitter<MainGridState> emit,
  ) async {
    final query = event.query.trim();

    // If query is empty, clear search
    if (query.isEmpty) {
      add(const ClearSearch());
      return;
    }

    // Only perform search if query is at least 2 characters
    if (query.length >= 2) {
      try {
        // Show loading state but maintain previous cards if available
        if (state is MainGridLoaded) {
          emit(
            (state as MainGridLoaded).copyWith(
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        } else {
          emit(MainGridLoading(isFirstLoad: false));
        }

        final searchResults = await _cardRepository.searchCards(query);

        if (state is MainGridLoaded) {
          emit(
            (state as MainGridLoaded).copyWith(
              cards: searchResults,
              hasReachedMax: true, // No pagination for search results
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        } else {
          emit(
            MainGridLoaded(
              cards: searchResults,
              hasReachedMax: true,
              searchQuery: query,
              isSearchResult: true,
            ),
          );
        }
      } catch (e) {
        // Don't emit error state for live search - just keep current state
        if (state is! MainGridLoaded) {
          // If we don't have any cards to show, we must show an error
          emit(MainGridError('Search failed: ${e.toString()}'));
        }
        print('Search query changed error: ${e.toString()}');
      }
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_event.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';
import '../../data/card_entity.dart';

abstract class MainGridEvent extends Equatable {
  const MainGridEvent();

  @override
  List<Object?> get props => [];
}

// Event to load initial cards
class LoadCards extends MainGridEvent {
  final bool refresh;

  const LoadCards({this.refresh = false});

  @override
  List<Object?> get props => [refresh];
}

// Event to load more cards (pagination)
class LoadMoreCards extends MainGridEvent {
  const LoadMoreCards();
}

// Event when card is added
class CardAdded extends MainGridEvent {
  final CardEntity card;

  const CardAdded(this.card);

  @override
  List<Object?> get props => [card];
}

// Event when card is deleted
class CardDeleted extends MainGridEvent {
  final int cardId;

  const CardDeleted(this.cardId);

  @override
  List<Object?> get props => [cardId];
}

// Event for searching cards
class SearchCards extends MainGridEvent {
  final String query;

  const SearchCards(this.query);

  @override
  List<Object?> get props => [query];
}

// Event when search query changes
class SearchQueryChanged extends MainGridEvent {
  final String query;

  const SearchQueryChanged(this.query);

  @override
  List<Object?> get props => [query];
}

// Event to clear search and show all cards
class ClearSearch extends MainGridEvent {
  const ClearSearch();
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\bloc\main_grid\main_grid_state.dart
=========================================
--- Content Start ---
import 'package:equatable/equatable.dart';
import '../../data/card_entity.dart';

abstract class MainGridState extends Equatable {
  const MainGridState();

  @override
  List<Object?> get props => [];
}

class MainGridInitial extends MainGridState {
  const MainGridInitial();
}

class MainGridLoading extends MainGridState {
  final bool isFirstLoad;

  const MainGridLoading({this.isFirstLoad = true});

  @override
  List<Object?> get props => [isFirstLoad];
}

class MainGridLoaded extends MainGridState {
  final List<CardEntity> cards;
  final bool hasReachedMax;
  final String? searchQuery;
  final bool isSearchResult;

  const MainGridLoaded({
    required this.cards,
    this.hasReachedMax = false,
    this.searchQuery,
    this.isSearchResult = false,
  });

  @override
  List<Object?> get props => [
    cards,
    hasReachedMax,
    searchQuery,
    isSearchResult,
  ];

  MainGridLoaded copyWith({
    List<CardEntity>? cards,
    bool? hasReachedMax,
    String? searchQuery,
    bool? isSearchResult,
  }) {
    return MainGridLoaded(
      cards: cards ?? this.cards,
      hasReachedMax: hasReachedMax ?? this.hasReachedMax,
      searchQuery: searchQuery ?? this.searchQuery,
      isSearchResult: isSearchResult ?? this.isSearchResult,
    );
  }
}

class MainGridError extends MainGridState {
  final String message;

  const MainGridError(this.message);

  @override
  List<Object?> get props => [message];
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\blocs ---
--- Directory: D:\SDPProject\retainly\lib\src\blocs\spaces ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\blocs\spaces\spaces_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

import '../../data/space_entity.dart';
import '../../data/repository/space_repository.dart';

// Events
abstract class SpacesEvent extends Equatable {
  const SpacesEvent();

  @override
  List<Object?> get props => [];
}

class LoadSpaces extends SpacesEvent {
  const LoadSpaces();
}

class AddSpace extends SpacesEvent {
  final String name;

  const AddSpace(this.name);

  @override
  List<Object> get props => [name];
}

class UpdateSpace extends SpacesEvent {
  final SpaceEntity space;

  const UpdateSpace(this.space);

  @override
  List<Object> get props => [space];
}

class DeleteSpace extends SpacesEvent {
  final int id;

  const DeleteSpace(this.id);

  @override
  List<Object> get props => [id];
}

// States
abstract class SpacesState extends Equatable {
  const SpacesState();

  @override
  List<Object?> get props => [];
}

class SpacesLoading extends SpacesState {
  const SpacesLoading();
}

class SpacesLoaded extends SpacesState {
  final List<SpaceEntity> spaces;

  const SpacesLoaded(this.spaces);

  @override
  List<Object> get props => [spaces];
}

class SpacesError extends SpacesState {
  final String message;

  const SpacesError(this.message);

  @override
  List<Object> get props => [message];
}

// Bloc
class SpacesBloc extends Bloc<SpacesEvent, SpacesState> {
  final SpaceRepository _spaceRepository;

  SpacesBloc({required SpaceRepository spaceRepository})
    : _spaceRepository = spaceRepository,
      super(const SpacesLoading()) {
    on<LoadSpaces>(_onLoadSpaces);
    on<AddSpace>(_onAddSpace);
    on<UpdateSpace>(_onUpdateSpace);
    on<DeleteSpace>(_onDeleteSpace);
  }

  Future<void> _onLoadSpaces(
    LoadSpaces event,
    Emitter<SpacesState> emit,
  ) async {
    emit(const SpacesLoading());
    try {
      final spaces = await _spaceRepository.getAllSpaces();
      emit(SpacesLoaded(spaces));
    } catch (e) {
      emit(SpacesError(e.toString()));
    }
  }

  Future<void> _onAddSpace(AddSpace event, Emitter<SpacesState> emit) async {
    try {
      final currentState = state;
      if (currentState is SpacesLoaded) {
        // Create a new space
        final now = DateTime.now().millisecondsSinceEpoch;
        final space = SpaceEntity(name: event.name, createdAt: now);

        await _spaceRepository.createSpace(space);

        // Reload the spaces to get the updated list with card counts
        final spaces = await _spaceRepository.getAllSpaces();
        emit(SpacesLoaded(spaces));
      }
    } catch (e) {
      emit(SpacesError(e.toString()));
    }
  }

  Future<void> _onUpdateSpace(
    UpdateSpace event,
    Emitter<SpacesState> emit,
  ) async {
    try {
      final currentState = state;
      if (currentState is SpacesLoaded) {
        await _spaceRepository.updateSpace(event.space);

        // Reload the spaces to get the updated list
        final spaces = await _spaceRepository.getAllSpaces();
        emit(SpacesLoaded(spaces));
      }
    } catch (e) {
      emit(SpacesError(e.toString()));
    }
  }

  Future<void> _onDeleteSpace(
    DeleteSpace event,
    Emitter<SpacesState> emit,
  ) async {
    try {
      final currentState = state;
      if (currentState is SpacesLoaded) {
        await _spaceRepository.deleteSpace(event.id);

        // Reload the spaces to get the updated list
        final spaces = await _spaceRepository.getAllSpaces();
        emit(SpacesLoaded(spaces));
      }
    } catch (e) {
      emit(SpacesError(e.toString()));
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\blocs\spaces\space_cards_bloc.dart
=========================================
--- Content Start ---
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:equatable/equatable.dart';

import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

// Events
abstract class SpaceCardsEvent extends Equatable {
  const SpaceCardsEvent();

  @override
  List<Object?> get props => [];
}

class LoadSpaceCards extends SpaceCardsEvent {
  final int spaceId;
  final int offset;
  final int limit;

  const LoadSpaceCards(this.spaceId, {this.offset = 0, this.limit = 40});

  @override
  List<Object> get props => [spaceId, offset, limit];
}

class MoveCardToSpace extends SpaceCardsEvent {
  final int cardId;
  final int? targetSpaceId;

  const MoveCardToSpace(this.cardId, this.targetSpaceId);

  @override
  List<Object?> get props => [cardId, targetSpaceId];
}

class AddCardToSpace extends SpaceCardsEvent {
  final CardEntity card;
  final int spaceId;

  const AddCardToSpace(this.card, this.spaceId);

  @override
  List<Object> get props => [card, spaceId];
}

// States
abstract class SpaceCardsState extends Equatable {
  const SpaceCardsState();

  @override
  List<Object?> get props => [];
}

class SpaceCardsLoading extends SpaceCardsState {
  const SpaceCardsLoading();
}

class SpaceCardsLoaded extends SpaceCardsState {
  final List<CardEntity> cards;
  final int spaceId;
  final bool hasMore;
  final int offset;

  const SpaceCardsLoaded({
    required this.cards,
    required this.spaceId,
    this.hasMore = false,
    this.offset = 0,
  });

  @override
  List<Object> get props => [cards, spaceId, hasMore, offset];
}

class SpaceCardsError extends SpaceCardsState {
  final String message;

  const SpaceCardsError(this.message);

  @override
  List<Object> get props => [message];
}

// Bloc
class SpaceCardsBloc extends Bloc<SpaceCardsEvent, SpaceCardsState> {
  final CardRepository _cardRepository;
  final int pageSize = 40;

  SpaceCardsBloc({required CardRepository cardRepository})
    : _cardRepository = cardRepository,
      super(const SpaceCardsLoading()) {
    on<LoadSpaceCards>(_onLoadSpaceCards);
    on<MoveCardToSpace>(_onMoveCardToSpace);
    on<AddCardToSpace>(_onAddCardToSpace);
  }

  Future<void> _onLoadSpaceCards(
    LoadSpaceCards event,
    Emitter<SpaceCardsState> emit,
  ) async {
    print('SpaceCardsBloc: Loading cards for space ID: ${event.spaceId}');
    if (event.offset == 0) {
      // First load or refresh
      emit(const SpaceCardsLoading());
    }

    try {
      // Load cards for this space
      final cards = await _cardRepository.getCardsBySpaceId(
        event.spaceId,
        offset: event.offset,
        limit: event.limit,
      );

      print(
        'SpaceCardsBloc: Loaded ${cards.length} cards for space ID: ${event.spaceId}',
      );

      // Log image cards
      final imageCards = cards.where((card) => card.type == 'image').toList();
      print('SpaceCardsBloc: Found ${imageCards.length} image cards');
      for (final card in imageCards) {
        print(
          'SpaceCardsBloc: Image card ID: ${card.id}, path: ${card.imagePath}',
        );
      }

      // If we got a full page, there might be more
      final hasMore = cards.length == event.limit;

      // Add to existing list for pagination, or use as initial list
      if (event.offset > 0 && state is SpaceCardsLoaded) {
        final currentState = state as SpaceCardsLoaded;
        final updatedCards = [...currentState.cards, ...cards];
        emit(
          SpaceCardsLoaded(
            cards: updatedCards,
            spaceId: event.spaceId,
            hasMore: hasMore,
            offset: event.offset + cards.length,
          ),
        );
      } else {
        emit(
          SpaceCardsLoaded(
            cards: cards,
            spaceId: event.spaceId,
            hasMore: hasMore,
            offset: cards.length,
          ),
        );
      }
    } catch (e) {
      emit(SpaceCardsError(e.toString()));
    }
  }

  Future<void> _onMoveCardToSpace(
    MoveCardToSpace event,
    Emitter<SpaceCardsState> emit,
  ) async {
    try {
      await _cardRepository.moveCardToSpace(event.cardId, event.targetSpaceId);

      // If this is a move from the current space, refresh the list
      if (state is SpaceCardsLoaded) {
        final currentState = state as SpaceCardsLoaded;
        if (event.targetSpaceId != currentState.spaceId) {
          // The card was moved out, reload cards for the current space
          add(LoadSpaceCards(currentState.spaceId));
        }
      }
    } catch (e) {
      emit(SpaceCardsError(e.toString()));
    }
  }

  Future<void> _onAddCardToSpace(
    AddCardToSpace event,
    Emitter<SpaceCardsState> emit,
  ) async {
    try {
      await _cardRepository.addCardToSpace(event.card, event.spaceId);

      // If this card was added to the current space, refresh the list
      if (state is SpaceCardsLoaded) {
        final currentState = state as SpaceCardsLoaded;
        if (event.spaceId == currentState.spaceId) {
          // The card was added to this space, reload cards
          add(LoadSpaceCards(currentState.spaceId));
        }
      }
    } catch (e) {
      emit(SpaceCardsError(e.toString()));
    }
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\data ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\data\card_dao.dart
=========================================
--- Content Start ---
part of 'database.dart';

@DriftAccessor(tables: [Cards])
class CardDao extends DatabaseAccessor<AppDatabase> with _$CardDaoMixin {
  CardDao(super.db);

  // Insert a card using direct SQL to avoid dependency on generated code
  Future<int> insertCard(CardEntity card) async {
    // Rather than using customStatement with an array of parameters,
    // let's explicitly construct the SQL statement with proper value handling

    print("CardDAO: Inserting new card of type: ${card.type}");
    if (card.type == 'image') {
      print("CardDAO: Image path: ${card.imagePath}");
      if (card.imagePath != null) {
        // Check if the image file exists
        final file = File(card.imagePath!);
        final exists = await file.exists();
        print("CardDAO: Image file exists? $exists at ${file.absolute.path}");
      }
    }

    // Helper function to handle SQL string values
    String sqlString(String? value) =>
        value == null ? 'NULL' : "'${value.replaceAll("'", "''")}'";

    // Helper function to handle SQL int values
    String sqlInt(int? value) => value?.toString() ?? 'NULL';

    final query =
        '''
      INSERT INTO cards (
        type, content, body, image_path, url, space_id, created_at, updated_at
      ) VALUES (
        '${card.type}', 
        '${card.content.replaceAll("'", "''")}',
        ${sqlString(card.body)},
        ${sqlString(card.imagePath)},
        ${sqlString(card.url)},
        ${sqlInt(card.spaceId)},
        ${card.createdAt},
        ${card.updatedAt}
      )
    ''';

    await customStatement(query, []);

    // Get the last inserted ID
    final result = await customSelect(
      'SELECT last_insert_rowid() as id',
    ).getSingle();

    return result.data['id'] as int;
  }

  Future<List<CardEntity>> getAllCards({int offset = 0, int limit = 40}) async {
    final query = '''
      SELECT * FROM cards 
      ORDER BY created_at DESC 
      LIMIT ? OFFSET ?
    ''';

    final rows = await customSelect(
      query,
      variables: [Variable<int>(limit), Variable<int>(offset)],
    ).get();

    return rows.map((row) => mapRowToCardEntity(row.data)).toList();
  }

  Future<List<CardEntity>> searchCards(String query) async {
    final like = '%${query.replaceAll('%', '\\%').replaceAll('_', '\\_')}%';
    final sqlQuery = '''
      SELECT * FROM cards 
      WHERE content LIKE ? 
         OR (body IS NOT NULL AND body LIKE ?) 
         OR (url IS NOT NULL AND url LIKE ?)
      ORDER BY created_at DESC 
      LIMIT 100
    ''';

    final rows = await customSelect(
      sqlQuery,
      variables: [
        Variable<String>(like),
        Variable<String>(like),
        Variable<String>(like),
      ],
    ).get();

    return rows.map((row) => mapRowToCardEntity(row.data)).toList();
  }

  Future<void> deleteCard(int id) async {
    await customStatement('DELETE FROM cards WHERE id = ?', [id]);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\card_entity.dart
=========================================
--- Content Start ---
// A simple plain Dart model representing a Card record in the local DB.
// Keeping it independent of Drift types makes it easy to test and use in UI.

class CardEntity {
  final int? id;
  final String type; // "text", "image", or "link"
  final String content; // title or short text
  final String? body; // full note text (nullable)
  final String? imagePath; // local file path (nullable)
  final String? url; // original URL if link (nullable)
  final String? transcript; // YouTube transcript if available (nullable)
  final int? spaceId; // ID of the space this card belongs to (nullable)
  final int createdAt; // epoch millis
  final int updatedAt; // epoch millis

  const CardEntity({
    this.id,
    required this.type,
    required this.content,
    this.body,
    this.imagePath,
    this.url,
    this.transcript,
    this.spaceId,
    required this.createdAt,
    required this.updatedAt,
  });

  @override
  String toString() {
    return 'CardEntity(id: $id, type: $type, content: $content, body: ${body?.substring(0, body!.length > 20 ? 20 : body!.length)}..., imagePath: $imagePath, url: $url, transcript: ${transcript != null ? 'available' : 'null'}, spaceId: $spaceId)';
  }

  CardEntity copyWith({
    int? id,
    String? type,
    String? content,
    String? body,
    String? imagePath,
    String? url,
    String? transcript,
    int? spaceId,
    int? createdAt,
    int? updatedAt,
  }) {
    return CardEntity(
      id: id ?? this.id,
      type: type ?? this.type,
      content: content ?? this.content,
      body: body ?? this.body,
      imagePath: imagePath ?? this.imagePath,
      url: url ?? this.url,
      transcript: transcript ?? this.transcript,
      spaceId: spaceId ?? this.spaceId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\database.dart
=========================================
--- Content Start ---
import 'dart:io';

import 'package:drift/drift.dart';
import 'package:drift/native.dart';
import 'package:path_provider/path_provider.dart';
import 'card_entity.dart';
import 'space_entity.dart';

part 'database.g.dart';
part 'card_dao.dart';
part 'space_dao.dart';

// Drift table definition for spaces
class Spaces extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get name => text()();
  IntColumn get createdAt => integer()();
}

// Drift table definition for cards
class Cards extends Table {
  IntColumn get id => integer().autoIncrement()();
  TextColumn get type => text()();
  TextColumn get content => text()();
  TextColumn get body => text().nullable()();
  TextColumn get imagePath => text().nullable()();
  TextColumn get url => text().nullable()();
  TextColumn get transcript =>
      text().nullable()(); // Added for YouTube transcripts
  IntColumn get spaceId => integer().nullable().references(Spaces, #id)();
  IntColumn get createdAt => integer()();
  IntColumn get updatedAt => integer()();
}

@DriftDatabase(tables: [Cards, Spaces], daos: [CardDao, SpaceDao])
class AppDatabase extends _$AppDatabase {
  AppDatabase._internal(QueryExecutor e) : super(e);

  static AppDatabase? _instance;

  factory AppDatabase() =>
      _instance ??= AppDatabase._internal(_openConnection());

  @override
  int get schemaVersion => 3;

  @override
  MigrationStrategy get migration => MigrationStrategy(
    onCreate: (m) => m.createAll(),
    onUpgrade: (m, from, to) async {
      if (from < 2) {
        // In version 2, we're adding spaces functionality
        // First create the spaces table
        await customStatement('''
          CREATE TABLE spaces (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            name TEXT NOT NULL,
            created_at INTEGER NOT NULL
          )
        ''');

        // Then add the space_id column to cards table
        await customStatement(
          'ALTER TABLE cards ADD COLUMN space_id INTEGER REFERENCES spaces(id)',
        );
      }

      if (from == 2) {
        // In version 3, we're adding YouTube transcript support
        await customStatement('ALTER TABLE cards ADD COLUMN transcript TEXT');
      }
    },
  );
}

LazyDatabase _openConnection() {
  return LazyDatabase(() async {
    try {
      // For mobile platforms
      if (Platform.isAndroid || Platform.isIOS) {
        final dir = await getApplicationDocumentsDirectory();
        final dbPath = '${dir.path}${Platform.pathSeparator}retainly.db';
        final file = File(dbPath);
        return NativeDatabase(file);
      }
    } catch (e) {
      // Handle case when path_provider doesn't work or platform isn't supported
      // Fallback to a temporary location - don't use in production
      final file = File('retainly.db');
      return NativeDatabase(file);
    }

    // Fallback for web, desktop, or any other platform
    final file = File('retainly.db');
    return NativeDatabase(file);
  });
}

/* 
 * Mapping helpers between Drift rows and Entities
 * NOTE: Temporarily commented out until code generation is run
 * These mappings will be uncommented once the Drift classes are generated
 */

/*
// Mapping helpers between Drift row and CardEntity
extension CardMapper on Card {
  CardEntity toEntity() => CardEntity(
    id: id,
    type: type,
    content: content,
    body: body,
    imagePath: imagePath,
    url: url,
    spaceId: spaceId,
    createdAt: createdAt,
    updatedAt: updatedAt,
  );
}

extension CardCompanionMapper on CardEntity {
  CardsCompanion toCompanion() => CardsCompanion.insert(
    type: type,
    content: content,
    body: Value(body),
    imagePath: Value(imagePath),
    url: Value(url),
    spaceId: Value(spaceId),
    createdAt: createdAt,
    updatedAt: updatedAt,
  );
}

// Mapping helpers for Spaces
extension SpaceMapper on Space {
  SpaceEntity toEntity({int? cardCount}) => SpaceEntity(
    id: id,
    name: name,
    createdAt: createdAt,
    cardCount: cardCount,
  );
}

extension SpaceCompanionMapper on SpaceEntity {
  SpacesCompanion toCompanion() =>
      SpacesCompanion.insert(name: name, createdAt: createdAt);
}
*/

// Manual mapping functions to use until code generation is complete
// These will be replaced by the extensions above after running the generator
CardEntity mapRowToCardEntity(Map<String, dynamic> row) {
  return CardEntity(
    id: row['id'] as int?,
    type: row['type'] as String,
    content: row['content'] as String,
    body: row['body'] as String?,
    imagePath: row['image_path'] as String?,
    url: row['url'] as String?,
    spaceId: row['space_id'] as int?,
    createdAt: row['created_at'] as int,
    updatedAt: row['updated_at'] as int,
  );
}

SpaceEntity mapRowToSpaceEntity(Map<String, dynamic> row, {int? cardCount}) {
  return SpaceEntity(
    id: row['id'] as int?,
    name: row['name'] as String,
    createdAt: row['created_at'] as int,
    cardCount: cardCount,
  );
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\database.g.dart
=========================================
--- Content Start ---
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'database.dart';

// ignore_for_file: type=lint
class $SpacesTable extends Spaces with TableInfo<$SpacesTable, Space> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $SpacesTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _nameMeta = const VerificationMeta('name');
  @override
  late final GeneratedColumn<String> name = GeneratedColumn<String>(
    'name',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [id, name, createdAt];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'spaces';
  @override
  VerificationContext validateIntegrity(
    Insertable<Space> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('name')) {
      context.handle(
        _nameMeta,
        name.isAcceptableOrUnknown(data['name']!, _nameMeta),
      );
    } else if (isInserting) {
      context.missing(_nameMeta);
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Space map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Space(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      name: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}name'],
      )!,
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
    );
  }

  @override
  $SpacesTable createAlias(String alias) {
    return $SpacesTable(attachedDatabase, alias);
  }
}

class Space extends DataClass implements Insertable<Space> {
  final int id;
  final String name;
  final int createdAt;
  const Space({required this.id, required this.name, required this.createdAt});
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['name'] = Variable<String>(name);
    map['created_at'] = Variable<int>(createdAt);
    return map;
  }

  SpacesCompanion toCompanion(bool nullToAbsent) {
    return SpacesCompanion(
      id: Value(id),
      name: Value(name),
      createdAt: Value(createdAt),
    );
  }

  factory Space.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Space(
      id: serializer.fromJson<int>(json['id']),
      name: serializer.fromJson<String>(json['name']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'name': serializer.toJson<String>(name),
      'createdAt': serializer.toJson<int>(createdAt),
    };
  }

  Space copyWith({int? id, String? name, int? createdAt}) => Space(
    id: id ?? this.id,
    name: name ?? this.name,
    createdAt: createdAt ?? this.createdAt,
  );
  Space copyWithCompanion(SpacesCompanion data) {
    return Space(
      id: data.id.present ? data.id.value : this.id,
      name: data.name.present ? data.name.value : this.name,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Space(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(id, name, createdAt);
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Space &&
          other.id == this.id &&
          other.name == this.name &&
          other.createdAt == this.createdAt);
}

class SpacesCompanion extends UpdateCompanion<Space> {
  final Value<int> id;
  final Value<String> name;
  final Value<int> createdAt;
  const SpacesCompanion({
    this.id = const Value.absent(),
    this.name = const Value.absent(),
    this.createdAt = const Value.absent(),
  });
  SpacesCompanion.insert({
    this.id = const Value.absent(),
    required String name,
    required int createdAt,
  }) : name = Value(name),
       createdAt = Value(createdAt);
  static Insertable<Space> custom({
    Expression<int>? id,
    Expression<String>? name,
    Expression<int>? createdAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (name != null) 'name': name,
      if (createdAt != null) 'created_at': createdAt,
    });
  }

  SpacesCompanion copyWith({
    Value<int>? id,
    Value<String>? name,
    Value<int>? createdAt,
  }) {
    return SpacesCompanion(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (name.present) {
      map['name'] = Variable<String>(name.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('SpacesCompanion(')
          ..write('id: $id, ')
          ..write('name: $name, ')
          ..write('createdAt: $createdAt')
          ..write(')'))
        .toString();
  }
}

class $CardsTable extends Cards with TableInfo<$CardsTable, Card> {
  @override
  final GeneratedDatabase attachedDatabase;
  final String? _alias;
  $CardsTable(this.attachedDatabase, [this._alias]);
  static const VerificationMeta _idMeta = const VerificationMeta('id');
  @override
  late final GeneratedColumn<int> id = GeneratedColumn<int>(
    'id',
    aliasedName,
    false,
    hasAutoIncrement: true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'PRIMARY KEY AUTOINCREMENT',
    ),
  );
  static const VerificationMeta _typeMeta = const VerificationMeta('type');
  @override
  late final GeneratedColumn<String> type = GeneratedColumn<String>(
    'type',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _contentMeta = const VerificationMeta(
    'content',
  );
  @override
  late final GeneratedColumn<String> content = GeneratedColumn<String>(
    'content',
    aliasedName,
    false,
    type: DriftSqlType.string,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _bodyMeta = const VerificationMeta('body');
  @override
  late final GeneratedColumn<String> body = GeneratedColumn<String>(
    'body',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _imagePathMeta = const VerificationMeta(
    'imagePath',
  );
  @override
  late final GeneratedColumn<String> imagePath = GeneratedColumn<String>(
    'image_path',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _urlMeta = const VerificationMeta('url');
  @override
  late final GeneratedColumn<String> url = GeneratedColumn<String>(
    'url',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _transcriptMeta = const VerificationMeta(
    'transcript',
  );
  @override
  late final GeneratedColumn<String> transcript = GeneratedColumn<String>(
    'transcript',
    aliasedName,
    true,
    type: DriftSqlType.string,
    requiredDuringInsert: false,
  );
  static const VerificationMeta _spaceIdMeta = const VerificationMeta(
    'spaceId',
  );
  @override
  late final GeneratedColumn<int> spaceId = GeneratedColumn<int>(
    'space_id',
    aliasedName,
    true,
    type: DriftSqlType.int,
    requiredDuringInsert: false,
    defaultConstraints: GeneratedColumn.constraintIsAlways(
      'REFERENCES spaces (id)',
    ),
  );
  static const VerificationMeta _createdAtMeta = const VerificationMeta(
    'createdAt',
  );
  @override
  late final GeneratedColumn<int> createdAt = GeneratedColumn<int>(
    'created_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  static const VerificationMeta _updatedAtMeta = const VerificationMeta(
    'updatedAt',
  );
  @override
  late final GeneratedColumn<int> updatedAt = GeneratedColumn<int>(
    'updated_at',
    aliasedName,
    false,
    type: DriftSqlType.int,
    requiredDuringInsert: true,
  );
  @override
  List<GeneratedColumn> get $columns => [
    id,
    type,
    content,
    body,
    imagePath,
    url,
    transcript,
    spaceId,
    createdAt,
    updatedAt,
  ];
  @override
  String get aliasedName => _alias ?? actualTableName;
  @override
  String get actualTableName => $name;
  static const String $name = 'cards';
  @override
  VerificationContext validateIntegrity(
    Insertable<Card> instance, {
    bool isInserting = false,
  }) {
    final context = VerificationContext();
    final data = instance.toColumns(true);
    if (data.containsKey('id')) {
      context.handle(_idMeta, id.isAcceptableOrUnknown(data['id']!, _idMeta));
    }
    if (data.containsKey('type')) {
      context.handle(
        _typeMeta,
        type.isAcceptableOrUnknown(data['type']!, _typeMeta),
      );
    } else if (isInserting) {
      context.missing(_typeMeta);
    }
    if (data.containsKey('content')) {
      context.handle(
        _contentMeta,
        content.isAcceptableOrUnknown(data['content']!, _contentMeta),
      );
    } else if (isInserting) {
      context.missing(_contentMeta);
    }
    if (data.containsKey('body')) {
      context.handle(
        _bodyMeta,
        body.isAcceptableOrUnknown(data['body']!, _bodyMeta),
      );
    }
    if (data.containsKey('image_path')) {
      context.handle(
        _imagePathMeta,
        imagePath.isAcceptableOrUnknown(data['image_path']!, _imagePathMeta),
      );
    }
    if (data.containsKey('url')) {
      context.handle(
        _urlMeta,
        url.isAcceptableOrUnknown(data['url']!, _urlMeta),
      );
    }
    if (data.containsKey('transcript')) {
      context.handle(
        _transcriptMeta,
        transcript.isAcceptableOrUnknown(data['transcript']!, _transcriptMeta),
      );
    }
    if (data.containsKey('space_id')) {
      context.handle(
        _spaceIdMeta,
        spaceId.isAcceptableOrUnknown(data['space_id']!, _spaceIdMeta),
      );
    }
    if (data.containsKey('created_at')) {
      context.handle(
        _createdAtMeta,
        createdAt.isAcceptableOrUnknown(data['created_at']!, _createdAtMeta),
      );
    } else if (isInserting) {
      context.missing(_createdAtMeta);
    }
    if (data.containsKey('updated_at')) {
      context.handle(
        _updatedAtMeta,
        updatedAt.isAcceptableOrUnknown(data['updated_at']!, _updatedAtMeta),
      );
    } else if (isInserting) {
      context.missing(_updatedAtMeta);
    }
    return context;
  }

  @override
  Set<GeneratedColumn> get $primaryKey => {id};
  @override
  Card map(Map<String, dynamic> data, {String? tablePrefix}) {
    final effectivePrefix = tablePrefix != null ? '$tablePrefix.' : '';
    return Card(
      id: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}id'],
      )!,
      type: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}type'],
      )!,
      content: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}content'],
      )!,
      body: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}body'],
      ),
      imagePath: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}image_path'],
      ),
      url: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}url'],
      ),
      transcript: attachedDatabase.typeMapping.read(
        DriftSqlType.string,
        data['${effectivePrefix}transcript'],
      ),
      spaceId: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}space_id'],
      ),
      createdAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}created_at'],
      )!,
      updatedAt: attachedDatabase.typeMapping.read(
        DriftSqlType.int,
        data['${effectivePrefix}updated_at'],
      )!,
    );
  }

  @override
  $CardsTable createAlias(String alias) {
    return $CardsTable(attachedDatabase, alias);
  }
}

class Card extends DataClass implements Insertable<Card> {
  final int id;
  final String type;
  final String content;
  final String? body;
  final String? imagePath;
  final String? url;
  final String? transcript;
  final int? spaceId;
  final int createdAt;
  final int updatedAt;
  const Card({
    required this.id,
    required this.type,
    required this.content,
    this.body,
    this.imagePath,
    this.url,
    this.transcript,
    this.spaceId,
    required this.createdAt,
    required this.updatedAt,
  });
  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    map['id'] = Variable<int>(id);
    map['type'] = Variable<String>(type);
    map['content'] = Variable<String>(content);
    if (!nullToAbsent || body != null) {
      map['body'] = Variable<String>(body);
    }
    if (!nullToAbsent || imagePath != null) {
      map['image_path'] = Variable<String>(imagePath);
    }
    if (!nullToAbsent || url != null) {
      map['url'] = Variable<String>(url);
    }
    if (!nullToAbsent || transcript != null) {
      map['transcript'] = Variable<String>(transcript);
    }
    if (!nullToAbsent || spaceId != null) {
      map['space_id'] = Variable<int>(spaceId);
    }
    map['created_at'] = Variable<int>(createdAt);
    map['updated_at'] = Variable<int>(updatedAt);
    return map;
  }

  CardsCompanion toCompanion(bool nullToAbsent) {
    return CardsCompanion(
      id: Value(id),
      type: Value(type),
      content: Value(content),
      body: body == null && nullToAbsent ? const Value.absent() : Value(body),
      imagePath: imagePath == null && nullToAbsent
          ? const Value.absent()
          : Value(imagePath),
      url: url == null && nullToAbsent ? const Value.absent() : Value(url),
      transcript: transcript == null && nullToAbsent
          ? const Value.absent()
          : Value(transcript),
      spaceId: spaceId == null && nullToAbsent
          ? const Value.absent()
          : Value(spaceId),
      createdAt: Value(createdAt),
      updatedAt: Value(updatedAt),
    );
  }

  factory Card.fromJson(
    Map<String, dynamic> json, {
    ValueSerializer? serializer,
  }) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return Card(
      id: serializer.fromJson<int>(json['id']),
      type: serializer.fromJson<String>(json['type']),
      content: serializer.fromJson<String>(json['content']),
      body: serializer.fromJson<String?>(json['body']),
      imagePath: serializer.fromJson<String?>(json['imagePath']),
      url: serializer.fromJson<String?>(json['url']),
      transcript: serializer.fromJson<String?>(json['transcript']),
      spaceId: serializer.fromJson<int?>(json['spaceId']),
      createdAt: serializer.fromJson<int>(json['createdAt']),
      updatedAt: serializer.fromJson<int>(json['updatedAt']),
    );
  }
  @override
  Map<String, dynamic> toJson({ValueSerializer? serializer}) {
    serializer ??= driftRuntimeOptions.defaultSerializer;
    return <String, dynamic>{
      'id': serializer.toJson<int>(id),
      'type': serializer.toJson<String>(type),
      'content': serializer.toJson<String>(content),
      'body': serializer.toJson<String?>(body),
      'imagePath': serializer.toJson<String?>(imagePath),
      'url': serializer.toJson<String?>(url),
      'transcript': serializer.toJson<String?>(transcript),
      'spaceId': serializer.toJson<int?>(spaceId),
      'createdAt': serializer.toJson<int>(createdAt),
      'updatedAt': serializer.toJson<int>(updatedAt),
    };
  }

  Card copyWith({
    int? id,
    String? type,
    String? content,
    Value<String?> body = const Value.absent(),
    Value<String?> imagePath = const Value.absent(),
    Value<String?> url = const Value.absent(),
    Value<String?> transcript = const Value.absent(),
    Value<int?> spaceId = const Value.absent(),
    int? createdAt,
    int? updatedAt,
  }) => Card(
    id: id ?? this.id,
    type: type ?? this.type,
    content: content ?? this.content,
    body: body.present ? body.value : this.body,
    imagePath: imagePath.present ? imagePath.value : this.imagePath,
    url: url.present ? url.value : this.url,
    transcript: transcript.present ? transcript.value : this.transcript,
    spaceId: spaceId.present ? spaceId.value : this.spaceId,
    createdAt: createdAt ?? this.createdAt,
    updatedAt: updatedAt ?? this.updatedAt,
  );
  Card copyWithCompanion(CardsCompanion data) {
    return Card(
      id: data.id.present ? data.id.value : this.id,
      type: data.type.present ? data.type.value : this.type,
      content: data.content.present ? data.content.value : this.content,
      body: data.body.present ? data.body.value : this.body,
      imagePath: data.imagePath.present ? data.imagePath.value : this.imagePath,
      url: data.url.present ? data.url.value : this.url,
      transcript: data.transcript.present
          ? data.transcript.value
          : this.transcript,
      spaceId: data.spaceId.present ? data.spaceId.value : this.spaceId,
      createdAt: data.createdAt.present ? data.createdAt.value : this.createdAt,
      updatedAt: data.updatedAt.present ? data.updatedAt.value : this.updatedAt,
    );
  }

  @override
  String toString() {
    return (StringBuffer('Card(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('content: $content, ')
          ..write('body: $body, ')
          ..write('imagePath: $imagePath, ')
          ..write('url: $url, ')
          ..write('transcript: $transcript, ')
          ..write('spaceId: $spaceId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }

  @override
  int get hashCode => Object.hash(
    id,
    type,
    content,
    body,
    imagePath,
    url,
    transcript,
    spaceId,
    createdAt,
    updatedAt,
  );
  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      (other is Card &&
          other.id == this.id &&
          other.type == this.type &&
          other.content == this.content &&
          other.body == this.body &&
          other.imagePath == this.imagePath &&
          other.url == this.url &&
          other.transcript == this.transcript &&
          other.spaceId == this.spaceId &&
          other.createdAt == this.createdAt &&
          other.updatedAt == this.updatedAt);
}

class CardsCompanion extends UpdateCompanion<Card> {
  final Value<int> id;
  final Value<String> type;
  final Value<String> content;
  final Value<String?> body;
  final Value<String?> imagePath;
  final Value<String?> url;
  final Value<String?> transcript;
  final Value<int?> spaceId;
  final Value<int> createdAt;
  final Value<int> updatedAt;
  const CardsCompanion({
    this.id = const Value.absent(),
    this.type = const Value.absent(),
    this.content = const Value.absent(),
    this.body = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.url = const Value.absent(),
    this.transcript = const Value.absent(),
    this.spaceId = const Value.absent(),
    this.createdAt = const Value.absent(),
    this.updatedAt = const Value.absent(),
  });
  CardsCompanion.insert({
    this.id = const Value.absent(),
    required String type,
    required String content,
    this.body = const Value.absent(),
    this.imagePath = const Value.absent(),
    this.url = const Value.absent(),
    this.transcript = const Value.absent(),
    this.spaceId = const Value.absent(),
    required int createdAt,
    required int updatedAt,
  }) : type = Value(type),
       content = Value(content),
       createdAt = Value(createdAt),
       updatedAt = Value(updatedAt);
  static Insertable<Card> custom({
    Expression<int>? id,
    Expression<String>? type,
    Expression<String>? content,
    Expression<String>? body,
    Expression<String>? imagePath,
    Expression<String>? url,
    Expression<String>? transcript,
    Expression<int>? spaceId,
    Expression<int>? createdAt,
    Expression<int>? updatedAt,
  }) {
    return RawValuesInsertable({
      if (id != null) 'id': id,
      if (type != null) 'type': type,
      if (content != null) 'content': content,
      if (body != null) 'body': body,
      if (imagePath != null) 'image_path': imagePath,
      if (url != null) 'url': url,
      if (transcript != null) 'transcript': transcript,
      if (spaceId != null) 'space_id': spaceId,
      if (createdAt != null) 'created_at': createdAt,
      if (updatedAt != null) 'updated_at': updatedAt,
    });
  }

  CardsCompanion copyWith({
    Value<int>? id,
    Value<String>? type,
    Value<String>? content,
    Value<String?>? body,
    Value<String?>? imagePath,
    Value<String?>? url,
    Value<String?>? transcript,
    Value<int?>? spaceId,
    Value<int>? createdAt,
    Value<int>? updatedAt,
  }) {
    return CardsCompanion(
      id: id ?? this.id,
      type: type ?? this.type,
      content: content ?? this.content,
      body: body ?? this.body,
      imagePath: imagePath ?? this.imagePath,
      url: url ?? this.url,
      transcript: transcript ?? this.transcript,
      spaceId: spaceId ?? this.spaceId,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
    );
  }

  @override
  Map<String, Expression> toColumns(bool nullToAbsent) {
    final map = <String, Expression>{};
    if (id.present) {
      map['id'] = Variable<int>(id.value);
    }
    if (type.present) {
      map['type'] = Variable<String>(type.value);
    }
    if (content.present) {
      map['content'] = Variable<String>(content.value);
    }
    if (body.present) {
      map['body'] = Variable<String>(body.value);
    }
    if (imagePath.present) {
      map['image_path'] = Variable<String>(imagePath.value);
    }
    if (url.present) {
      map['url'] = Variable<String>(url.value);
    }
    if (transcript.present) {
      map['transcript'] = Variable<String>(transcript.value);
    }
    if (spaceId.present) {
      map['space_id'] = Variable<int>(spaceId.value);
    }
    if (createdAt.present) {
      map['created_at'] = Variable<int>(createdAt.value);
    }
    if (updatedAt.present) {
      map['updated_at'] = Variable<int>(updatedAt.value);
    }
    return map;
  }

  @override
  String toString() {
    return (StringBuffer('CardsCompanion(')
          ..write('id: $id, ')
          ..write('type: $type, ')
          ..write('content: $content, ')
          ..write('body: $body, ')
          ..write('imagePath: $imagePath, ')
          ..write('url: $url, ')
          ..write('transcript: $transcript, ')
          ..write('spaceId: $spaceId, ')
          ..write('createdAt: $createdAt, ')
          ..write('updatedAt: $updatedAt')
          ..write(')'))
        .toString();
  }
}

abstract class _$AppDatabase extends GeneratedDatabase {
  _$AppDatabase(QueryExecutor e) : super(e);
  $AppDatabaseManager get managers => $AppDatabaseManager(this);
  late final $SpacesTable spaces = $SpacesTable(this);
  late final $CardsTable cards = $CardsTable(this);
  late final CardDao cardDao = CardDao(this as AppDatabase);
  late final SpaceDao spaceDao = SpaceDao(this as AppDatabase);
  @override
  Iterable<TableInfo<Table, Object?>> get allTables =>
      allSchemaEntities.whereType<TableInfo<Table, Object?>>();
  @override
  List<DatabaseSchemaEntity> get allSchemaEntities => [spaces, cards];
}

typedef $$SpacesTableCreateCompanionBuilder =
    SpacesCompanion Function({
      Value<int> id,
      required String name,
      required int createdAt,
    });
typedef $$SpacesTableUpdateCompanionBuilder =
    SpacesCompanion Function({
      Value<int> id,
      Value<String> name,
      Value<int> createdAt,
    });

final class $$SpacesTableReferences
    extends BaseReferences<_$AppDatabase, $SpacesTable, Space> {
  $$SpacesTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static MultiTypedResultKey<$CardsTable, List<Card>> _cardsRefsTable(
    _$AppDatabase db,
  ) => MultiTypedResultKey.fromTable(
    db.cards,
    aliasName: $_aliasNameGenerator(db.spaces.id, db.cards.spaceId),
  );

  $$CardsTableProcessedTableManager get cardsRefs {
    final manager = $$CardsTableTableManager(
      $_db,
      $_db.cards,
    ).filter((f) => f.spaceId.id.sqlEquals($_itemColumn<int>('id')!));

    final cache = $_typedResult.readTableOrNull(_cardsRefsTable($_db));
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: cache),
    );
  }
}

class $$SpacesTableFilterComposer
    extends Composer<_$AppDatabase, $SpacesTable> {
  $$SpacesTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  Expression<bool> cardsRefs(
    Expression<bool> Function($$CardsTableFilterComposer f) f,
  ) {
    final $$CardsTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cards,
      getReferencedColumn: (t) => t.spaceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CardsTableFilterComposer(
            $db: $db,
            $table: $db.cards,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SpacesTableOrderingComposer
    extends Composer<_$AppDatabase, $SpacesTable> {
  $$SpacesTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get name => $composableBuilder(
    column: $table.name,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );
}

class $$SpacesTableAnnotationComposer
    extends Composer<_$AppDatabase, $SpacesTable> {
  $$SpacesTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get name =>
      $composableBuilder(column: $table.name, builder: (column) => column);

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  Expression<T> cardsRefs<T extends Object>(
    Expression<T> Function($$CardsTableAnnotationComposer a) f,
  ) {
    final $$CardsTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.id,
      referencedTable: $db.cards,
      getReferencedColumn: (t) => t.spaceId,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$CardsTableAnnotationComposer(
            $db: $db,
            $table: $db.cards,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return f(composer);
  }
}

class $$SpacesTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $SpacesTable,
          Space,
          $$SpacesTableFilterComposer,
          $$SpacesTableOrderingComposer,
          $$SpacesTableAnnotationComposer,
          $$SpacesTableCreateCompanionBuilder,
          $$SpacesTableUpdateCompanionBuilder,
          (Space, $$SpacesTableReferences),
          Space,
          PrefetchHooks Function({bool cardsRefs})
        > {
  $$SpacesTableTableManager(_$AppDatabase db, $SpacesTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$SpacesTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$SpacesTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$SpacesTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> name = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
              }) => SpacesCompanion(id: id, name: name, createdAt: createdAt),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String name,
                required int createdAt,
              }) => SpacesCompanion.insert(
                id: id,
                name: name,
                createdAt: createdAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$SpacesTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({cardsRefs = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [if (cardsRefs) db.cards],
              addJoins: null,
              getPrefetchedDataCallback: (items) async {
                return [
                  if (cardsRefs)
                    await $_getPrefetchedData<Space, $SpacesTable, Card>(
                      currentTable: table,
                      referencedTable: $$SpacesTableReferences._cardsRefsTable(
                        db,
                      ),
                      managerFromTypedResult: (p0) =>
                          $$SpacesTableReferences(db, table, p0).cardsRefs,
                      referencedItemsForCurrentItem: (item, referencedItems) =>
                          referencedItems.where((e) => e.spaceId == item.id),
                      typedResults: items,
                    ),
                ];
              },
            );
          },
        ),
      );
}

typedef $$SpacesTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $SpacesTable,
      Space,
      $$SpacesTableFilterComposer,
      $$SpacesTableOrderingComposer,
      $$SpacesTableAnnotationComposer,
      $$SpacesTableCreateCompanionBuilder,
      $$SpacesTableUpdateCompanionBuilder,
      (Space, $$SpacesTableReferences),
      Space,
      PrefetchHooks Function({bool cardsRefs})
    >;
typedef $$CardsTableCreateCompanionBuilder =
    CardsCompanion Function({
      Value<int> id,
      required String type,
      required String content,
      Value<String?> body,
      Value<String?> imagePath,
      Value<String?> url,
      Value<String?> transcript,
      Value<int?> spaceId,
      required int createdAt,
      required int updatedAt,
    });
typedef $$CardsTableUpdateCompanionBuilder =
    CardsCompanion Function({
      Value<int> id,
      Value<String> type,
      Value<String> content,
      Value<String?> body,
      Value<String?> imagePath,
      Value<String?> url,
      Value<String?> transcript,
      Value<int?> spaceId,
      Value<int> createdAt,
      Value<int> updatedAt,
    });

final class $$CardsTableReferences
    extends BaseReferences<_$AppDatabase, $CardsTable, Card> {
  $$CardsTableReferences(super.$_db, super.$_table, super.$_typedResult);

  static $SpacesTable _spaceIdTable(_$AppDatabase db) => db.spaces.createAlias(
    $_aliasNameGenerator(db.cards.spaceId, db.spaces.id),
  );

  $$SpacesTableProcessedTableManager? get spaceId {
    final $_column = $_itemColumn<int>('space_id');
    if ($_column == null) return null;
    final manager = $$SpacesTableTableManager(
      $_db,
      $_db.spaces,
    ).filter((f) => f.id.sqlEquals($_column));
    final item = $_typedResult.readTableOrNull(_spaceIdTable($_db));
    if (item == null) return manager;
    return ProcessedTableManager(
      manager.$state.copyWith(prefetchedData: [item]),
    );
  }
}

class $$CardsTableFilterComposer extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableFilterComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnFilters<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get url => $composableBuilder(
    column: $table.url,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<String> get transcript => $composableBuilder(
    column: $table.transcript,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnFilters(column),
  );

  ColumnFilters<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnFilters(column),
  );

  $$SpacesTableFilterComposer get spaceId {
    final $$SpacesTableFilterComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.spaceId,
      referencedTable: $db.spaces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SpacesTableFilterComposer(
            $db: $db,
            $table: $db.spaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CardsTableOrderingComposer
    extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableOrderingComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  ColumnOrderings<int> get id => $composableBuilder(
    column: $table.id,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get type => $composableBuilder(
    column: $table.type,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get content => $composableBuilder(
    column: $table.content,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get body => $composableBuilder(
    column: $table.body,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get imagePath => $composableBuilder(
    column: $table.imagePath,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get url => $composableBuilder(
    column: $table.url,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<String> get transcript => $composableBuilder(
    column: $table.transcript,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get createdAt => $composableBuilder(
    column: $table.createdAt,
    builder: (column) => ColumnOrderings(column),
  );

  ColumnOrderings<int> get updatedAt => $composableBuilder(
    column: $table.updatedAt,
    builder: (column) => ColumnOrderings(column),
  );

  $$SpacesTableOrderingComposer get spaceId {
    final $$SpacesTableOrderingComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.spaceId,
      referencedTable: $db.spaces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SpacesTableOrderingComposer(
            $db: $db,
            $table: $db.spaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CardsTableAnnotationComposer
    extends Composer<_$AppDatabase, $CardsTable> {
  $$CardsTableAnnotationComposer({
    required super.$db,
    required super.$table,
    super.joinBuilder,
    super.$addJoinBuilderToRootComposer,
    super.$removeJoinBuilderFromRootComposer,
  });
  GeneratedColumn<int> get id =>
      $composableBuilder(column: $table.id, builder: (column) => column);

  GeneratedColumn<String> get type =>
      $composableBuilder(column: $table.type, builder: (column) => column);

  GeneratedColumn<String> get content =>
      $composableBuilder(column: $table.content, builder: (column) => column);

  GeneratedColumn<String> get body =>
      $composableBuilder(column: $table.body, builder: (column) => column);

  GeneratedColumn<String> get imagePath =>
      $composableBuilder(column: $table.imagePath, builder: (column) => column);

  GeneratedColumn<String> get url =>
      $composableBuilder(column: $table.url, builder: (column) => column);

  GeneratedColumn<String> get transcript => $composableBuilder(
    column: $table.transcript,
    builder: (column) => column,
  );

  GeneratedColumn<int> get createdAt =>
      $composableBuilder(column: $table.createdAt, builder: (column) => column);

  GeneratedColumn<int> get updatedAt =>
      $composableBuilder(column: $table.updatedAt, builder: (column) => column);

  $$SpacesTableAnnotationComposer get spaceId {
    final $$SpacesTableAnnotationComposer composer = $composerBuilder(
      composer: this,
      getCurrentColumn: (t) => t.spaceId,
      referencedTable: $db.spaces,
      getReferencedColumn: (t) => t.id,
      builder:
          (
            joinBuilder, {
            $addJoinBuilderToRootComposer,
            $removeJoinBuilderFromRootComposer,
          }) => $$SpacesTableAnnotationComposer(
            $db: $db,
            $table: $db.spaces,
            $addJoinBuilderToRootComposer: $addJoinBuilderToRootComposer,
            joinBuilder: joinBuilder,
            $removeJoinBuilderFromRootComposer:
                $removeJoinBuilderFromRootComposer,
          ),
    );
    return composer;
  }
}

class $$CardsTableTableManager
    extends
        RootTableManager<
          _$AppDatabase,
          $CardsTable,
          Card,
          $$CardsTableFilterComposer,
          $$CardsTableOrderingComposer,
          $$CardsTableAnnotationComposer,
          $$CardsTableCreateCompanionBuilder,
          $$CardsTableUpdateCompanionBuilder,
          (Card, $$CardsTableReferences),
          Card,
          PrefetchHooks Function({bool spaceId})
        > {
  $$CardsTableTableManager(_$AppDatabase db, $CardsTable table)
    : super(
        TableManagerState(
          db: db,
          table: table,
          createFilteringComposer: () =>
              $$CardsTableFilterComposer($db: db, $table: table),
          createOrderingComposer: () =>
              $$CardsTableOrderingComposer($db: db, $table: table),
          createComputedFieldComposer: () =>
              $$CardsTableAnnotationComposer($db: db, $table: table),
          updateCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                Value<String> type = const Value.absent(),
                Value<String> content = const Value.absent(),
                Value<String?> body = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> url = const Value.absent(),
                Value<String?> transcript = const Value.absent(),
                Value<int?> spaceId = const Value.absent(),
                Value<int> createdAt = const Value.absent(),
                Value<int> updatedAt = const Value.absent(),
              }) => CardsCompanion(
                id: id,
                type: type,
                content: content,
                body: body,
                imagePath: imagePath,
                url: url,
                transcript: transcript,
                spaceId: spaceId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          createCompanionCallback:
              ({
                Value<int> id = const Value.absent(),
                required String type,
                required String content,
                Value<String?> body = const Value.absent(),
                Value<String?> imagePath = const Value.absent(),
                Value<String?> url = const Value.absent(),
                Value<String?> transcript = const Value.absent(),
                Value<int?> spaceId = const Value.absent(),
                required int createdAt,
                required int updatedAt,
              }) => CardsCompanion.insert(
                id: id,
                type: type,
                content: content,
                body: body,
                imagePath: imagePath,
                url: url,
                transcript: transcript,
                spaceId: spaceId,
                createdAt: createdAt,
                updatedAt: updatedAt,
              ),
          withReferenceMapper: (p0) => p0
              .map(
                (e) =>
                    (e.readTable(table), $$CardsTableReferences(db, table, e)),
              )
              .toList(),
          prefetchHooksCallback: ({spaceId = false}) {
            return PrefetchHooks(
              db: db,
              explicitlyWatchedTables: [],
              addJoins:
                  <
                    T extends TableManagerState<
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic,
                      dynamic
                    >
                  >(state) {
                    if (spaceId) {
                      state =
                          state.withJoin(
                                currentTable: table,
                                currentColumn: table.spaceId,
                                referencedTable: $$CardsTableReferences
                                    ._spaceIdTable(db),
                                referencedColumn: $$CardsTableReferences
                                    ._spaceIdTable(db)
                                    .id,
                              )
                              as T;
                    }

                    return state;
                  },
              getPrefetchedDataCallback: (items) async {
                return [];
              },
            );
          },
        ),
      );
}

typedef $$CardsTableProcessedTableManager =
    ProcessedTableManager<
      _$AppDatabase,
      $CardsTable,
      Card,
      $$CardsTableFilterComposer,
      $$CardsTableOrderingComposer,
      $$CardsTableAnnotationComposer,
      $$CardsTableCreateCompanionBuilder,
      $$CardsTableUpdateCompanionBuilder,
      (Card, $$CardsTableReferences),
      Card,
      PrefetchHooks Function({bool spaceId})
    >;

class $AppDatabaseManager {
  final _$AppDatabase _db;
  $AppDatabaseManager(this._db);
  $$SpacesTableTableManager get spaces =>
      $$SpacesTableTableManager(_db, _db.spaces);
  $$CardsTableTableManager get cards =>
      $$CardsTableTableManager(_db, _db.cards);
}

mixin _$CardDaoMixin on DatabaseAccessor<AppDatabase> {
  $SpacesTable get spaces => attachedDatabase.spaces;
  $CardsTable get cards => attachedDatabase.cards;
}
mixin _$SpaceDaoMixin on DatabaseAccessor<AppDatabase> {
  $SpacesTable get spaces => attachedDatabase.spaces;
  $CardsTable get cards => attachedDatabase.cards;
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\space_dao.dart
=========================================
--- Content Start ---
part of 'database.dart';

@DriftAccessor(tables: [Spaces, Cards])
class SpaceDao extends DatabaseAccessor<AppDatabase> {
  SpaceDao(super.db);

  // Create a new space
  Future<int> createSpace(SpaceEntity space) async {
    // Using direct SQL with proper escaping for string values
    final query =
        '''
      INSERT INTO spaces (name, created_at) 
      VALUES ('${space.name.replaceAll("'", "''")}', ${space.createdAt})
    ''';

    await customStatement(query, []);

    // Get the last inserted ID
    final result = await customSelect(
      'SELECT last_insert_rowid() as id',
    ).getSingle();

    return result.data['id'] as int;
  }

  // Get all spaces with card counts
  Future<List<SpaceEntity>> getAllSpaces() async {
    // We need to run a join query to get the card counts
    final query = '''
      SELECT s.id, s.name, s.created_at, COUNT(c.id) as card_count 
      FROM spaces s 
      LEFT JOIN cards c ON c.space_id = s.id 
      GROUP BY s.id 
      ORDER BY s.created_at DESC
    ''';

    final rows = await customSelect(query).get();

    return rows.map((row) {
      return mapRowToSpaceEntity(
        row.data,
        cardCount: row.data['card_count'] as int,
      );
    }).toList();
  }

  // Get cards by space ID
  Future<List<CardEntity>> getCardsBySpaceId(
    int spaceId, {
    int offset = 0,
    int limit = 40,
  }) async {
    // Use a direct query with interpolation instead of parameters
    final directQuery =
        '''
      SELECT * FROM cards 
      WHERE space_id = $spaceId
      ORDER BY created_at DESC 
      LIMIT $limit OFFSET $offset
    ''';

    final rows = await customSelect(directQuery).get();

    return rows.map((row) => mapRowToCardEntity(row.data)).toList();
  }

  // Delete a space and update its cards to have null spaceId
  Future<void> deleteSpace(int id) async {
    // First update any cards in this space to have null spaceId
    await customStatement(
      'UPDATE cards SET space_id = NULL WHERE space_id = $id',
      [],
    );

    // Then delete the space
    await customStatement('DELETE FROM spaces WHERE id = $id', []);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\space_entity.dart
=========================================
--- Content Start ---
// A simple plain Dart model representing a Space record in the local DB.
// Similar to CardEntity, keeping it independent of Drift types

class SpaceEntity {
  final int? id;
  final String name;
  final int createdAt; // epoch millis
  final int? cardCount; // Optional count for UI display

  const SpaceEntity({
    this.id,
    required this.name,
    required this.createdAt,
    this.cardCount,
  });

  SpaceEntity copyWith({
    int? id,
    String? name,
    int? createdAt,
    int? cardCount,
  }) {
    return SpaceEntity(
      id: id ?? this.id,
      name: name ?? this.name,
      createdAt: createdAt ?? this.createdAt,
      cardCount: cardCount ?? this.cardCount,
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\data\repository ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\data\repository\card_repository.dart
=========================================
--- Content Start ---
import 'dart:io';

import '../../data/card_entity.dart';
import '../../data/database.dart';
import '../../utils/image_storage.dart';
import 'package:drift/drift.dart';

/// Repository to abstract database access for cards
class CardRepository {
  final AppDatabase _database;
  final ImageStorage _imageStorage;

  CardRepository({AppDatabase? database, ImageStorage? imageStorage})
    : _database = database ?? AppDatabase(),
      _imageStorage = imageStorage ?? ImageStorage();

  Future<int> addCard(CardEntity card) async {
    print('Repository: Adding card of type: ${card.type}');

    // Extra validation for image cards
    if (card.type == 'image') {
      print('Repository: Image path: ${card.imagePath}');
      if (card.imagePath != null) {
        try {
          final file = File(card.imagePath!);
          final exists = await file.exists();
          final fileSize = exists ? await file.length() : 0;

          print(
            'Repository: Image file exists? $exists, size: $fileSize bytes',
          );

          if (!exists) {
            print('Repository: WARNING - Image file does not exist!');
            throw Exception(
              'Image file does not exist at path: ${card.imagePath}',
            );
          }

          if (fileSize <= 0) {
            print('Repository: WARNING - Image file is empty!');
            throw Exception('Image file is empty at path: ${card.imagePath}');
          }
        } catch (e) {
          print('Repository: Error checking image file: $e');
          throw Exception('Error accessing image file: ${e.toString()}');
        }
      } else {
        print('Repository: WARNING - Image path is null!');
        throw Exception('Cannot add image card with null image path');
      }
    }

    try {
      final id = await _database.cardDao.insertCard(card);
      print('Repository: Card added with ID: $id');

      // Verify the card was actually added
      final verifyQuery = 'SELECT * FROM cards WHERE id = $id';
      final result = await _database.customSelect(verifyQuery).get();
      if (result.isEmpty) {
        print('Repository: ERROR - Card not found after insertion!');
        throw Exception('Card was not saved correctly');
      }

      print('Repository: Card verified in database with ID: $id');
      return id;
    } catch (e) {
      print('Repository: ERROR adding card - $e');
      rethrow;
    }
  }

  Future<List<CardEntity>> getAllCards({int offset = 0, int limit = 40}) {
    return _database.cardDao.getAllCards(offset: offset, limit: limit);
  }

  Future<List<CardEntity>> getGlobalCards({
    int offset = 0,
    int limit = 40,
  }) async {
    final query = '''
      SELECT * FROM cards 
      WHERE space_id IS NULL
      ORDER BY created_at DESC 
      LIMIT ? OFFSET ?
    ''';

    final result = await _database
        .customSelect(
          query,
          variables: [Variable<int>(limit), Variable<int>(offset)],
        )
        .get();

    return result
        .map(
          (row) => CardEntity(
            id: row.read<int>('id'),
            type: row.read<String>('type'),
            content: row.read<String>('content'),
            body: row.readNullable<String>('body'),
            imagePath: row.readNullable<String>('image_path'),
            url: row.readNullable<String>('url'),
            spaceId: row.readNullable<int>('space_id'),
            createdAt: row.read<int>('created_at'),
            updatedAt: row.read<int>('updated_at'),
          ),
        )
        .toList();
  }

  Future<List<CardEntity>> searchCards(String query) {
    return _database.cardDao.searchCards(query);
  }

  Future<List<CardEntity>> getCardsBySpaceId(
    int spaceId, {
    int offset = 0,
    int limit = 40,
  }) async {
    print('Repository: Fetching cards for space ID: $spaceId');

    final directQuery =
        'SELECT * FROM cards WHERE space_id = $spaceId ORDER BY created_at DESC LIMIT $limit OFFSET $offset';

    final result = await _database.customSelect(directQuery).get();

    final cards = result.map((row) => mapRowToCardEntity(row.data)).toList();
    print('Repository: Found ${cards.length} cards in space ID: $spaceId');

    // Debug image cards
    final imageCards = cards.where((card) => card.type == 'image').toList();
    print('Repository: Found ${imageCards.length} image cards');

    // Verify all image cards have valid paths
    for (final card in imageCards) {
      print('Repository: Image card ID: ${card.id}, path: ${card.imagePath}');

      // Skip remote images (start with http)
      if (card.imagePath != null && !card.imagePath!.startsWith('http')) {
        try {
          // Check if the image file exists
          final file = File(card.imagePath!);
          final exists = await file.exists();
          print('Repository: Image file exists? $exists');

          if (!exists) {
            print(
              'Repository: WARNING - Image file not found: ${card.imagePath}',
            );
          } else {
            final size = await file.length();
            print('Repository: Image file size: ${size / 1024}KB');
          }
        } catch (e) {
          print('Repository: Error checking image file: $e');
        }
      }
    }

    return cards;
  }

  Future<int> addCardToSpace(CardEntity card, int spaceId) {
    final cardWithSpace = card.copyWith(spaceId: spaceId);
    return addCard(cardWithSpace);
  }

  Future<void> moveCardToSpace(int cardId, int? spaceId) async {
    // We'll use a custom SQL update with direct interpolation
    final query = spaceId != null
        ? 'UPDATE cards SET space_id = $spaceId WHERE id = $cardId'
        : 'UPDATE cards SET space_id = NULL WHERE id = $cardId';

    await _database.customStatement(query, []);
  }

  Future<void> deleteCard(int id) async {
    // First, get the card to check for associated files
    final cards = await _database.cardDao.getAllCards();
    final card = cards.firstWhere(
      (c) => c.id == id,
      orElse: () => throw Exception('Card not found'),
    );

    // Delete any associated files
    if (card.imagePath != null && !card.imagePath!.startsWith('http')) {
      await _imageStorage.deleteImagePair(card.imagePath!);
    }

    // Delete the database record
    return _database.cardDao.deleteCard(id);
  }

  /// Create a sample card for testing
  Future<int> createSampleCard() {
    final now = DateTime.now().millisecondsSinceEpoch;
    final card = CardEntity(
      type: 'text',
      content: 'Sample Note',
      body: 'This is a sample note created for testing the database.',
      createdAt: now,
      updatedAt: now,
    );
    return addCard(card);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\data\repository\space_repository.dart
=========================================
--- Content Start ---
import '../../data/space_entity.dart';
import '../../data/database.dart';

/// Repository to abstract database access for spaces
class SpaceRepository {
  final AppDatabase _database;

  SpaceRepository({AppDatabase? database})
    : _database = database ?? AppDatabase();

  // Create a new space
  Future<int> createSpace(SpaceEntity space) async {
    // Using a direct SQL insert with string interpolation
    final query =
        '''
      INSERT INTO spaces (name, created_at) 
      VALUES ('${space.name.replaceAll("'", "''")}', ${space.createdAt})
    ''';

    await _database.customStatement(query, []);

    // Get the last inserted ID
    final result = await _database
        .customSelect('SELECT last_insert_rowid() as id')
        .getSingle();

    return result.data['id'] as int;
  }

  // Get all spaces with card counts
  Future<List<SpaceEntity>> getAllSpaces() async {
    // We'll create a custom SQL query to get spaces with card counts
    final query = '''
      SELECT s.id, s.name, s.created_at, COUNT(c.id) as card_count 
      FROM spaces s 
      LEFT JOIN cards c ON c.space_id = s.id 
      GROUP BY s.id 
      ORDER BY s.created_at DESC
    ''';

    final result = await _database.customSelect(query).get();

    return result
        .map(
          (row) => SpaceEntity(
            id: row.data['id'] as int,
            name: row.data['name'] as String,
            createdAt: row.data['created_at'] as int,
            cardCount: row.data['card_count'] as int,
          ),
        )
        .toList();
  }

  // Delete a space (cards will remain in global view with null spaceId)
  Future<void> deleteSpace(int id) async {
    // First update any cards in this space to have null spaceId
    await _database.customStatement(
      'UPDATE cards SET space_id = NULL WHERE space_id = $id',
      [],
    );

    // Then delete the space
    await _database.customStatement('DELETE FROM spaces WHERE id = $id', []);
  }

  // Update a space's name
  Future<void> updateSpace(SpaceEntity space) async {
    if (space.id == null) {
      throw ArgumentError('Space ID cannot be null for update');
    }

    // Escape single quotes in name
    final escapedName = space.name.replaceAll("'", "''");
    await _database.customStatement(
      "UPDATE spaces SET name = '$escapedName' WHERE id = ${space.id!}",
      [],
    );
  }

  // Create a sample space for testing
  Future<int> createSampleSpace() {
    final now = DateTime.now().millisecondsSinceEpoch;
    final space = SpaceEntity(name: 'Sample Space', createdAt: now);
    return createSpace(space);
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\services ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\services\youtube_service.dart
=========================================
--- Content Start ---
import 'dart:convert';
import 'dart:io';
import 'dart:math';
import 'package:http/http.dart' as http;
import 'package:html/parser.dart' as html_parser;
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart';

class YouTubeService {
  final String? apiKey;

  YouTubeService({this.apiKey});

  /// Checks if a given URL is a YouTube URL.
  bool isYoutubeUrl(String url) {
    final normalizedUrl = url.toLowerCase();

    // Check for common YouTube URL patterns
    return normalizedUrl.contains('youtube.com/watch') ||
        normalizedUrl.contains('youtu.be/') ||
        normalizedUrl.contains('youtube.com/shorts/') ||
        normalizedUrl.contains('youtube.com/v/');
  }

  /// Extracts the video ID from a YouTube URL.
  /// Returns null if the video ID cannot be extracted.
  String? extractVideoId(String url) {
    // Handle youtu.be short links
    RegExp youtubeBe = RegExp(r'youtu\.be/([a-zA-Z0-9_-]{11})');
    Match? youtubeBeMatch = youtubeBe.firstMatch(url);
    if (youtubeBeMatch != null && youtubeBeMatch.groupCount >= 1) {
      return youtubeBeMatch.group(1);
    }

    // Handle youtube.com/shorts/ links
    RegExp youtubeShorts = RegExp(r'youtube\.com/shorts/([a-zA-Z0-9_-]{11})');
    Match? youtubeShortsMatch = youtubeShorts.firstMatch(url);
    if (youtubeShortsMatch != null && youtubeShortsMatch.groupCount >= 1) {
      return youtubeShortsMatch.group(1);
    }

    // Handle youtube.com/v/ links
    RegExp youtubeV = RegExp(r'youtube\.com/v/([a-zA-Z0-9_-]{11})');
    Match? youtubeVMatch = youtubeV.firstMatch(url);
    if (youtubeVMatch != null && youtubeVMatch.groupCount >= 1) {
      return youtubeVMatch.group(1);
    }

    // Handle youtube.com/watch?v= links
    try {
      Uri uri = Uri.parse(url);
      if (uri.host.contains('youtube.com') && uri.path.contains('watch')) {
        return uri.queryParameters['v'];
      }
    } catch (e) {
      print('Error parsing YouTube URL: $e');
    }

    // Try a generic regex as fallback for any URL containing an 11-character ID
    RegExp genericIdPattern = RegExp(
      r'(?:^|[^a-zA-Z0-9_-])([a-zA-Z0-9_-]{11})(?:$|[^a-zA-Z0-9_-])',
    );
    Match? genericMatch = genericIdPattern.firstMatch(url);
    if (genericMatch != null && genericMatch.groupCount >= 1) {
      return genericMatch.group(1);
    }

    return null;
  }

  /// Fetches a YouTube video thumbnail and saves it locally.
  /// Returns the local path to the saved thumbnail.
  Future<String?> fetchThumbnail(String videoId) async {
    try {
      // Try the maxresdefault quality first (highest quality)
      String thumbnailUrl =
          'https://img.youtube.com/vi/$videoId/maxresdefault.jpg';

      final response = await http.get(Uri.parse(thumbnailUrl));

      // If maxres not available, try hqdefault
      if (response.statusCode != 200) {
        thumbnailUrl = 'https://img.youtube.com/vi/$videoId/hqdefault.jpg';
        final fallbackResponse = await http.get(Uri.parse(thumbnailUrl));

        if (fallbackResponse.statusCode != 200) {
          print('Failed to fetch YouTube thumbnail for video ID: $videoId');
          return null;
        }

        return await _saveThumbnailToFile(videoId, fallbackResponse.bodyBytes);
      }

      return await _saveThumbnailToFile(videoId, response.bodyBytes);
    } catch (e) {
      print('Error fetching YouTube thumbnail: $e');
      return null;
    }
  }

  /// Save the thumbnail bytes to a local file and return the file path
  Future<String?> _saveThumbnailToFile(
    String videoId,
    List<int> imageBytes,
  ) async {
    try {
      final directory = await getTemporaryDirectory();
      final filePath = '${directory.path}/${const Uuid().v4()}_$videoId.jpg';

      final File file = File(filePath);
      await file.writeAsBytes(imageBytes);

      print('Thumbnail saved to: $filePath');
      return filePath;
    } catch (e) {
      print('Error saving thumbnail to file: $e');
      return null;
    }
  }

  /// Attempts to fetch the transcript for a YouTube video.
  /// This tries multiple methods to maximize success, including auto-generated captions.
  Future<String?> fetchTranscript(String videoId) async {
    print('======= STARTING TRANSCRIPT FETCH FOR VIDEO ID: $videoId =======');

    // Try each method in order, with detailed logging

    // METHOD 1: Official API (if key available)
    if (apiKey != null) {
      try {
        print('Method 1: Trying YouTube Data API with key');
        final apiTranscript = await _fetchTranscriptWithAPI(videoId);
        if (apiTranscript != null && apiTranscript.isNotEmpty) {
          print(
            'SUCCESS: Got transcript via YouTube Data API (${apiTranscript.length} chars)',
          );
          return apiTranscript;
        } else {
          print('FAIL: YouTube Data API returned no transcript');
        }
      } catch (e) {
        print('ERROR: YouTube Data API fetch failed: $e');
      }
    } else {
      print('SKIP: No YouTube API key provided, skipping API method');
    }

    // METHOD 2: Timedtext API (most reliable for auto-generated captions)
    try {
      print('Method 2: Trying YouTube timedtext API (best for auto-generated)');
      final timedTextTranscript = await _fetchTranscriptFromTimedText(videoId);
      if (timedTextTranscript != null && timedTextTranscript.isNotEmpty) {
        print(
          'SUCCESS: Got transcript via timedtext API (${timedTextTranscript.length} chars)',
        );
        return timedTextTranscript;
      } else {
        print('FAIL: Timedtext API returned no transcript');
      }
    } catch (e) {
      print('ERROR: Timedtext API fetch failed: $e');
    }

    // METHOD 3: HTML parsing (direct page extraction)
    try {
      print('Method 3: Trying direct HTML page parsing');
      final htmlTranscript = await _fetchTranscriptWithoutAPI(videoId);
      if (htmlTranscript != null && htmlTranscript.isNotEmpty) {
        print(
          'SUCCESS: Got transcript via HTML parsing (${htmlTranscript.length} chars)',
        );
        return htmlTranscript;
      } else {
        print('FAIL: HTML parsing returned no transcript');
      }
    } catch (e) {
      print('ERROR: HTML parsing fetch failed: $e');
    }

    print(
      '======= ALL TRANSCRIPT FETCH METHODS FAILED FOR VIDEO ID: $videoId =======',
    );
    return null; // No transcript available
  }

  /// Attempts to fetch the transcript for a YouTube video using the YouTube Data API.
  /// This requires an API key to access the Captions API.
  Future<String?> _fetchTranscriptWithAPI(String videoId) async {
    if (apiKey == null) {
      print('YouTube API key not provided, cannot fetch transcript via API');
      return null;
    }

    try {
      // Step 1: Get caption tracks for the video
      final captionsUrl =
          'https://www.googleapis.com/youtube/v3/captions?videoId=$videoId&part=snippet&key=$apiKey';

      final response = await http.get(Uri.parse(captionsUrl));

      if (response.statusCode != 200) {
        print('Failed to fetch captions list: ${response.statusCode}');
        return null;
      }

      final captionsData = json.decode(response.body);

      if (captionsData['items'] == null || captionsData['items'].isEmpty) {
        print('No caption tracks found for video ID: $videoId');
        return null;
      }

      // Try to find English captions first
      var captionId = '';
      for (var item in captionsData['items']) {
        final language = item['snippet']['language'];
        if (language == 'en') {
          captionId = item['id'];
          break;
        }
      }
      // If no English captions, use the first one available
      if (captionId.isEmpty && captionsData['items'].isNotEmpty) {
        captionId = captionsData['items'][0]['id'];
      }

      if (captionId.isEmpty) {
        print('No usable caption track found for video ID: $videoId');
        return null;
      }

      // Step 2: Fetch the actual caption track content
      final captionDownloadUrl =
          'https://www.googleapis.com/youtube/v3/captions/$captionId?key=$apiKey';

      final captionResponse = await http.get(
        Uri.parse(captionDownloadUrl),
        headers: {'Accept': 'text/plain'},
      );

      if (captionResponse.statusCode != 200) {
        print('Failed to fetch caption track: ${captionResponse.statusCode}');
        return null;
      }

      // Parse the caption data
      String rawTranscript = utf8.decode(captionResponse.bodyBytes);

      // Basic processing to clean up the transcript
      String processedTranscript = _processRawTranscript(rawTranscript);

      return processedTranscript;
    } catch (e) {
      print('Error fetching YouTube transcript via API: $e');
      return null;
    }
  }

  /// Method to fetch transcript from YouTube's timedtext API
  /// This method specifically targets auto-generated captions as well
  Future<String?> _fetchTranscriptFromTimedText(String videoId) async {
    try {
      // First, try the direct auto-generated captions URL format
      final directResult = await _tryDirectAutoCaptionsUrl(videoId);
      if (directResult != null && directResult.isNotEmpty) {
        print('Successfully fetched transcript via direct auto-captions URL');
        return directResult;
      }

      // If direct method fails, fall back to page parsing
      // First, fetch the video page to get the captions track URL
      final videoUrl =
          'https://www.youtube.com/watch?v=$videoId&cc_load_policy=1';
      final videoResponse = await http.get(Uri.parse(videoUrl));

      if (videoResponse.statusCode != 200) {
        return null;
      }

      // Try to find the timedtext URL
      final videoPageContent = videoResponse.body;

      // Extract the captionTracks section
      // This regex pattern gets all caption tracks, including auto-generated ones
      final regex = RegExp(r'"captionTracks":(\[.*?\])');
      final match = regex.firstMatch(videoPageContent);

      if (match == null || match.groupCount < 1) {
        print('Could not find captionTracks in the YouTube page');
        return null;
      }

      // Extract the JSON string and parse it
      final captionsJson = match.group(1)!;

      // First try to find auto-generated captions specifically (they're often more available)
      String captionUrl = '';

      // Try auto-generated English captions first (most common)
      captionUrl = _findCaptionUrl(captionsJson, true, 'en');

      // If not found, try regular English captions
      if (captionUrl.isEmpty) {
        captionUrl = _findCaptionUrl(captionsJson, false, 'en');
      }

      // If still not found, try any auto-generated captions
      if (captionUrl.isEmpty) {
        captionUrl = _findCaptionUrl(captionsJson, true);
      }

      // Last resort, try any captions
      if (captionUrl.isEmpty) {
        captionUrl = _findCaptionUrl(captionsJson, false);
      }

      // If still no captions found, return null
      if (captionUrl.isEmpty) {
        print(
          'No caption URLs found in: ${captionsJson.substring(0, min(100, captionsJson.length))}...',
        );
        return null;
      }

      // Clean up the URL (unescape characters)
      captionUrl = captionUrl.replaceAll('\\u0026', '&');

      print(
        'Found caption URL: ${captionUrl.substring(0, min(100, captionUrl.length))}...',
      );

      // Fetch the captions XML
      final captionsResponse = await http.get(Uri.parse(captionUrl));

      if (captionsResponse.statusCode != 200) {
        print('Failed to fetch captions XML: ${captionsResponse.statusCode}');
        return null;
      }

      // Parse the XML to extract text
      final captionsXml = captionsResponse.body;
      final document = html_parser.parse(captionsXml);
      final textElements = document.getElementsByTagName('text');

      StringBuffer transcript = StringBuffer();

      for (var element in textElements) {
        if (element.text.isNotEmpty) {
          transcript.writeln(element.text);
        }
      }

      return transcript.toString();
    } catch (e) {
      print('Error fetching transcript from timedtext: $e');
      return null;
    }
  }

  /// Fallback method to try to extract transcript from the video page directly
  /// This version specifically looks for auto-generated captions as well
  Future<String?> _fetchTranscriptWithoutAPI(String videoId) async {
    try {
      final url =
          'https://www.youtube.com/watch?v=$videoId&cc_lang_pref=en&cc_load_policy=1';
      final response = await http.get(Uri.parse(url));

      if (response.statusCode != 200) {
        print('Failed to fetch YouTube page: ${response.statusCode}');
        return null;
      }

      // Parse HTML content
      final document = html_parser.parse(response.body);

      // Try to find transcript in page data
      // This is a fragile approach as YouTube might change their page structure
      final scriptTags = document.getElementsByTagName('script');

      for (var script in scriptTags) {
        final content = script.text;

        if (content.contains('"captionTracks"') ||
            content.contains('"playerCaptionsTracklistRenderer"')) {
          // Try both captions patterns - auto-generated is our primary target

          // First, look specifically for auto-generated captions
          RegExp autoRegex = RegExp(r'"kind":"asr".*?"baseUrl":"(.*?)"');
          Match? autoMatch = autoRegex.firstMatch(content);

          if (autoMatch != null) {
            String captionUrl = autoMatch.group(1) ?? '';
            captionUrl = captionUrl.replaceAll('\\u0026', '&');
            print(
              'Found auto-generated caption URL: ${captionUrl.substring(0, min(100, captionUrl.length))}...',
            );

            // Fetch the caption file
            final captionResult = await _fetchCaptionFile(captionUrl);
            if (captionResult != null) {
              return captionResult;
            }
          }

          // If auto-generated captions aren't found, try regular captions
          RegExp regex = RegExp(r'"captionTracks":\[(.*?)\]');
          Match? match = regex.firstMatch(content);

          if (match != null) {
            String captionData = match.group(1) ?? '';

            // Look for baseUrl to caption track
            RegExp baseUrlRegex = RegExp(r'"baseUrl":"(.*?)"');
            Match? baseUrlMatch = baseUrlRegex.firstMatch(captionData);

            if (baseUrlMatch != null) {
              String captionUrl = baseUrlMatch.group(1) ?? '';
              captionUrl = captionUrl.replaceAll('\\u0026', '&');
              print(
                'Found regular caption URL: ${captionUrl.substring(0, min(100, captionUrl.length))}...',
              );

              // Fetch the caption file
              return await _fetchCaptionFile(captionUrl);
            }
          }
        }
      }

      // Try another approach - check for the playerCaptionsTracklistRenderer
      for (var script in scriptTags) {
        final content = script.text;
        if (content.contains('"playerCaptionsTracklistRenderer"')) {
          RegExp tracksRegex = RegExp(
            r'"playerCaptionsTracklistRenderer".*?"captionTracks":\s*(\[.*?\])',
          );
          Match? tracksMatch = tracksRegex.firstMatch(content);

          if (tracksMatch != null) {
            final tracksJson = tracksMatch.group(1)!;

            // Use our helper method to find caption URLs
            String captionUrl = _findCaptionUrl(
              tracksJson,
              true,
              'en',
            ); // Auto-generated English
            if (captionUrl.isEmpty) {
              captionUrl = _findCaptionUrl(
                tracksJson,
                false,
                'en',
              ); // Regular English
            }
            if (captionUrl.isEmpty) {
              captionUrl = _findCaptionUrl(
                tracksJson,
                true,
              ); // Any auto-generated
            }
            if (captionUrl.isEmpty) {
              captionUrl = _findCaptionUrl(tracksJson, false); // Any captions
            }

            if (captionUrl.isNotEmpty) {
              return await _fetchCaptionFile(captionUrl);
            }
          }
        }
      }
      print('Could not extract transcript from YouTube page');
      return null;
    } catch (e) {
      print('Error fetching transcript without API: $e');
      return null;
    }
  }

  /// Helper method to fetch and parse a caption file from a given URL
  Future<String?> _fetchCaptionFile(String captionUrl) async {
    try {
      // Fetch the actual caption file
      final captionResponse = await http.get(Uri.parse(captionUrl));

      if (captionResponse.statusCode == 200) {
        // Parse XML caption data
        final captionDoc = html_parser.parse(captionResponse.body);
        final textElements = captionDoc.getElementsByTagName('text');

        StringBuffer transcript = StringBuffer();

        for (var element in textElements) {
          final text = element.text;
          // element.text is not nullable in the html library
          if (text.isNotEmpty) {
            transcript.writeln(text);
          }
        }

        final result = transcript.toString();
        if (result.isNotEmpty) {
          return result;
        }
      }
      return null;
    } catch (e) {
      print('Error fetching caption file: $e');
      return null;
    }
  }

  /// Process raw transcript data into clean text
  String _processRawTranscript(String rawTranscript) {
    // This is a placeholder for transcript processing logic
    // Depending on the format of the raw transcript, you might need to:
    // - Remove timestamps
    // - Join caption segments into sentences
    // - Fix formatting

    // For now, just return the raw text with basic cleanup
    return rawTranscript
        .replaceAll(RegExp(r'\d+:\d+:\d+\.\d+'), '') // Remove timestamps
        .replaceAll(RegExp(r'[\r\n]+'), '\n') // Normalize newlines
        .trim();
  }

  /// Fetches the title of a YouTube video
  Future<String?> fetchYouTubeTitle(String videoId) async {
    try {
      if (apiKey == null) {
        return await _fetchYouTubeTitleWithoutAPI(videoId);
      }

      // Use YouTube Data API to fetch video details
      final url =
          'https://www.googleapis.com/youtube/v3/videos?part=snippet&id=$videoId&key=$apiKey';
      final response = await http.get(Uri.parse(url));

      if (response.statusCode != 200) {
        print('Failed to fetch video details: ${response.statusCode}');
        return await _fetchYouTubeTitleWithoutAPI(videoId);
      }

      final data = json.decode(response.body);

      if (data['items'] == null || data['items'].isEmpty) {
        print('No video details found for video ID: $videoId');
        return await _fetchYouTubeTitleWithoutAPI(videoId);
      }

      final title = data['items'][0]['snippet']['title'];
      return title;
    } catch (e) {
      print('Error fetching YouTube title via API: $e');
      return await _fetchYouTubeTitleWithoutAPI(videoId);
    }
  }

  /// Fallback method to extract title from YouTube page
  Future<String?> _fetchYouTubeTitleWithoutAPI(String videoId) async {
    try {
      final url = 'https://www.youtube.com/watch?v=$videoId';
      final response = await http.get(Uri.parse(url));

      if (response.statusCode != 200) {
        print('Failed to fetch YouTube page: ${response.statusCode}');
        return null;
      }

      // Parse HTML content
      final document = html_parser.parse(response.body);

      // Try to find the title
      final titleTags = document.getElementsByTagName('title');
      if (titleTags.isNotEmpty) {
        String title = titleTags.first.text;
        // Clean up the title (remove " - YouTube" suffix if present)
        if (title.endsWith(' - YouTube')) {
          title = title.substring(0, title.length - 10);
        }
        return title;
      }

      return null;
    } catch (e) {
      print('Error fetching YouTube title without API: $e');
      return null;
    }
  }

  /// Fetches the title of any web page
  Future<String?> fetchWebPageTitle(String url) async {
    try {
      final response = await http.get(Uri.parse(url));

      if (response.statusCode != 200) {
        print('Failed to fetch web page: ${response.statusCode}');
        return null;
      }

      // Parse HTML content
      final document = html_parser.parse(response.body);

      // Try to find the title
      final titleTags = document.getElementsByTagName('title');
      if (titleTags.isNotEmpty) {
        return titleTags.first.text;
      }

      // Try meta tags if title tag is not available
      final metaTags = document.getElementsByTagName('meta');
      for (var tag in metaTags) {
        if (tag.attributes['property'] == 'og:title' ||
            tag.attributes['name'] == 'title') {
          return tag.attributes['content'];
        }
      }

      return null;
    } catch (e) {
      print('Error fetching web page title: $e');
      return null;
    }
  }

  /// Try to fetch auto-generated captions directly using a known URL format
  Future<String?> _tryDirectAutoCaptionsUrl(String videoId) async {
    try {
      // This URL format directly requests auto-generated captions from YouTube
      final autoUrl =
          'https://www.youtube.com/api/timedtext?lang=en&v=$videoId&kind=asr';
      print('Trying direct auto-caption URL: $autoUrl');

      final response = await http.get(Uri.parse(autoUrl));

      if (response.statusCode != 200 || response.body.isEmpty) {
        return null;
      }

      // Parse XML caption data
      final captionsXml = response.body;
      if (!captionsXml.contains('<text ')) {
        return null; // No captions in the response
      }

      final document = html_parser.parse(captionsXml);
      final textElements = document.getElementsByTagName('text');

      StringBuffer transcript = StringBuffer();

      for (var element in textElements) {
        if (element.text.isNotEmpty) {
          transcript.writeln(element.text);
        }
      }

      final result = transcript.toString();
      if (result.isNotEmpty) {
        print('Successfully extracted auto captions from direct URL!');
        return result;
      }

      return null;
    } catch (e) {
      print('Error fetching direct auto-captions: $e');
      return null;
    }
  }

  /// Helper method to find caption URL in YouTube's captionTracks data
  /// If isAutoGenerated is true, it specifically looks for auto-generated captions
  /// If languageCode is provided, it looks for captions in that language
  String _findCaptionUrl(
    String captionsJson,
    bool isAutoGenerated, [
    String? languageCode,
  ]) {
    try {
      // Parse the JSON string
      // Need to handle possible JSON parsing issues
      if (!captionsJson.startsWith('[') || !captionsJson.endsWith(']')) {
        return '';
      }

      // Extract individual caption track entries
      RegExp trackRegex = RegExp(
        r'\{"baseUrl":"(.*?)","name":\{"simpleText":"(.*?)"\},"vssId":"(.*?)","languageCode":"(.*?)","kind":"(.*?)"',
      );
      Iterable<Match> matches = trackRegex.allMatches(captionsJson);

      for (var match in matches) {
        if (match.groupCount >= 5) {
          final url = match.group(1) ?? '';
          final name = match.group(2) ?? '';
          final vssId = match.group(3) ?? '';
          final trackLangCode = match.group(4) ?? '';
          final kind = match.group(5) ?? '';

          // Check if this is what we're looking for
          bool isAuto =
              name.toLowerCase().contains('auto') ||
              vssId.toLowerCase().contains('a.') ||
              kind.toLowerCase().contains('asr');

          // If we're looking for auto-generated and this is auto-generated,
          // or if we're NOT looking for auto-generated and this is NOT auto-generated
          if (isAutoGenerated == isAuto) {
            // If language code is specified and matches, return immediately
            if (languageCode != null && trackLangCode == languageCode) {
              return url;
            }
            // If no language specified, store the first matching URL
            else if (languageCode == null) {
              return url;
            }
          }
        }
      }

      return '';
    } catch (e) {
      print('Error parsing caption JSON: $e');
      return '';
    }
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui ---
--- Directory: D:\SDPProject\retainly\lib\src\ui\screens ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\add_card_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class AddCardScreen extends StatefulWidget {
  const AddCardScreen({super.key});

  @override
  State<AddCardScreen> createState() => _AddCardScreenState();
}

class _AddCardScreenState extends State<AddCardScreen> {
  final _formKey = GlobalKey<FormState>();
  final _repository = CardRepository();

  String _title = '';
  String _content = '';
  String _type = 'text'; // Default type
  bool _isSubmitting = false;

  void _submitForm() async {
    if (_formKey.currentState?.validate() ?? false) {
      _formKey.currentState?.save();

      setState(() {
        _isSubmitting = true;
      });

      try {
        final now = DateTime.now().millisecondsSinceEpoch;
        final card = CardEntity(
          type: _type,
          content: _title,
          body: _content,
          createdAt: now,
          updatedAt: now,
        );

        await _repository.addCard(card);

        if (mounted) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('Card added successfully')),
          );
          Navigator.pop(context, true); // Return success
        }
      } catch (e) {
        setState(() {
          _isSubmitting = false;
        });

        if (mounted) {
          ScaffoldMessenger.of(
            context,
          ).showSnackBar(SnackBar(content: Text('Failed to add card: $e')));
        }
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('Add Card')),
      body: Form(
        key: _formKey,
        child: ListView(
          padding: const EdgeInsets.all(16.0),
          children: [
            DropdownButtonFormField<String>(
              value: _type,
              decoration: const InputDecoration(labelText: 'Card Type'),
              items: const [
                DropdownMenuItem(value: 'text', child: Text('Text Note')),
                DropdownMenuItem(value: 'link', child: Text('Link')),
              ],
              onChanged: (value) {
                if (value != null) {
                  setState(() {
                    _type = value;
                  });
                }
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(labelText: 'Title'),
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Please enter a title';
                }
                return null;
              },
              onSaved: (value) {
                _title = value?.trim() ?? '';
              },
            ),
            const SizedBox(height: 16),
            TextFormField(
              decoration: const InputDecoration(
                labelText: 'Content',
                alignLabelWithHint: true,
              ),
              maxLines: 5,
              validator: (value) {
                if (value == null || value.trim().isEmpty) {
                  return 'Please enter content';
                }
                return null;
              },
              onSaved: (value) {
                _content = value?.trim() ?? '';
              },
            ),
            const SizedBox(height: 24),
            ElevatedButton(
              onPressed: _isSubmitting ? null : _submitForm,
              child: _isSubmitting
                  ? const SizedBox(
                      height: 20,
                      width: 20,
                      child: CircularProgressIndicator(strokeWidth: 2),
                    )
                  : const Text('Save Card'),
            ),
          ],
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\card_detail_screen.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:share_plus/share_plus.dart';
import 'package:video_player/video_player.dart';
import 'package:image_picker/image_picker.dart';

import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';
import '../../utils/url_utils.dart';

class CardDetailScreen extends StatefulWidget {
  final int cardId;

  const CardDetailScreen({super.key, required this.cardId});

  @override
  State<CardDetailScreen> createState() => _CardDetailScreenState();
}

class _CardDetailScreenState extends State<CardDetailScreen>
    with SingleTickerProviderStateMixin {
  late Future<CardEntity?> _cardFuture;
  VideoPlayerController? _videoController;
  final CardRepository _repository = CardRepository();
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _cardFuture = _loadCard();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeIn),
    );
    _animationController.forward();
  }

  Future<CardEntity?> _loadCard() async {
    try {
      final cards = await _repository.getAllCards();
      return cards.firstWhere((card) => card.id == widget.cardId);
    } catch (e) {
      return null;
    }
  }

  @override
  void dispose() {
    _videoController?.dispose();
    _animationController.dispose();
    super.dispose();
  }

  // Video player initialization was moved to a different location

  void _showDeleteConfirmation(CardEntity card) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E1E),
        title: const Text('Delete Card', style: TextStyle(color: Colors.white)),
        content: const Text(
          'Are you sure you want to delete this card?',
          style: TextStyle(color: Colors.white70),
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL'),
          ),
          ElevatedButton(
            onPressed: () {
              // Delete the card
              _repository.deleteCard(card.id!).then((_) {
                Navigator.of(context).pop(); // Close dialog
                Navigator.of(
                  context,
                ).pop(true); // Pop detail screen with reload flag
              });
            },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.red,
              foregroundColor: Colors.white,
            ),
            child: const Text('DELETE'),
          ),
        ],
      ),
    );
  }

  @override
  Widget build(BuildContext context) {
    return FutureBuilder<CardEntity?>(
      future: _cardFuture,
      builder: (context, snapshot) {
        if (snapshot.connectionState == ConnectionState.waiting) {
          return Scaffold(
            backgroundColor: const Color(0xFF121212),
            body: const Center(child: CircularProgressIndicator()),
          );
        } else if (snapshot.hasData) {
          final card = snapshot.data!;

          return Scaffold(
            backgroundColor: const Color(0xFF121212),
            appBar: AppBar(
              backgroundColor: const Color(0xFF121212),
              elevation: 0,
              leading: IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () => Navigator.of(context).pop(),
              ),
              actions: [
                if (card.type == 'link')
                  IconButton(
                    icon: const Icon(Icons.open_in_browser),
                    onPressed: () => _launchUrl(card.url!),
                    tooltip: 'Open URL',
                  ),
                if (card.type == 'image')
                  IconButton(
                    icon: const Icon(Icons.share),
                    onPressed: () async {
                      try {
                        await Share.shareXFiles([
                          XFile(card.imagePath!),
                        ], text: card.content);
                      } catch (e) {
                        if (mounted) {
                          ScaffoldMessenger.of(context).showSnackBar(
                            SnackBar(content: Text('Error sharing: $e')),
                          );
                        }
                      }
                    },
                  ),
                IconButton(
                  icon: const Icon(Icons.delete),
                  onPressed: () => _showDeleteConfirmation(card),
                ),
              ],
            ),
            body: FadeTransition(
              opacity: _fadeAnimation,
              child: SingleChildScrollView(
                padding: const EdgeInsets.all(16.0),
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Title section for all card types
                    Row(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: [
                        Expanded(
                          child: Text(
                            card.content,
                            style: const TextStyle(
                              fontSize: 22,
                              fontWeight: FontWeight.bold,
                              color: Colors.white,
                            ),
                          ),
                        ),
                        const SizedBox(
                          width: 8,
                        ), // Add some padding to the right
                        Icon(
                          _getCardTypeIcon(card.type),
                          color: _getCardTypeColor(card.type),
                        ),
                      ],
                    ),

                    const SizedBox(height: 16),

                    // Date information
                    Text(
                      'Created: ${_formatDate(card.createdAt)}',
                      style: TextStyle(fontSize: 12, color: Colors.grey[500]),
                    ),
                    if (card.updatedAt != card.createdAt)
                      Text(
                        'Updated: ${_formatDate(card.updatedAt)}',
                        style: TextStyle(fontSize: 12, color: Colors.grey[500]),
                      ),

                    const SizedBox(height: 16),

                    // Card type specific content
                    if (card.type == 'text' && card.body != null) ...[
                      Container(
                        decoration: BoxDecoration(
                          color: const Color(0xFF1A1A1A),
                          borderRadius: BorderRadius.circular(8),
                        ),
                        padding: const EdgeInsets.all(16),
                        width: double.infinity,
                        child: Text(
                          card.body!,
                          style: const TextStyle(
                            fontSize: 16,
                            color: Colors.white,
                            height: 1.5,
                          ),
                        ),
                      ),
                    ] else if (card.type == 'image' &&
                        card.imagePath != null) ...[
                      AspectRatio(
                        aspectRatio: 16 / 9,
                        child: ClipRRect(
                          borderRadius: BorderRadius.circular(8),
                          child: GestureDetector(
                            onTap: () {
                              Navigator.of(context).push(
                                MaterialPageRoute(
                                  builder: (context) => Scaffold(
                                    backgroundColor: Colors.black,
                                    appBar: AppBar(
                                      backgroundColor: Colors.black,
                                      iconTheme: const IconThemeData(
                                        color: Colors.white,
                                      ),
                                    ),
                                    body: PhotoView(
                                      imageProvider: FileImage(
                                        File(card.imagePath!),
                                      ),
                                      minScale:
                                          PhotoViewComputedScale.contained,
                                      maxScale:
                                          PhotoViewComputedScale.covered * 2,
                                    ),
                                  ),
                                ),
                              );
                            },
                            child: Hero(
                              tag: 'image_${card.id}',
                              child: Image.file(
                                File(card.imagePath!),
                                fit: BoxFit.cover,
                                errorBuilder: (context, error, stackTrace) {
                                  return Container(
                                    color: Colors.grey[800],
                                    child: const Center(
                                      child: Icon(
                                        Icons.broken_image,
                                        color: Colors.white,
                                        size: 64,
                                      ),
                                    ),
                                  );
                                },
                              ),
                            ),
                          ),
                        ),
                      ),
                    ] else if (card.type == 'link' && card.url != null) ...[
                      GestureDetector(
                        onTap: () => _launchUrl(card.url!),
                        child: Container(
                          decoration: BoxDecoration(
                            color: const Color(0xFF1A1A1A),
                            borderRadius: BorderRadius.circular(8),
                            border: Border.all(
                              color: Colors.grey.withOpacity(0.3),
                              width: 1,
                            ),
                          ),
                          padding: const EdgeInsets.all(16),
                          width: double.infinity,
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              Row(
                                children: [
                                  const Icon(
                                    Icons.link,
                                    color: Colors.blue,
                                    size: 20,
                                  ),
                                  const SizedBox(width: 16),
                                  Expanded(
                                    child: Column(
                                      crossAxisAlignment:
                                          CrossAxisAlignment.start,
                                      children: [
                                        Text(
                                          card.url!,
                                          style: const TextStyle(
                                            color: Colors.blue,
                                            fontSize: 14,
                                          ),
                                          maxLines: 1,
                                          overflow: TextOverflow.ellipsis,
                                        ),
                                        const SizedBox(height: 4),
                                        Text(
                                          card.content,
                                          style: const TextStyle(
                                            color: Colors.white,
                                            fontWeight: FontWeight.bold,
                                          ),
                                        ),
                                      ],
                                    ),
                                  ),
                                ],
                              ),
                            ],
                          ),
                        ),
                      ),

                      const SizedBox(height: 16),

                      // YouTube transcript section (if available)
                      if (card.transcript != null &&
                          card.transcript!.isNotEmpty) ...[
                        const SizedBox(height: 24),

                        const Divider(color: Color(0xFF303030)),

                        const Text(
                          'Video Transcript',
                          style: TextStyle(
                            fontSize: 18,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),

                        const SizedBox(height: 8),

                        Container(
                          constraints: const BoxConstraints(maxHeight: 300),
                          decoration: BoxDecoration(
                            color: const Color(0xFF212121),
                            borderRadius: BorderRadius.circular(8),
                          ),
                          padding: const EdgeInsets.all(12),
                          child: SingleChildScrollView(
                            child: SelectableText(
                              card.transcript!,
                              style: const TextStyle(
                                color: Colors.white70,
                                height: 1.5,
                                fontSize: 14,
                              ),
                            ),
                          ),
                        ),
                      ],

                      const SizedBox(height: 16),

                      // Add a more obvious open URL button
                      SizedBox(
                        width: double.infinity,
                        child: ElevatedButton.icon(
                          onPressed: () {
                            final String url = card.url!;
                            print('Opening URL from button: $url');
                            _launchUrl(url);
                          },
                          icon: const Icon(Icons.open_in_browser),
                          label: const Text('Open Link'),
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.blue.shade700,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(vertical: 12),
                            textStyle: const TextStyle(fontSize: 16),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                        ),
                      ),
                    ],
                  ],
                ),
              ),
            ),
          );
        } else {
          // Card not found or error
          return Scaffold(
            backgroundColor: const Color(0xFF121212),
            appBar: AppBar(
              backgroundColor: const Color(0xFF121212),
              elevation: 0,
              leading: IconButton(
                icon: const Icon(Icons.arrow_back),
                onPressed: () => Navigator.of(context).pop(),
              ),
            ),
            body: Center(
              child: Text(
                snapshot.error != null
                    ? 'Error: ${snapshot.error}'
                    : 'Card not found',
                style: const TextStyle(color: Colors.white),
              ),
            ),
          );
        }
      },
    );
  }

  Future<void> _launchUrl(String urlString) async {
    try {
      print('Attempting to launch URL: $urlString');

      // Use the URL utils class for consistent URL handling
      if (mounted) {
        final result = await UrlUtils.launchUrl(
          urlString,
          context: context,
          showError: true,
        );

        print('URL launch result: $result');
      }
    } catch (e) {
      print('Error in _launchUrl: $e');
      // Error handling is done inside UrlUtils.launchUrl
    }
  }

  String _formatDate(int timestamp) {
    final dateTime = DateTime.fromMillisecondsSinceEpoch(timestamp);
    final now = DateTime.now();
    final difference = now.difference(dateTime);

    if (difference.inDays == 0) {
      // Today
      return 'Today at ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (difference.inDays == 1) {
      // Yesterday
      return 'Yesterday at ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else if (difference.inDays < 7) {
      // Within a week
      final weekdays = [
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
        'Sunday',
      ];
      return '${weekdays[dateTime.weekday - 1]} at ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    } else {
      // More than a week
      return '${dateTime.day}/${dateTime.month}/${dateTime.year} at ${dateTime.hour.toString().padLeft(2, '0')}:${dateTime.minute.toString().padLeft(2, '0')}';
    }
  }

  IconData _getCardTypeIcon(String type) {
    switch (type) {
      case 'text':
        return Icons.note;
      case 'image':
        return Icons.image;
      case 'link':
        return Icons.link;
      default:
        return Icons.help_outline;
    }
  }

  Color _getCardTypeColor(String type) {
    switch (type) {
      case 'text':
        return Colors.green;
      case 'image':
        return Colors.purple;
      case 'link':
        return Colors.blue;
      default:
        return Colors.grey;
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\card_detail_screen.dart.bak
=========================================
--- Content Start ---
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:photo_view/photo_view.dart';
import 'package:share_plus/share_plus.dart';
import 'package:video_player/video_player.dart';
import 'package:url_launcher/url_launcher.dart' as url_launcher;

import '../../utils/url_utils.dart';

import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class CardDetailScreen extends StatefulWidget {
  final int cardId;

  const CardDetailScreen({super.key, required this.cardId});

  @override
  State<CardDetailScreen> createState() => _CardDetailScreenState();
}

class _CardDetailScreenState extends State<CardDetailScreen>
    with SingleTickerProviderStateM                    // Add a more obvious open URL button
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () {
                  final String url = card.url!;
                  print('Opening URL from button: $url');
                  _launchUrl(url);
                },
                icon: const Icon(Icons.open_in_browser),
                label: const Text('Open Link'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue.shade700,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  textStyle: const TextStyle(fontSize: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),re<CardEntity?> _cardFuture;
  VideoPlayerController? _videoController;
  final CardRepository _repository = CardRepository();
  late AnimationController _animationController;
  late Animation<double> _fadeAnimation;

  @override
  void initState() {
    super.initState();
    _cardFuture = _loadCard();
    _animationController = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );
    _fadeAnimation = Tween<double>(begin: 0.0, end: 1.0).animate(
      CurvedAnimation(parent: _animationController, curve: Curves.easeIn),
    );
    _animationController.forward();
  }

  Future<CardEntity?> _loadCard() async {
    try {
      final cards = await _repository.getAllCards();
      return cards.firstWhere((card) => card.id == widget.cardId);
    } catch (e) {
      return null;
    }
  }

  @override
  void dispose() {
    _videoController?.dispose();
    _animationController.dispose();
    super.dispose();
  }

  void _initVideoPlayer(String path) {
    if (_videoController != null) {
      _videoController!.dispose();
    }

    if (path.startsWith('http')) {
      _videoController = VideoPlayerController.networkUrl(Uri.parse(path));
    } else {
      _videoController = VideoPlayerController.file(File(path));
    }

    _videoController!.initialize().then((_) {
      if (mounted) setState(() {});
      _videoController!.play();
    });
  }

  void _showDeleteConfirmation(CardEntity card) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        backgroundColor: const Color(0xFF1E1E1E),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        title: const Text(
          'Delete Card',
          style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
          textAlign: TextAlign.center,
        ),
        content: Text(
          'Are you sure you want to delete "${card.content}"?',
          style: const TextStyle(color: Colors.white70),
          textAlign: TextAlign.center,
        ),
        actions: [
          TextButton(
            style: TextButton.styleFrom(
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
            ),
            onPressed: () => Navigator.of(context).pop(),
            child: const Text('CANCEL', style: TextStyle(color: Colors.grey)),
          ),
          TextButton(
            style: TextButton.styleFrom(
              backgroundColor: Colors.red.withOpacity(0.2),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 10),
              shape: RoundedRectangleBorder(
                borderRadius: BorderRadius.circular(8),
              ),
            ),
            onPressed: () async {
              if (card.id != null) {
                await _repository.deleteCard(card.id!);
                if (mounted) {
                  Navigator.of(context).pop(); // Close dialog
                  Navigator.of(context).pop(true); // Go back with result
                }
              }
            },
            child: const Text(
              'DELETE',
              style: TextStyle(color: Colors.red, fontWeight: FontWeight.bold),
            ),
          ),
        ],
      ),
    );
  }

  Future<void> _shareCard(CardEntity card) async {
    bool success = true;
    try {
      switch (card.type) {
        case 'text':
          await Share.share(card.body ?? card.content);
          break;
        case 'image':
          if (card.imagePath != null) {
            if (card.imagePath!.startsWith('http')) {
              // For network image, share the URL
              await Share.share('Check out this image: ${card.imagePath}');
            } else {
              // For local image, share the file
              await Share.shareXFiles([
                XFile(card.imagePath!),
              ], text: card.content);
            }
          } else {
            success = false;
          }
          break;
        case 'video':
          if (card.imagePath != null) {
            if (card.imagePath!.startsWith('http')) {
              // For network video, share the URL
              await Share.share('Check out this video: ${card.imagePath}');
            } else {
              // For local video, share the file
              await Share.shareXFiles([
                XFile(card.imagePath!),
              ], text: card.content);
            }
          } else {
            success = false;
          }
          break;
        case 'link':
          if (card.url != null) {
            await Share.share('${card.content}: ${card.url}');
          } else {
            success = false;
          }
          break;
      }

      // Show success message
      if (mounted && success) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Card shared successfully'),
            backgroundColor: Colors.green,
            behavior: SnackBarBehavior.floating,
            duration: Duration(seconds: 2),
          ),
        );
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: const Text('Failed to share card'),
            backgroundColor: Colors.red.shade700,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  String _getFormattedDate(DateTime date) {
    return '${date.day} ${_getMonthName(date.month)} ${date.year}, ${date.hour.toString().padLeft(2, '0')}:${date.minute.toString().padLeft(2, '0')}';
  }

  String _getMonthName(int month) {
    const months = [
      'Jan',
      'Feb',
      'Mar',
      'Apr',
      'May',
      'Jun',
      'Jul',
      'Aug',
      'Sep',
      'Oct',
      'Nov',
      'Dec',
    ];
    return months[month - 1];
  }

  String _getCardTypeTitle(String type) {
    switch (type) {
      case 'text':
        return 'Text Card';
      case 'image':
        return 'Image Card';
      case 'video':
        return 'Video Card';
      case 'link':
        return 'Link Card';
      default:
        return 'Card';
    }
  }

  @override
  Widget build(BuildContext context) {
    // Check if we're on a tablet
    final isTablet = MediaQuery.of(context).size.width > 600;

    return FadeTransition(
      opacity: _fadeAnimation,
      child: FutureBuilder<CardEntity?>(
        future: _cardFuture,
        builder: (context, snapshot) {
          if (snapshot.connectionState == ConnectionState.waiting) {
            return Scaffold(
              appBar: AppBar(
                backgroundColor: const Color(0xFF1E1E1E),
                elevation: 0,
              ),
              backgroundColor: const Color(0xFF121212),
              body: const Center(
                child: CircularProgressIndicator(
                  valueColor: AlwaysStoppedAnimation<Color>(
                    Colors.orangeAccent,
                  ),
                ),
              ),
            );
          }

          if (snapshot.hasError || !snapshot.hasData || snapshot.data == null) {
            return Scaffold(
              appBar: AppBar(
                title: const Text('Error'),
                backgroundColor: const Color(0xFF1E1E1E),
                elevation: 0,
              ),
              backgroundColor: const Color(0xFF121212),
              body: Center(
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    Icon(
                      Icons.error_outline,
                      size: 64,
                      color: Colors.grey[700],
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Card not found',
                      style: TextStyle(
                        fontSize: isTablet ? 22 : 18,
                        color: Colors.grey[400],
                      ),
                    ),
                    const SizedBox(height: 24),
                    ElevatedButton(
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.orangeAccent,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(
                          horizontal: 24,
                          vertical: 12,
                        ),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                      onPressed: () => Navigator.of(context).pop(),
                      child: const Text('Go Back'),
                    ),
                  ],
                ),
              ),
            );
          }

          final card = snapshot.data!;
          final createdDate = DateTime.fromMillisecondsSinceEpoch(
            card.createdAt,
          );
          final formattedDate = _getFormattedDate(createdDate);

          // Initialize video player if it's a video card
          if (card.type == 'video' &&
              card.imagePath != null &&
              _videoController == null) {
            _initVideoPlayer(card.imagePath!);
          }

          return Scaffold(
            appBar: AppBar(
              backgroundColor: const Color(0xFF1E1E1E),
              elevation: 0,
              centerTitle: true,
              title: Text(
                _getCardTypeTitle(card.type),
                style: TextStyle(
                  fontSize: isTablet ? 20 : 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
              actions: [
                IconButton(
                  icon: const Icon(Icons.share, color: Colors.white),
                  tooltip: 'Share card',
                  onPressed: () => _shareCard(card),
                ),
                IconButton(
                  icon: const Icon(Icons.delete, color: Colors.red),
                  tooltip: 'Delete card',
                  onPressed: () => _showDeleteConfirmation(card),
                ),
                const SizedBox(width: 8), // Add some padding to the right
              ],
            ),
            backgroundColor: const Color(0xFF121212),
            body: Hero(
              tag: 'card-${card.id ?? card.createdAt}',
              child: SafeArea(
                child: Column(
                  children: [
                    Expanded(child: _buildCardDetailContent(card, isTablet)),
                    _buildFooter(formattedDate),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildFooter(String formattedDate) {
    return Container(
      padding: const EdgeInsets.symmetric(vertical: 12, horizontal: 16),
      decoration: BoxDecoration(
        color: const Color(0xFF1A1A1A),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, -1),
          ),
        ],
      ),
      child: Row(
        children: [
          const Icon(Icons.access_time, size: 16, color: Colors.grey),
          const SizedBox(width: 8),
          Text(
            'Created on $formattedDate',
            style: const TextStyle(fontSize: 12, color: Colors.grey),
          ),
        ],
      ),
    );
  }

  Widget _buildCardDetailContent(CardEntity card, bool isTablet) {
    switch (card.type) {
      case 'text':
        return _buildTextDetail(card, isTablet);
      case 'image':
        return _buildImageDetail(card, isTablet);
      case 'video':
        return _buildVideoDetail(card, isTablet);
      case 'link':
        return _buildLinkDetail(card, isTablet);
      default:
        return _buildTextDetail(card, isTablet);
    }
  }

  Widget _buildTextDetail(CardEntity card, bool isTablet) {
    final double titleSize = isTablet ? 28 : 24;
    final double bodySize = isTablet ? 20 : 18;

    return SingleChildScrollView(
      physics: const BouncingScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            card.content,
            style: TextStyle(
              fontSize: titleSize,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 16),
          Container(
            height: 1,
            color: Colors.grey.withOpacity(0.2),
            margin: const EdgeInsets.symmetric(vertical: 16),
          ),
          if (card.body != null)
            SelectableText(
              card.body!,
              style: TextStyle(
                fontSize: bodySize,
                height: 1.4,
                color: Colors.white,
              ),
            ),
        ],
      ),
    );
  }

  Widget _buildImageDetail(CardEntity card, bool isTablet) {
    if (card.imagePath == null) {
      return const Center(child: Text('No image available'));
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 24 : 20,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        ),
        Expanded(
          child: Container(
            margin: const EdgeInsets.symmetric(horizontal: 16),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              boxShadow: [
                BoxShadow(
                  color: Colors.black.withOpacity(0.4),
                  blurRadius: 8,
                  offset: const Offset(0, 4),
                ),
              ],
            ),
            child: ClipRRect(
              borderRadius: BorderRadius.circular(12),
              child: card.imagePath!.startsWith('http')
                  ? PhotoView(
                      imageProvider: NetworkImage(card.imagePath!),
                      minScale: PhotoViewComputedScale.contained,
                      maxScale: PhotoViewComputedScale.covered * 2,
                      backgroundDecoration: const BoxDecoration(
                        color: Colors.black,
                      ),
                    )
                  : PhotoView(
                      imageProvider: FileImage(File(card.imagePath!)),
                      minScale: PhotoViewComputedScale.contained,
                      maxScale: PhotoViewComputedScale.covered * 2,
                      backgroundDecoration: const BoxDecoration(
                        color: Colors.black,
                      ),
                    ),
            ),
          ),
        ),
        if (card.body != null && card.body!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 16 : 14,
                color: Colors.white70,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildVideoDetail(CardEntity card, bool isTablet) {
    if (card.imagePath == null || _videoController == null) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.orangeAccent),
        ),
      );
    }

    if (!_videoController!.value.isInitialized) {
      return const Center(
        child: CircularProgressIndicator(
          valueColor: AlwaysStoppedAnimation<Color>(Colors.orangeAccent),
        ),
      );
    }

    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Padding(
          padding: const EdgeInsets.all(16.0),
          child: Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 24 : 20,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
        ),
        Expanded(
          child: Center(
            child: Container(
              margin: const EdgeInsets.symmetric(horizontal: 16),
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.4),
                    blurRadius: 8,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: AspectRatio(
                  aspectRatio: _videoController!.value.aspectRatio,
                  child: Stack(
                    alignment: Alignment.bottomCenter,
                    children: [
                      VideoPlayer(_videoController!),
                      _ControlsOverlay(controller: _videoController!),
                      VideoProgressIndicator(
                        _videoController!,
                        allowScrubbing: true,
                        colors: const VideoProgressColors(
                          playedColor: Colors.orangeAccent,
                          bufferedColor: Colors.white24,
                          backgroundColor: Colors.white10,
                        ),
                        padding: const EdgeInsets.all(16.0),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ),
        if (card.body != null && card.body!.isNotEmpty)
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 16 : 14,
                color: Colors.white70,
              ),
            ),
          ),
      ],
    );
  }

  Widget _buildLinkDetail(CardEntity card, bool isTablet) {
    return SingleChildScrollView(
      physics: const BouncingScrollPhysics(),
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            card.content,
            style: TextStyle(
              fontSize: isTablet ? 28 : 24,
              fontWeight: FontWeight.bold,
              color: Colors.white,
            ),
          ),
          const SizedBox(height: 20),
          if (card.url != null) ...[
            GestureDetector(
              onTap: () => _launchUrl(card.url!),
              child: Container(
                padding: const EdgeInsets.all(16),
                decoration: BoxDecoration(
                  color: const Color(0xFF2A2A2A),
                  borderRadius: BorderRadius.circular(12),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 8,
                      offset: const Offset(0, 2),
                    ),
                  ],
                ),
                child: Row(
                  children: [
                    Container(
                      padding: const EdgeInsets.all(10),
                      decoration: BoxDecoration(
                        color: Colors.purpleAccent.withOpacity(0.2),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(Icons.link, color: Colors.purpleAccent),
                    ),
                    const SizedBox(width: 16),
                    Expanded(
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        children: [
                          const Text(
                            'URL',
                            style: TextStyle(color: Colors.grey, fontSize: 12),
                          ),
                          const SizedBox(height: 4),
                          Text(
                            card.url!,
                            style: const TextStyle(
                              color: Colors.blueAccent,
                              decoration: TextDecoration.underline,
                              fontSize: 16,
                            ),
                          ),
                        ],
                      ),
                    ),
                    GestureDetector(
                      onTap: () => _launchUrl(card.url!),
                      child: Container(
                        padding: const EdgeInsets.all(8),
                        decoration: BoxDecoration(
                          color: Colors.blueAccent.withOpacity(0.2),
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.open_in_new,
                          color: Colors.blueAccent,
                          size: 20,
                        ),
                      ),
                    ),
                    // Add an explicit Open button
                    IconButton(
                      onPressed: () => _launchUrl(card.url!),
                      icon: const Icon(Icons.open_in_browser),
                      tooltip: 'Open URL',
                      color: Colors.blueAccent,
                    ),
                  ],
                ),
              ),
            ),
            // Add a more obvious open URL button
            const SizedBox(height: 16),
            SizedBox(
              width: double.infinity,
              child: ElevatedButton.icon(
                onPressed: () {
                  final String url = card.url!;
                  print('Opening URL from button: $url');
                  _launchUrl(url);
                },
                icon: const Icon(Icons.open_in_browser),
                label: const Text('Open Link'),
                style: ElevatedButton.styleFrom(
                  backgroundColor: Colors.blue.shade700,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(vertical: 12),
                  textStyle: const TextStyle(fontSize: 16),
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
            const SizedBox(height: 24),
          ],
          if (card.imagePath != null) ...[
            Container(
              decoration: BoxDecoration(
                borderRadius: BorderRadius.circular(12),
                boxShadow: [
                  BoxShadow(
                    color: Colors.black.withOpacity(0.3),
                    blurRadius: 10,
                    offset: const Offset(0, 4),
                  ),
                ],
              ),
              child: ClipRRect(
                borderRadius: BorderRadius.circular(12),
                child: card.imagePath!.startsWith('http')
                    ? Image.network(
                        card.imagePath!,
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) =>
                            _buildErrorImage(),
                      )
                    : Image.file(
                        File(card.imagePath!),
                        fit: BoxFit.cover,
                        errorBuilder: (context, error, stackTrace) =>
                            _buildErrorImage(),
                      ),
              ),
            ),
            const SizedBox(height: 24),
          ],
          if (card.body != null && card.body!.isNotEmpty) ...[
            const Divider(color: Colors.grey, height: 32),
            Text(
              card.body!,
              style: TextStyle(
                fontSize: isTablet ? 18 : 16,
                color: Colors.white,
                height: 1.5,
              ),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildErrorImage() {
    return Container(
      height: 200,
      decoration: BoxDecoration(
        color: const Color(0xFF2A2A2A),
        borderRadius: BorderRadius.circular(12),
      ),
      child: Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Icon(Icons.broken_image, color: Colors.grey[400], size: 48),
            const SizedBox(height: 12),
            Text(
              'Image not available',
              style: TextStyle(color: Colors.grey[400]),
            ),
          ],
        ),
      ),
    );
  }

  Future<void> _launchUrl(String urlString) async {
    try {
      print('Attempting to launch URL: $urlString');
      if (urlString.isEmpty) {
        throw Exception('URL is empty');
      }

      // Enhanced URL normalization
      String normalizedUrl = urlString.trim();

      try {
        // Handle common URL schemes
        if (normalizedUrl.startsWith('www.')) {
          normalizedUrl = 'https://$normalizedUrl';
          print('Added https:// to www. URL: $normalizedUrl');
        } else if (!normalizedUrl.contains('://')) {
          // Check if it might be an email
          if (RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$').hasMatch(normalizedUrl)) {
            normalizedUrl = 'mailto:$normalizedUrl';
            print('Converting to mailto scheme: $normalizedUrl');
          }
          // Check if it might be a phone number
          else if (RegExp(r'^\+?[\d\s\-()]{5,}$').hasMatch(normalizedUrl)) {
            normalizedUrl =
                'tel:${normalizedUrl.replaceAll(RegExp(r'[\s\-()]'), '')}';
            print('Converting to tel scheme: $normalizedUrl');
          }
          // Default to https for web URLs
          else {
            normalizedUrl = 'https://$normalizedUrl';
            print('Defaulting to https scheme: $normalizedUrl');
          }
        }

        final Uri url = Uri.parse(normalizedUrl);
        print('Parsed URI: $url');

        // Force launch with external application
        print('Launching URL with external application');
        final bool result = await url_launcher.launchUrl(
          url,
          mode: url_launcher.LaunchMode.externalApplication,
        );

        if (!result) {
          throw Exception('Could not launch URL: $normalizedUrl');
        }
        print('URL launch successful');
        return;
      } catch (e) {
        print('Error during URL parsing/launching: $e');
        
        // Try a more permissive approach
        try {
          // Just try to launch with the original URL as a fallback
          final fallbackUrl = Uri.parse('https://${urlString.trim()}');
          final result = await url_launcher.launchUrl(
            fallbackUrl,
            mode: url_launcher.LaunchMode.externalApplication,
          );
          
          if (result) {
            print('Fallback URL launch successful');
            return;
          }
        } catch (fallbackError) {
          print('Fallback launch also failed: $fallbackError');
        }
        
        throw Exception('Failed to open link');
      }
    } catch (e) {
      print('Error launching URL: $e');
      // Show error
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Could not open URL: ${e.toString()}'),
            backgroundColor: Colors.red.shade700,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }
}

class _ControlsOverlay extends StatefulWidget {
  const _ControlsOverlay({required this.controller});

  final VideoPlayerController controller;

  @override
  State<_ControlsOverlay> createState() => _ControlsOverlayState();
}

class _ControlsOverlayState extends State<_ControlsOverlay> {
  bool _hideControls = false;

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: () {
        setState(() {
          _hideControls = !_hideControls;
        });
      },
      child: AnimatedOpacity(
        opacity: _hideControls ? 0.0 : 1.0,
        duration: const Duration(milliseconds: 300),
        child: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                Colors.black.withOpacity(0.0),
                Colors.black.withOpacity(0.5),
              ],
            ),
          ),
          child: Center(
            child: IconButton(
              onPressed: () {
                setState(() {
                  widget.controller.value.isPlaying
                      ? widget.controller.pause()
                      : widget.controller.play();
                });
              },
              icon: Container(
                padding: const EdgeInsets.all(12),
                decoration: BoxDecoration(
                  color: Colors.black38,
                  shape: BoxShape.circle,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.5),
                      blurRadius: 8,
                      spreadRadius: 2,
                    ),
                  ],
                ),
                child: Icon(
                  widget.controller.value.isPlaying
                      ? Icons.pause
                      : Icons.play_arrow,
                  size: 32.0,
                  color: Colors.white,
                ),
              ),
            ),
          ),
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\home_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:async';
import '../theme/app_theme.dart';
import '../../bloc/main_grid/main_grid_bloc.dart';
import '../../bloc/main_grid/main_grid_event.dart';
import '../../data/repository/card_repository.dart';
import '../../data/repository/space_repository.dart';
import '../widgets/grid/main_grid_view.dart';
import '../widgets/tabs/spaces_tab.dart';
import '../widgets/card/add_text_card_modal.dart';
import '../widgets/card/add_image_card_modal.dart';
import '../widgets/card/add_link_card_modal.dart';
import 'package:image_picker/image_picker.dart';
import 'dart:io';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  late final MainGridBloc _mainGridBloc;
  final TextEditingController _searchController = TextEditingController();
  int _selectedIndex = 0;
  Timer? _searchDebounceTimer;

  // Define the navigation items
  final List<_NavItem> _navItems = const [
    _NavItem(label: 'Everything', icon: Icons.grid_view_rounded),
    _NavItem(label: 'Spaces', icon: Icons.folder_rounded),
    _NavItem(label: 'Serendipity', icon: Icons.auto_awesome),
  ];

  @override
  void initState() {
    super.initState();
    // Initialize BLoC with repository
    _mainGridBloc = MainGridBloc(cardRepository: CardRepository());

    // Setup search controller listener
    _searchController.addListener(_onSearchChanged);
  }

  @override
  void dispose() {
    _searchDebounceTimer?.cancel();
    _searchController.removeListener(_onSearchChanged);
    _searchController.dispose();
    _mainGridBloc.close(); // Clean up the BLoC when screen is disposed
    super.dispose();
  }

  void _onSearchChanged() {
    // Cancel previous debounce timer
    _searchDebounceTimer?.cancel();

    final query = _searchController.text;

    // Debounce search for 300ms to avoid excessive DB queries
    _searchDebounceTimer = Timer(const Duration(milliseconds: 300), () {
      _mainGridBloc.add(SearchQueryChanged(query));
    });
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (context) => _mainGridBloc,
      child: Scaffold(
        backgroundColor:
            AppTheme.scaffoldBackgroundColor, // Material 3 dark theme
        appBar: _buildAppBar(),
        body: _buildBody(),
        bottomNavigationBar: _buildBottomNavBar(),
        floatingActionButton: AnimatedScale(
          scale: _searchController.text.isEmpty ? 1.0 : 0.0,
          duration: const Duration(milliseconds: 300),
          curve: Curves.easeInOut,
          child: FloatingActionButton.extended(
            onPressed: () {
              // Add haptic feedback
              HapticFeedback.mediumImpact();
              _addNewCard(context);
            },
            backgroundColor: AppTheme.primaryColor,
            elevation: 6,
            shape: RoundedRectangleBorder(
              borderRadius: BorderRadius.circular(16),
            ),
            icon: AnimatedSwitcher(
              duration: const Duration(milliseconds: 300),
              child: const Icon(
                Icons.add,
                key: ValueKey('add-icon'),
                color: Colors.white,
              ),
            ),
            label: const Text('Create'),
          ),
        ),
      ),
    );
  }

  Widget _buildBody() {
    // Switch between different tabs based on _selectedIndex
    switch (_selectedIndex) {
      case 0: // Everything (Main Grid)
        return const MainGridView();
      case 1: // Spaces
        return const SpacesTab();
      case 2: // Serendipity
        return const Center(
          child: Text(
            'Serendipity feature coming soon!',
            style: TextStyle(color: Colors.white70),
          ),
        );
      default:
        return const MainGridView();
    }
  }

  PreferredSizeWidget _buildAppBar() {
    return AppBar(
      backgroundColor: AppTheme.surfaceVariantColor,
      elevation: 0,
      automaticallyImplyLeading:
          false, // This prevents the back button from appearing
      title: const Text(
        'Retainly',
        style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
      ),
      actions: [],
      bottom: PreferredSize(
        preferredSize: const Size.fromHeight(65),
        child: Padding(
          padding: const EdgeInsets.fromLTRB(16, 0, 16, 12),
          child: _buildSearchBar(),
        ),
      ),
    );
  }

  Widget _buildSearchBar() {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.surfaceColor.withOpacity(0.7),
        borderRadius: BorderRadius.circular(12),
        boxShadow: [
          BoxShadow(
            color: Colors.black12.withOpacity(0.05),
            blurRadius: 8,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: TextField(
        controller: _searchController,
        style: const TextStyle(color: Colors.white),
        textInputAction: TextInputAction.search,
        decoration: InputDecoration(
          hintText: 'Search cards...',
          hintStyle: TextStyle(color: Colors.grey[400]),
          prefixIcon: const Icon(Icons.search, color: AppTheme.primaryColor),
          suffixIcon: _searchController.text.isNotEmpty
              ? IconButton(
                  icon: Container(
                    decoration: BoxDecoration(
                      color: Colors.grey.withOpacity(0.3),
                      shape: BoxShape.circle,
                    ),
                    padding: const EdgeInsets.all(2),
                    child: const Icon(
                      Icons.close,
                      color: Colors.white70,
                      size: 14,
                    ),
                  ),
                  onPressed: () {
                    _searchController.clear();
                    _mainGridBloc.add(const ClearSearch());
                    FocusScope.of(context).unfocus();
                  },
                )
              : null,
          filled: true,
          fillColor: Colors.transparent,
          border: OutlineInputBorder(
            borderRadius: BorderRadius.circular(12),
            borderSide: BorderSide.none,
          ),
          contentPadding: const EdgeInsets.symmetric(vertical: 12.0),
        ),
        onSubmitted: (value) {
          if (value.isNotEmpty) {
            FocusScope.of(context).unfocus();
          }
        },
      ),
    );
  }

  Widget _buildBottomNavBar() {
    return Container(
      decoration: BoxDecoration(
        color: AppTheme.surfaceVariantColor,
        boxShadow: const [
          BoxShadow(
            color: Colors.black26,
            blurRadius: 8,
            offset: Offset(0, -2),
          ),
        ],
      ),
      child: SafeArea(
        child: Padding(
          padding: const EdgeInsets.symmetric(vertical: 8.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: List.generate(_navItems.length, (index) {
              final isSelected = index == _selectedIndex;

              return InkWell(
                onTap: () {
                  HapticFeedback.lightImpact();
                  setState(() => _selectedIndex = index);
                },
                borderRadius: BorderRadius.circular(12),
                child: AnimatedContainer(
                  duration: const Duration(milliseconds: 200),
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 8,
                  ),
                  decoration: BoxDecoration(
                    color: isSelected
                        ? AppTheme.primaryColor.withOpacity(0.2)
                        : Colors.transparent,
                    borderRadius: BorderRadius.circular(12),
                  ),
                  child: Column(
                    mainAxisSize: MainAxisSize.min,
                    children: [
                      Icon(
                        _navItems[index].icon,
                        color: isSelected ? AppTheme.primaryColor : Colors.grey,
                      ),
                      const SizedBox(height: 4),
                      Text(
                        _navItems[index].label,
                        style: TextStyle(
                          color: isSelected
                              ? AppTheme.primaryColor
                              : Colors.grey,
                          fontSize: 12,
                          fontWeight: isSelected
                              ? FontWeight.w600
                              : FontWeight.normal,
                        ),
                      ),
                    ],
                  ),
                ),
              );
            }),
          ),
        ),
      ),
    );
  }

  Future<void> _addNewCard(BuildContext context) async {
    final action = await showModalBottomSheet<_FabAction>(
      context: context,
      backgroundColor: const Color(0xFF1A1A1A),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (_) => _FabOptionsSheet(),
    );

    if (action == _FabAction.text) {
      final result = await showModalBottomSheet<bool>(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) => const AddTextCardModal(),
      );
      if (result == true) {
        _mainGridBloc.add(const LoadCards(refresh: true));
      }
    } else if (action == _FabAction.image) {
      // Ask for image source
      final source = await showModalBottomSheet<ImageSource>(
        context: context,
        backgroundColor: const Color(0xFF1A1A1A),
        shape: const RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
        ),
        builder: (_) => _ImageSourceSheet(),
      );
      if (source != null) {
        final picker = ImagePicker();
        final picked = await picker.pickImage(source: source, imageQuality: 95);
        if (picked != null) {
          final file = File(picked.path);
          final result = await showModalBottomSheet<bool>(
            context: context,
            isScrollControlled: true,
            backgroundColor: Colors.transparent,
            builder: (_) => AddImageCardModal(imageFile: file),
          );
          if (result == true) {
            _mainGridBloc.add(const LoadCards(refresh: true));
          }
        }
      }
    } else if (action == _FabAction.link) {
      final result = await showModalBottomSheet<bool>(
        context: context,
        isScrollControlled: true,
        backgroundColor: Colors.transparent,
        builder: (context) => const AddLinkCardModal(),
      );
      if (result == true) {
        _mainGridBloc.add(const LoadCards(refresh: true));
      }
    }
  }
}

enum _FabAction { text, image, link }

class _FabOptionsSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              border: Border(
                bottom: BorderSide(
                  color: AppTheme.dividerColor.withOpacity(0.5),
                  width: 1,
                ),
              ),
            ),
            child: const Center(
              child: Text(
                'Create New Card',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),

          // Card options
          _buildOptionItem(
            context,
            icon: Icons.text_snippet,
            title: 'Text Card',
            subtitle: 'Create a card with formatted text',
            action: _FabAction.text,
            color: Colors.blue,
          ),
          _buildOptionItem(
            context,
            icon: Icons.image,
            title: 'Image Card',
            subtitle: 'Upload an image with optional caption',
            action: _FabAction.image,
            color: Colors.green,
          ),
          _buildOptionItem(
            context,
            icon: Icons.link,
            title: 'Link Card',
            subtitle: 'Save a link with preview',
            action: _FabAction.link,
            color: Colors.purple,
          ),

          // Bottom padding
          const SizedBox(height: 8),
        ],
      ),
    );
  }

  Widget _buildOptionItem(
    BuildContext context, {
    required IconData icon,
    required String title,
    required String subtitle,
    required _FabAction action,
    required Color color,
  }) {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
      child: Material(
        color: Colors.transparent,
        child: InkWell(
          onTap: () {
            HapticFeedback.mediumImpact();
            Navigator.of(context).pop(action);
          },
          borderRadius: BorderRadius.circular(12),
          child: Ink(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
            decoration: BoxDecoration(
              borderRadius: BorderRadius.circular(12),
              color: AppTheme.surfaceVariantColor,
            ),
            child: Row(
              children: [
                Container(
                  padding: const EdgeInsets.all(12),
                  decoration: BoxDecoration(
                    color: color.withOpacity(0.2),
                    shape: BoxShape.circle,
                  ),
                  child: Icon(icon, color: color, size: 24),
                ),
                const SizedBox(width: 16),
                Expanded(
                  child: Column(
                    crossAxisAlignment: CrossAxisAlignment.start,
                    children: [
                      Text(
                        title,
                        style: const TextStyle(
                          color: Colors.white,
                          fontSize: 16,
                          fontWeight: FontWeight.w500,
                        ),
                      ),
                      const SizedBox(height: 4),
                      Text(
                        subtitle,
                        style: TextStyle(color: Colors.grey[400], fontSize: 12),
                      ),
                    ],
                  ),
                ),
                const Icon(
                  Icons.arrow_forward_ios,
                  color: Colors.grey,
                  size: 16,
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }
}

class _ImageSourceSheet extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with title
          Container(
            width: double.infinity,
            padding: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              color: AppTheme.surfaceColor,
              border: Border(
                bottom: BorderSide(
                  color: AppTheme.dividerColor.withOpacity(0.5),
                  width: 1,
                ),
              ),
            ),
            child: const Center(
              child: Text(
                'Select Image Source',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),

          // Source options with grid layout
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildSourceOption(
                  context,
                  icon: Icons.photo_library,
                  label: 'Gallery',
                  source: ImageSource.gallery,
                  color: Colors.blue,
                ),
                _buildSourceOption(
                  context,
                  icon: Icons.photo_camera,
                  label: 'Camera',
                  source: ImageSource.camera,
                  color: Colors.green,
                ),
              ],
            ),
          ),

          // Bottom padding
          const SizedBox(height: 16),
        ],
      ),
    );
  }

  Widget _buildSourceOption(
    BuildContext context, {
    required IconData icon,
    required String label,
    required ImageSource source,
    required Color color,
  }) {
    return InkWell(
      onTap: () {
        HapticFeedback.mediumImpact();
        Navigator.of(context).pop(source);
      },
      borderRadius: BorderRadius.circular(16),
      child: Container(
        width: 120,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: AppTheme.surfaceVariantColor,
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color.withOpacity(0.3), width: 1),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: color.withOpacity(0.2),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: color, size: 32),
            ),
            const SizedBox(height: 12),
            Text(
              label,
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

// Helper class for navigation items
class _NavItem {
  final String label;
  final IconData icon;

  const _NavItem({required this.label, required this.icon});
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\landing_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';

class LandingScreen extends StatelessWidget {
  const LandingScreen({super.key});

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: SafeArea(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.stretch,
            children: [
              const Spacer(),
              const Image(
                image: AssetImage('assets/images/brain_logo.png'),
                width: 216,
                height: 216,
              ),
              const SizedBox(height: 24),
              Text(
                'Retainly',
                style: Theme.of(context).textTheme.headlineLarge?.copyWith(
                  fontWeight: FontWeight.bold,
                ),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 12),
              Text(
                'An extension of your mind',
                style: Theme.of(context).textTheme.bodyLarge,
                textAlign: TextAlign.center,
              ),
              const Spacer(),
              SizedBox(
                height: 48,
                child: FilledButton(
                  onPressed: () =>
                      Navigator.of(context).pushReplacementNamed('/home'),
                  child: const Text('Open Memories'),
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\space_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../blocs/spaces/space_cards_bloc.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';
import '../../data/space_entity.dart';
import '../widgets/card_grid.dart';
import '../widgets/card/add_text_card_to_space_modal.dart';
import '../widgets/card/add_link_card_to_space_modal.dart';

class SpaceScreen extends StatefulWidget {
  final SpaceEntity space;

  const SpaceScreen({super.key, required this.space});

  @override
  State<SpaceScreen> createState() => _SpaceScreenState();
}

class _SpaceScreenState extends State<SpaceScreen> {
  late SpaceCardsBloc _spaceCardsBloc;
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _spaceCardsBloc = SpaceCardsBloc(
      cardRepository: context.read<CardRepository>(),
    );
    _spaceCardsBloc.add(LoadSpaceCards(widget.space.id!));

    // Set up scroll listener for pagination
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    _spaceCardsBloc.close();
    super.dispose();
  }

  void _onScroll() {
    // Load more when reaching the bottom
    if (_scrollController.position.pixels >=
        _scrollController.position.maxScrollExtent * 0.8) {
      final state = _spaceCardsBloc.state;
      if (state is SpaceCardsLoaded && state.hasMore) {
        _spaceCardsBloc.add(
          LoadSpaceCards(widget.space.id!, offset: state.offset),
        );
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _spaceCardsBloc,
      child: Scaffold(
        appBar: AppBar(
          title: Text(widget.space.name),
          actions: [
            IconButton(
              icon: const Icon(Icons.add),
              onPressed: () => _showAddCardOptions(context),
              tooltip: 'Add Card',
            ),
          ],
        ),
        body: BlocBuilder<SpaceCardsBloc, SpaceCardsState>(
          builder: (context, state) {
            if (state is SpaceCardsLoading) {
              return const Center(child: CircularProgressIndicator());
            } else if (state is SpaceCardsLoaded) {
              return state.cards.isEmpty
                  ? _buildEmptyState()
                  : _buildCardsList(state.cards);
            } else if (state is SpaceCardsError) {
              return Center(child: Text('Error: ${state.message}'));
            } else {
              return const SizedBox.shrink();
            }
          },
        ),
      ),
    );
  }

  Widget _buildEmptyState() {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.note_alt_outlined, size: 64, color: Colors.grey),
          const SizedBox(height: 16),
          const Text(
            'No cards in this space',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text(
            'Add cards to this space by creating new ones\nor moving them from the global view',
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.grey),
          ),
          const SizedBox(height: 16),
          ElevatedButton.icon(
            icon: const Icon(Icons.add),
            label: const Text('Add Card'),
            onPressed: () => _showAddCardOptions(context),
          ),
        ],
      ),
    );
  }

  Widget _buildCardsList(List<CardEntity> cards) {
    return RefreshIndicator(
      onRefresh: () async {
        _spaceCardsBloc.add(LoadSpaceCards(widget.space.id!));
      },
      child: CardGrid(
        cards: cards,
        scrollController: _scrollController,
        onCardSelected: (card) {
          // Navigate to card detail/edit screen
          if (card.id != null) {
            Navigator.pushNamed(
              context,
              '/cardDetail',
              arguments: card.id,
            ).then((_) {
              // Refresh cards when returning from detail screen
              _spaceCardsBloc.add(LoadSpaceCards(widget.space.id!));
            });
          }
        },
        onCardLongPress: (card) {
          // Show move card options
          _showCardOptions(context, card);
        },
      ),
    );
  }

  void _showAddCardOptions(BuildContext context) {
    showModalBottomSheet(
      context: context,
      backgroundColor: const Color(0xFF1A1A1A),
      shape: const RoundedRectangleBorder(
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'Add to Space',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                    color: Colors.white,
                  ),
                ),
              ),
              // Text card option
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Color(0xFF303030),
                  child: Icon(Icons.text_fields, color: Colors.white),
                ),
                title: const Text(
                  'Text Note',
                  style: TextStyle(color: Colors.white),
                ),
                subtitle: const Text(
                  'Create a text note',
                  style: TextStyle(color: Colors.grey),
                ),
                onTap: () async {
                  Navigator.pop(context);
                  final result = await showModalBottomSheet<bool>(
                    context: context,
                    isScrollControlled: true,
                    backgroundColor: Colors.transparent,
                    builder: (context) =>
                        // Use MultiBlocProvider to provide repositories and blocs
                        RepositoryProvider<CardRepository>.value(
                          value: context.read<CardRepository>(),
                          child: AddTextCardToSpaceModal(
                            spaceId: widget.space.id!,
                          ),
                        ),
                  );
                  if (result == true) {
                    // Refresh cards in this space
                    _spaceCardsBloc.add(LoadSpaceCards(widget.space.id!));
                  }
                },
              ),
              // Link card option
              ListTile(
                leading: const CircleAvatar(
                  backgroundColor: Color(0xFF303030),
                  child: Icon(Icons.link, color: Colors.white),
                ),
                title: const Text(
                  'Link',
                  style: TextStyle(color: Colors.white),
                ),
                subtitle: const Text(
                  'Add a link card',
                  style: TextStyle(color: Colors.grey),
                ),
                onTap: () async {
                  Navigator.pop(context);
                  final result = await showModalBottomSheet<bool>(
                    context: context,
                    isScrollControlled: true,
                    backgroundColor: Colors.transparent,
                    builder: (context) =>
                        RepositoryProvider<CardRepository>.value(
                          value: context.read<CardRepository>(),
                          child: AddLinkCardToSpaceModal(
                            spaceId: widget.space.id!,
                          ),
                        ),
                  );
                  if (result == true) {
                    _spaceCardsBloc.add(LoadSpaceCards(widget.space.id!));
                  }
                },
              ),
              const SizedBox(height: 16),
            ],
          ),
        );
      },
    );
  }

  void _showCardOptions(BuildContext context, CardEntity card) {
    showModalBottomSheet(
      context: context,
      builder: (context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              ListTile(
                leading: const Icon(Icons.remove_circle_outline),
                title: const Text('Remove from Space'),
                subtitle: const Text('Move to global view'),
                onTap: () {
                  Navigator.pop(context);
                  _spaceCardsBloc.add(MoveCardToSpace(card.id!, null));
                },
              ),
              ListTile(
                leading: const Icon(Icons.delete),
                title: const Text('Delete Card'),
                subtitle: const Text('Remove completely'),
                onTap: () {
                  Navigator.pop(context);
                  // Implement delete card functionality
                  // This should use the card repository's delete method
                },
              ),
            ],
          ),
        );
      },
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\screens\splash_screen.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'landing_screen.dart';

class SplashScreen extends StatefulWidget {
  const SplashScreen({super.key});

  @override
  State<SplashScreen> createState() => _SplashScreenState();
}

class _SplashScreenState extends State<SplashScreen>
    with SingleTickerProviderStateMixin {
  late final AnimationController _controller;
  late final Animation<double> _fade;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      vsync: this,
      duration: const Duration(milliseconds: 800),
    );
    _fade = CurvedAnimation(parent: _controller, curve: Curves.easeIn);
    _controller.forward();

    Future.delayed(const Duration(seconds: 2), () {
      if (!mounted) return;
      Navigator.of(context).pushReplacement(
        PageRouteBuilder(
          settings: const RouteSettings(name: '/landing'),
          pageBuilder: (context, animation, secondaryAnimation) =>
              const LandingScreen(),
          transitionsBuilder: (context, animation, secondaryAnimation, child) {
            return FadeTransition(opacity: animation, child: child);
          },
          transitionDuration: const Duration(milliseconds: 400),
        ),
      );
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      body: Center(
        child: FadeTransition(
          opacity: _fade,
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: const [
              Image(
                image: AssetImage('assets/images/brain_logo.png'),
                width: 180,
                height: 180,
              ),
              SizedBox(height: 16),
              Text('Retainly', style: TextStyle(fontSize: 20)),
            ],
          ),
        ),
      ),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\theme ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\theme\app_theme.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';

class AppTheme {
  // Define our color palette
  static const Color primaryColor = Color(0xFFFF6A00);
  static const Color surfaceColor = Color(0xFF121212);
  static const Color surfaceVariantColor = Color(0xFF1C1C1E);
  static const Color onSurfaceColor = Colors.white70;
  static const Color onPrimaryColor = Colors.white;
  static const Color errorColor = Color(0xFFCF6679);
  static const Color cardColor = Color(0xFF1C1C1E);
  static const Color scaffoldBackgroundColor = Color(0xFF121212);
  static const Color dividerColor = Color(0xFF383838);

  // Material 3 light theme (not used, but included for completeness)
  static ThemeData get lightTheme {
    return ThemeData(
      useMaterial3: true,
      colorScheme: ColorScheme.light(
        primary: primaryColor,
        onPrimary: Colors.white,
        secondary: primaryColor.withOpacity(0.8),
        onSecondary: Colors.white,
        surface: Colors.white,
        onSurface: Colors.black87,
        background: const Color(0xFFF5F5F5),
        error: const Color(0xFFB00020),
      ),
    );
  }

  // Material 3 dark theme
  static ThemeData get darkTheme {
    return ThemeData(
      useMaterial3: true,
      brightness: Brightness.dark,
      colorScheme: const ColorScheme.dark(
        primary: primaryColor,
        onPrimary: onPrimaryColor,
        secondary: primaryColor,
        onSecondary: onPrimaryColor,
        surface: surfaceColor,
        onSurface: onSurfaceColor,
        background: scaffoldBackgroundColor,
        error: errorColor,
      ),
      scaffoldBackgroundColor: scaffoldBackgroundColor,
      cardColor: cardColor,
      dividerColor: dividerColor,

      // Text themes
      textTheme: const TextTheme(
        bodyLarge: TextStyle(color: onSurfaceColor, fontSize: 16),
        bodyMedium: TextStyle(color: onSurfaceColor, fontSize: 14),
        bodySmall: TextStyle(color: onSurfaceColor, fontSize: 12),
        titleLarge: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.bold,
          fontSize: 22,
        ),
        titleMedium: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.w500,
          fontSize: 16,
        ),
        titleSmall: TextStyle(
          color: Colors.white,
          fontWeight: FontWeight.w500,
          fontSize: 14,
        ),
      ),

      // AppBar theme
      appBarTheme: const AppBarTheme(
        backgroundColor: surfaceVariantColor,
        elevation: 0,
        centerTitle: true,
        titleTextStyle: TextStyle(
          color: Colors.white,
          fontSize: 20,
          fontWeight: FontWeight.bold,
        ),
        iconTheme: IconThemeData(color: Colors.white),
      ),

      // Card theme
      cardTheme: CardThemeData(
        color: cardColor,
        elevation: 2,
        shadowColor: Colors.black.withOpacity(0.2),
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        clipBehavior: Clip.antiAlias,
      ),

      // Button themes
      elevatedButtonTheme: ElevatedButtonThemeData(
        style: ElevatedButton.styleFrom(
          backgroundColor: primaryColor,
          foregroundColor: onPrimaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          textStyle: const TextStyle(fontWeight: FontWeight.w600),
        ),
      ),

      textButtonTheme: TextButtonThemeData(
        style: TextButton.styleFrom(
          foregroundColor: primaryColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(12),
          ),
          padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 12),
          textStyle: const TextStyle(fontWeight: FontWeight.w600),
        ),
      ),

      // Input decoration theme
      inputDecorationTheme: InputDecorationTheme(
        filled: true,
        fillColor: surfaceColor,
        border: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        enabledBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: BorderSide.none,
        ),
        focusedBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: primaryColor, width: 1.5),
        ),
        errorBorder: OutlineInputBorder(
          borderRadius: BorderRadius.circular(12),
          borderSide: const BorderSide(color: errorColor, width: 1.5),
        ),
        contentPadding: const EdgeInsets.symmetric(
          horizontal: 16,
          vertical: 16,
        ),
        hintStyle: TextStyle(color: onSurfaceColor.withOpacity(0.6)),
        labelStyle: TextStyle(color: onSurfaceColor.withOpacity(0.8)),
        errorStyle: const TextStyle(color: errorColor),
      ),

      // Floating action button theme
      floatingActionButtonTheme: const FloatingActionButtonThemeData(
        backgroundColor: primaryColor,
        foregroundColor: onPrimaryColor,
        shape: CircleBorder(),
      ),

      // Dialog theme
      dialogTheme: DialogThemeData(
        backgroundColor: surfaceVariantColor,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(16)),
        titleTextStyle: const TextStyle(
          color: Colors.white,
          fontSize: 18,
          fontWeight: FontWeight.bold,
        ),
        contentTextStyle: const TextStyle(color: onSurfaceColor, fontSize: 14),
      ),

      // Bottom sheet theme
      bottomSheetTheme: const BottomSheetThemeData(
        backgroundColor: surfaceVariantColor,
        shape: RoundedRectangleBorder(
          borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
        ),
      ),

      // Snackbar theme
      snackBarTheme: SnackBarThemeData(
        backgroundColor: surfaceVariantColor,
        contentTextStyle: const TextStyle(color: onSurfaceColor),
        behavior: SnackBarBehavior.floating,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(8)),
      ),

      // Divider theme
      dividerTheme: const DividerThemeData(
        color: dividerColor,
        thickness: 1,
        space: 1,
      ),

      // Icon theme
      iconTheme: const IconThemeData(color: onSurfaceColor, size: 24),

      // List tile theme
      listTileTheme: const ListTileThemeData(
        iconColor: primaryColor,
        textColor: onSurfaceColor,
      ),

      // Slider theme
      sliderTheme: SliderThemeData(
        activeTrackColor: primaryColor,
        thumbColor: primaryColor,
        overlayColor: primaryColor.withOpacity(0.2),
        valueIndicatorColor: primaryColor,
        valueIndicatorTextStyle: const TextStyle(color: onPrimaryColor),
      ),
    );
  }

  // Page transition builders
  static PageRouteBuilder<T> fadeTransition<T>({
    required Widget page,
    required RouteSettings settings,
  }) {
    return PageRouteBuilder<T>(
      settings: settings,
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        return FadeTransition(opacity: animation, child: child);
      },
      transitionDuration: const Duration(milliseconds: 220),
    );
  }

  static PageRouteBuilder<T> slideAndFadeTransition<T>({
    required Widget page,
    required RouteSettings settings,
  }) {
    return PageRouteBuilder<T>(
      settings: settings,
      pageBuilder: (context, animation, secondaryAnimation) => page,
      transitionsBuilder: (context, animation, secondaryAnimation, child) {
        const begin = Offset(0.0, 0.05);
        const end = Offset.zero;
        const curve = Curves.easeOutCubic;

        var tween = Tween(
          begin: begin,
          end: end,
        ).chain(CurveTween(curve: curve));

        return SlideTransition(
          position: animation.drive(tween),
          child: FadeTransition(opacity: animation, child: child),
        );
      },
      transitionDuration: const Duration(milliseconds: 220),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card_grid.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'dart:io';

import '../../data/card_entity.dart';
import '../../ui/theme/app_theme.dart';

class CardGrid extends StatelessWidget {
  final List<CardEntity> cards;
  final ScrollController? scrollController;
  final Function(CardEntity) onCardSelected;
  final Function(CardEntity)? onCardLongPress;
  final bool isLoading;
  final bool hasMore;

  const CardGrid({
    super.key,
    required this.cards,
    this.scrollController,
    required this.onCardSelected,
    this.onCardLongPress,
    this.isLoading = false,
    this.hasMore = false,
  });

  @override
  Widget build(BuildContext context) {
    if (cards.isEmpty && !isLoading) {
      return const Center(
        child: Text('No cards found', style: TextStyle(color: Colors.white70)),
      );
    }

    return GridView.builder(
      controller: scrollController,
      padding: const EdgeInsets.all(16.0),
      gridDelegate: const SliverGridDelegateWithFixedCrossAxisCount(
        crossAxisCount: 2,
        mainAxisSpacing: 16.0,
        crossAxisSpacing: 16.0,
        childAspectRatio: 0.75,
      ),
      itemCount: cards.length + (hasMore || isLoading ? 1 : 0),
      itemBuilder: (context, index) {
        if (index >= cards.length) {
          return const Center(child: CircularProgressIndicator());
        }
        return _buildCardItem(context, cards[index]);
      },
    );
  }

  Widget _buildCardItem(BuildContext context, CardEntity card) {
    // Choose image or text card appearance

    // Choose image or text card appearance
    final isImage = card.type == 'image' && card.imagePath != null;
    final isLink = card.type == 'link' && card.url != null;

    return InkWell(
      onTap: () => onCardSelected(card),
      onLongPress: onCardLongPress != null
          ? () => onCardLongPress!(card)
          : null,
      borderRadius: BorderRadius.circular(12),
      child: Card(
        elevation: 2,
        shape: RoundedRectangleBorder(borderRadius: BorderRadius.circular(12)),
        color: AppTheme.surfaceColor,
        child: Container(
          decoration: BoxDecoration(
            borderRadius: BorderRadius.circular(12),
            border: Border.all(
              color: AppTheme.dividerColor.withOpacity(0.2),
              width: 1,
            ),
          ),
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              if (isImage) _buildImageContent(card),
              if (isLink) _buildLinkContent(card),
              if (!isImage && !isLink) _buildTextContent(card),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildImageContent(CardEntity card) {
    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Expanded(
            child: ClipRRect(
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
              child: card.imagePath!.startsWith('http')
                  ? Image.network(
                      card.imagePath!,
                      fit: BoxFit.cover,
                      width: double.infinity,
                      errorBuilder: (_, __, ___) => const Center(
                        child: Icon(
                          Icons.broken_image,
                          size: 48,
                          color: Colors.grey,
                        ),
                      ),
                    )
                  : Image.file(
                      File(card.imagePath!),
                      fit: BoxFit.cover,
                      width: double.infinity,
                      errorBuilder: (_, __, ___) => const Center(
                        child: Icon(
                          Icons.broken_image,
                          size: 48,
                          color: Colors.grey,
                        ),
                      ),
                    ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(12.0),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Text(
                  card.content,
                  style: const TextStyle(
                    fontWeight: FontWeight.bold,
                    fontSize: 14,
                    color: Colors.white,
                  ),
                  maxLines: 2,
                  overflow: TextOverflow.ellipsis,
                ),
                const SizedBox(height: 4),
                Text(
                  _formatDate(card.createdAt),
                  style: const TextStyle(fontSize: 12, color: Colors.grey),
                ),
              ],
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildLinkContent(CardEntity card) {
    final uri = Uri.tryParse(card.url!);
    final host = uri?.host ?? 'link';

    return Expanded(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Container(
            padding: const EdgeInsets.all(12),
            decoration: BoxDecoration(
              color: AppTheme.primaryColor.withOpacity(0.1),
              borderRadius: const BorderRadius.only(
                topLeft: Radius.circular(12),
                topRight: Radius.circular(12),
              ),
            ),
            child: Row(
              children: [
                const Icon(Icons.link, size: 16, color: AppTheme.primaryColor),
                const SizedBox(width: 8),
                Expanded(
                  child: Text(
                    host,
                    style: const TextStyle(
                      fontSize: 12,
                      color: AppTheme.primaryColor,
                    ),
                    overflow: TextOverflow.ellipsis,
                  ),
                ),
              ],
            ),
          ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(12.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    card.content,
                    style: const TextStyle(
                      fontWeight: FontWeight.bold,
                      fontSize: 16,
                      color: Colors.white,
                    ),
                    maxLines: 2,
                    overflow: TextOverflow.ellipsis,
                  ),
                  const SizedBox(height: 8),
                  if (card.body != null)
                    Expanded(
                      child: Text(
                        card.body!,
                        style: const TextStyle(
                          fontSize: 13,
                          color: Colors.grey,
                        ),
                        maxLines: 3,
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                  const SizedBox(height: 4),
                  Text(
                    _formatDate(card.createdAt),
                    style: const TextStyle(fontSize: 12, color: Colors.grey),
                  ),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildTextContent(CardEntity card) {
    return Expanded(
      child: Padding(
        padding: const EdgeInsets.all(12.0),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              card.content,
              style: const TextStyle(
                fontWeight: FontWeight.bold,
                fontSize: 16,
                color: Colors.white,
              ),
              maxLines: 2,
              overflow: TextOverflow.ellipsis,
            ),
            const SizedBox(height: 8),
            if (card.body != null)
              Expanded(
                child: Text(
                  card.body!,
                  style: const TextStyle(fontSize: 13, color: Colors.grey),
                  maxLines: 8,
                  overflow: TextOverflow.ellipsis,
                ),
              ),
            const SizedBox(height: 4),
            Text(
              _formatDate(card.createdAt),
              style: const TextStyle(fontSize: 12, color: Colors.grey),
            ),
          ],
        ),
      ),
    );
  }

  String _formatDate(int timestamp) {
    final date = DateTime.fromMillisecondsSinceEpoch(timestamp);
    final now = DateTime.now();
    final diff = now.difference(date);

    if (diff.inDays == 0) {
      if (diff.inHours == 0) {
        return '${diff.inMinutes} min ago';
      }
      return '${diff.inHours} hr ago';
    } else if (diff.inDays < 7) {
      return '${diff.inDays} day${diff.inDays > 1 ? 's' : ''} ago';
    } else {
      return DateFormat.MMMd().format(date);
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card_grid_widget.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card_list_widget.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import '../../data/card_entity.dart';
import '../../data/repository/card_repository.dart';

class CardListWidget extends StatefulWidget {
  const CardListWidget({super.key});

  @override
  CardListWidgetState createState() => CardListWidgetState();
}

class CardListWidgetState extends State<CardListWidget> {
  final _repository = CardRepository();
  List<CardEntity> _cards = [];
  bool _isLoading = true;
  String? _error;

  @override
  void initState() {
    super.initState();
    _loadCards();
  }

  Future<void> _loadCards() async {
    try {
      setState(() {
        _isLoading = true;
        _error = null;
      });

      final cards = await _repository.getAllCards();

      setState(() {
        _cards = cards;
        _isLoading = false;
      });
    } catch (e) {
      setState(() {
        _error = 'Failed to load cards: $e';
        _isLoading = false;
      });
    }
  }

  // Make _loadCards method public so it can be called from outside
  void refreshCards() {
    _loadCards();
  }

  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Center(child: CircularProgressIndicator());
    }

    if (_error != null) {
      return Center(
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(_error!, style: const TextStyle(color: Colors.red)),
            const SizedBox(height: 16),
            ElevatedButton(onPressed: _loadCards, child: const Text('Retry')),
          ],
        ),
      );
    }

    if (_cards.isEmpty) {
      return const Center(
        child: Text('No cards yet. Add a card using the + button.'),
      );
    }

    return ListView.builder(
      padding: const EdgeInsets.all(8.0),
      itemCount: _cards.length,
      itemBuilder: (context, index) {
        final card = _cards[index];
        return Card(
          margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
          child: ListTile(
            title: Text(card.content),
            subtitle: Text(card.body ?? 'No content'),
            trailing: Text(
              DateTime.fromMillisecondsSinceEpoch(
                card.createdAt,
              ).toString().split('.')[0],
            ),
          ),
        );
      },
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\image_source_sheet.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:image_picker/image_picker.dart';

class ImageSourceSheet extends StatelessWidget {
  const ImageSourceSheet({super.key});

  @override
  Widget build(BuildContext context) {
    return SafeArea(
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          // Header with border
          Container(
            padding: const EdgeInsets.symmetric(vertical: 16),
            decoration: BoxDecoration(
              border: Border(
                bottom: BorderSide(
                  color: Colors.grey.withOpacity(0.5),
                  width: 1,
                ),
              ),
            ),
            child: const Center(
              child: Text(
                'Select Image Source',
                style: TextStyle(
                  color: Colors.white,
                  fontSize: 16,
                  fontWeight: FontWeight.w600,
                ),
              ),
            ),
          ),

          // Source options with grid layout
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 24),
            child: Row(
              mainAxisAlignment: MainAxisAlignment.spaceEvenly,
              children: [
                _buildSourceOption(
                  context,
                  icon: Icons.photo_library,
                  label: 'Gallery',
                  source: ImageSource.gallery,
                  color: Colors.blue,
                ),
                _buildSourceOption(
                  context,
                  icon: Icons.photo_camera,
                  label: 'Camera',
                  source: ImageSource.camera,
                  color: Colors.green,
                ),
              ],
            ),
          ),

          // Bottom padding
          const SizedBox(height: 16),
        ],
      ),
    );
  }

  Widget _buildSourceOption(
    BuildContext context, {
    required IconData icon,
    required String label,
    required ImageSource source,
    required Color color,
  }) {
    return InkWell(
      onTap: () {
        HapticFeedback.mediumImpact();
        Navigator.of(context).pop(source);
      },
      borderRadius: BorderRadius.circular(16),
      child: Container(
        width: 120,
        padding: const EdgeInsets.all(16),
        decoration: BoxDecoration(
          color: const Color(0xFF303030),
          borderRadius: BorderRadius.circular(16),
          border: Border.all(color: color.withOpacity(0.3), width: 1),
        ),
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            Container(
              padding: const EdgeInsets.all(16),
              decoration: BoxDecoration(
                color: color.withOpacity(0.2),
                shape: BoxShape.circle,
              ),
              child: Icon(icon, color: color, size: 32),
            ),
            const SizedBox(height: 12),
            Text(
              label,
              style: const TextStyle(
                color: Colors.white,
                fontWeight: FontWeight.w500,
              ),
            ),
          ],
        ),
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\spaces_panel.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:intl/intl.dart';

import '../../blocs/spaces/spaces_bloc.dart';
import '../../data/space_entity.dart';
import '../../ui/screens/space_screen.dart';

class SpacesPanel extends StatelessWidget {
  const SpacesPanel({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<SpacesBloc, SpacesState>(
      builder: (context, state) {
        if (state is SpacesLoading) {
          return const Center(child: CircularProgressIndicator());
        } else if (state is SpacesLoaded) {
          return Column(
            children: [
              _buildHeader(context),
              Expanded(
                child: state.spaces.isEmpty
                    ? _buildEmptyState(context)
                    : _buildSpacesList(context, state.spaces),
              ),
            ],
          );
        } else if (state is SpacesError) {
          return Center(child: Text('Error: ${state.message}'));
        } else {
          return const SizedBox.shrink();
        }
      },
    );
  }

  Widget _buildHeader(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.spaceBetween,
        children: [
          const Text(
            'Spaces',
            style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold),
          ),
          IconButton(
            icon: const Icon(Icons.add),
            onPressed: () => _showAddSpaceDialog(context),
            tooltip: 'Create New Space',
          ),
        ],
      ),
    );
  }

  Widget _buildEmptyState(BuildContext context) {
    return Center(
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          const Icon(Icons.folder_outlined, size: 64, color: Colors.grey),
          const SizedBox(height: 16),
          const Text(
            'No spaces yet',
            style: TextStyle(fontSize: 18, fontWeight: FontWeight.bold),
          ),
          const SizedBox(height: 8),
          const Text(
            'Create spaces to organize your cards',
            textAlign: TextAlign.center,
            style: TextStyle(color: Colors.grey),
          ),
          const SizedBox(height: 16),
          ElevatedButton.icon(
            icon: const Icon(Icons.add),
            label: const Text('Create Space'),
            onPressed: () => _showAddSpaceDialog(context),
          ),
        ],
      ),
    );
  }

  Widget _buildSpacesList(BuildContext context, List<SpaceEntity> spaces) {
    return ListView.builder(
      padding: const EdgeInsets.symmetric(vertical: 8),
      itemCount: spaces.length,
      itemBuilder: (context, index) {
        final space = spaces[index];
        return _buildSpaceListItem(context, space);
      },
    );
  }

  Widget _buildSpaceListItem(BuildContext context, SpaceEntity space) {
    final cardCount = space.cardCount ?? 0;
    final formatter = DateFormat.yMMMd();
    final dateCreated = formatter.format(
      DateTime.fromMillisecondsSinceEpoch(space.createdAt),
    );

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
      child: InkWell(
        onTap: () => _navigateToSpace(context, space),
        borderRadius: BorderRadius.circular(12),
        child: Card(
          elevation: 1,
          child: Padding(
            padding: const EdgeInsets.all(16),
            child: Column(
              crossAxisAlignment: CrossAxisAlignment.start,
              children: [
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Expanded(
                      child: Text(
                        space.name,
                        style: const TextStyle(
                          fontSize: 18,
                          fontWeight: FontWeight.bold,
                        ),
                      ),
                    ),
                    PopupMenuButton<String>(
                      onSelected: (value) {
                        switch (value) {
                          case 'edit':
                            _showEditSpaceDialog(context, space);
                            break;
                          case 'delete':
                            _showDeleteSpaceDialog(context, space);
                            break;
                        }
                      },
                      itemBuilder: (context) => [
                        const PopupMenuItem(
                          value: 'edit',
                          child: Row(
                            children: [
                              Icon(Icons.edit),
                              SizedBox(width: 8),
                              Text('Rename'),
                            ],
                          ),
                        ),
                        const PopupMenuItem(
                          value: 'delete',
                          child: Row(
                            children: [
                              Icon(Icons.delete),
                              SizedBox(width: 8),
                              Text('Delete'),
                            ],
                          ),
                        ),
                      ],
                    ),
                  ],
                ),
                const SizedBox(height: 8),
                Row(
                  mainAxisAlignment: MainAxisAlignment.spaceBetween,
                  children: [
                    Text(
                      '$cardCount ${cardCount == 1 ? 'card' : 'cards'}',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                    Text(
                      'Created $dateCreated',
                      style: Theme.of(context).textTheme.bodySmall,
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  void _navigateToSpace(BuildContext context, SpaceEntity space) {
    Navigator.of(
      context,
    ).push(MaterialPageRoute(builder: (_) => SpaceScreen(space: space)));
  }

  void _showAddSpaceDialog(BuildContext context) {
    final textController = TextEditingController();

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Create New Space'),
        content: TextField(
          controller: textController,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Space Name',
            labelText: 'Name',
          ),
          textCapitalization: TextCapitalization.sentences,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final name = textController.text.trim();
              if (name.isNotEmpty) {
                context.read<SpacesBloc>().add(AddSpace(name));
                Navigator.pop(dialogContext);
              }
            },
            child: const Text('Create'),
          ),
        ],
      ),
    );
  }

  void _showEditSpaceDialog(BuildContext context, SpaceEntity space) {
    final textController = TextEditingController(text: space.name);

    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Rename Space'),
        content: TextField(
          controller: textController,
          autofocus: true,
          decoration: const InputDecoration(
            hintText: 'Space Name',
            labelText: 'Name',
          ),
          textCapitalization: TextCapitalization.sentences,
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              final name = textController.text.trim();
              if (name.isNotEmpty) {
                context.read<SpacesBloc>().add(
                  UpdateSpace(space.copyWith(name: name)),
                );
                Navigator.pop(dialogContext);
              }
            },
            child: const Text('Save'),
          ),
        ],
      ),
    );
  }

  void _showDeleteSpaceDialog(BuildContext context, SpaceEntity space) {
    showDialog(
      context: context,
      builder: (dialogContext) => AlertDialog(
        title: const Text('Delete Space'),
        content: Text(
          'Are you sure you want to delete "${space.name}"? '
          'Cards in this space will remain in your collection but will be moved to the global view.',
        ),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(dialogContext),
            child: const Text('Cancel'),
          ),
          TextButton(
            onPressed: () {
              context.read<SpacesBloc>().add(DeleteSpace(space.id!));
              Navigator.pop(dialogContext);
            },
            style: TextButton.styleFrom(foregroundColor: Colors.red),
            child: const Text('Delete'),
          ),
        ],
      ),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\card ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_card_options_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_image_card_modal.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';

class AddImageCardModal extends StatefulWidget {
  final File? imageFile;
  final String? imagePath;
  final bool autofocusSave;
  const AddImageCardModal({
    super.key,
    this.imageFile,
    this.imagePath,
    this.autofocusSave = false,
  });

  @override
  State<AddImageCardModal> createState() => _AddImageCardModalState();
}

class _AddImageCardModalState extends State<AddImageCardModal> {
  final _captionController = TextEditingController();
  File? _fileToShow;
  bool _userInitiatedSave = false;

  @override
  void initState() {
    super.initState();
    _initializeImage();
  }

  Future<void> _initializeImage() async {
    try {
      if (widget.imageFile != null) {
        print('AddImageCardModal: Using provided File object');
        _fileToShow = widget.imageFile;
      } else if (widget.imagePath != null) {
        print(
          'AddImageCardModal: Loading image from path: ${widget.imagePath}',
        );
        final file = File(widget.imagePath!);

        if (await file.exists()) {
          print(
            'AddImageCardModal: File exists, size: ${await file.length()} bytes',
          );
          setState(() {
            _fileToShow = file;
          });
        } else {
          print(
            'AddImageCardModal: Error - File does not exist at ${widget.imagePath}',
          );
          if (mounted) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Image file not found or inaccessible'),
                backgroundColor: Colors.red,
                behavior: SnackBarBehavior.floating,
              ),
            );
          }
        }
      } else {
        print('AddImageCardModal: No image source provided');
      }
    } catch (e) {
      print('AddImageCardModal: Error initializing image: $e');
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error loading image: ${e.toString()}'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }
    }
  }

  @override
  void dispose() {
    _captionController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => AddCardBloc(cardRepository: CardRepository()),
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is AddCardSuccess) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Image saved successfully'),
                behavior: SnackBarBehavior.floating,
              ),
            );
            // Only pop if the user initiated saving via the save button
            if (_userInitiatedSave) {
              Navigator.of(context).pop(true);
            }
          } else if (state is AddCardError) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(SnackBar(content: Text('Failed: ${state.message}')));
          }
        },
        builder: (context, state) {
          return Material(
            // Use actual color instead of transparent for Material widget with TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Column(
                mainAxisSize: MainAxisSize.min,
                crossAxisAlignment: CrossAxisAlignment.stretch,
                children: [
                  Row(
                    children: [
                      const Text(
                        'Image Preview',
                        style: TextStyle(
                          fontSize: 20,
                          fontWeight: FontWeight.bold,
                          color: Colors.white,
                        ),
                      ),
                      const Spacer(),
                      IconButton(
                        icon: const Icon(Icons.close, color: Colors.grey),
                        onPressed: () => Navigator.of(context).pop(),
                      ),
                    ],
                  ),
                  const SizedBox(height: 12),
                  _fileToShow != null
                      ? AspectRatio(
                          aspectRatio: 1,
                          child: ClipRRect(
                            borderRadius: BorderRadius.circular(12),
                            child: Builder(
                              builder: (context) {
                                try {
                                  return Image.file(
                                    _fileToShow!,
                                    fit: BoxFit.cover,
                                    errorBuilder: (context, error, stackTrace) {
                                      print(
                                        'AddImageCardModal: Error rendering image: $error',
                                      );
                                      return Container(
                                        color: Colors.grey[800],
                                        child: const Center(
                                          child: Icon(
                                            Icons.broken_image,
                                            color: Colors.white54,
                                            size: 64,
                                          ),
                                        ),
                                      );
                                    },
                                  );
                                } catch (e) {
                                  print(
                                    'AddImageCardModal: Exception in image builder: $e',
                                  );
                                  return Container(
                                    color: Colors.grey[800],
                                    child: const Center(
                                      child: Icon(
                                        Icons.error_outline,
                                        color: Colors.redAccent,
                                        size: 64,
                                      ),
                                    ),
                                  );
                                }
                              },
                            ),
                          ),
                        )
                      // Show placeholder if no image
                      : AspectRatio(
                          aspectRatio: 1,
                          child: Container(
                            decoration: BoxDecoration(
                              color: Colors.grey[800],
                              borderRadius: BorderRadius.circular(12),
                            ),
                            child: const Center(
                              child: Icon(
                                Icons.image_not_supported,
                                color: Colors.white54,
                                size: 64,
                              ),
                            ),
                          ),
                        ),
                  const SizedBox(height: 12),
                  TextField(
                    controller: _captionController,
                    style: const TextStyle(color: Colors.white),
                    decoration: InputDecoration(
                      hintText: 'Add a caption (optional)',
                      hintStyle: TextStyle(color: Colors.grey[400]),
                      filled: true,
                      fillColor: const Color(0xFF262626),
                      border: OutlineInputBorder(
                        borderRadius: BorderRadius.circular(12),
                        borderSide: BorderSide.none,
                      ),
                      contentPadding: const EdgeInsets.all(14),
                    ),
                  ),
                  const SizedBox(height: 16),
                  Row(
                    mainAxisAlignment: MainAxisAlignment.end,
                    children: [
                      TextButton(
                        onPressed: () => Navigator.of(context).pop(),
                        child: const Text(
                          'CANCEL',
                          style: TextStyle(color: Colors.grey),
                        ),
                      ),
                      const SizedBox(width: 12),
                      ElevatedButton(
                        autofocus: widget.autofocusSave,
                        onPressed: state is AddCardLoading
                            ? null
                            : () {
                                // Mark that user initiated this save
                                _userInitiatedSave = true;

                                context.read<AddCardBloc>().add(
                                  AddImageCardRequested(
                                    imagePath: _fileToShow?.path ?? '',
                                    caption:
                                        _captionController.text.trim().isEmpty
                                        ? null
                                        : _captionController.text.trim(),
                                  ),
                                );
                              },
                        style: ElevatedButton.styleFrom(
                          backgroundColor: Colors.orangeAccent,
                          foregroundColor: Colors.white,
                        ),
                        child: state is AddCardLoading
                            ? const SizedBox(
                                width: 20,
                                height: 20,
                                child: CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(
                                    Colors.white,
                                  ),
                                ),
                              )
                            : const Text('SAVE'),
                      ),
                    ],
                  ),
                ],
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_image_card_to_space_modal.dart
=========================================
--- Content Start ---

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_image_card_to_space_modal.dart.bak
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'dart:io';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';
import '../../../data/card_entity.dart';
import '../../../utils/image_storage.dart';

class AddImageCardToSpaceModal extends StatefulWidget {
  final File? imageFile;
  final String? imagePath;
  final bool autofocusSave;
  final int spaceId;

  const AddImageCardToSpaceModal({
    super.key,
    this.imageFile,
    this.imagePath,
    this.autofocusSave = false,
    required this.spaceId,
  });

  @override
  State<AddImageCardToSpaceModal> createState() =>
      _AddImageCardToSpaceModalState();
}

class _AddImageCardToSpaceModalState extends State<AddImageCardToSpaceModal> {
  late final TextEditingController _titleController;
  late final TextEditingController _descriptionController;
  final _formKey = GlobalKey<FormState>();
  final ImageStorage _imageStorage = ImageStorage();
  bool _isSaveEnabled = false;
  String? _processedImagePath;
  bool _processingImage = false;

  @override
  void initState() {
    super.initState();
    _titleController = TextEditingController();
    _descriptionController = TextEditingController();
    _titleController.addListener(_validateInput);

    if (widget.imageFile != null) {
      _processImage();
    } else if (widget.imagePath != null) {
      _processedImagePath = widget.imagePath;
    }
  }

  @override
  void dispose() {
    _titleController.removeListener(_validateInput);
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final isValid =
        _titleController.text.trim().isNotEmpty && _processedImagePath != null;
    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  Future<void> _processImage() async {
    if (widget.imageFile == null) return;

    setState(() {
      _processingImage = true;
    });

    try {
      // Use ImageStorage to save and process the image
      final savedPath = await _imageStorage.saveImageFromFile(
        widget.imageFile!,
      );
      setState(() {
        _processedImagePath = savedPath;
        _processingImage = false;
      });
      _validateInput();
    } catch (e) {
      setState(() {
        _processingImage = false;
      });
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error processing image: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }

  Future<void> _saveCard() async {
    if (!_formKey.currentState!.validate() || _isLoading) return;
    
    setState(() {
      _isLoading = true;
    });

    try {
      final cardRepository = context.read<CardRepository>();
      final now = DateTime.now().millisecondsSinceEpoch;
      
      final card = CardEntity(
        type: 'image',
        content: _titleController.text.trim(),
        body: _descriptionController.text.trim(),
        imagePath: _processedImagePath,
        spaceId: widget.spaceId,
        createdAt: now,
        updatedAt: now,
      );

      await cardRepository.addCard(card);
      
      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
            return Container(
              padding: EdgeInsets.only(
                bottom: MediaQuery.of(context).viewInsets.bottom,
              ),
              decoration: const BoxDecoration(
                color: Color(0xFF1A1A1A),
                borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _buildHeader(),
                    _buildImagePreview(),
                    _buildTextForm(),
                    _buildFooter(state),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        children: [
          const Icon(Icons.image, color: Colors.white),
          const SizedBox(width: 16),
          const Text(
            'Add Image to Space',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const Spacer(),
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white70),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  Widget _buildImagePreview() {
    if (_processingImage) {
      return const Padding(
        padding: EdgeInsets.all(24.0),
        child: Center(child: CircularProgressIndicator()),
      );
    } else if (_processedImagePath != null) {
      return Padding(
        padding: const EdgeInsets.all(16.0),
        child: ClipRRect(
          borderRadius: BorderRadius.circular(12),
          child: Image.file(
            File(_processedImagePath!),
            height: 200,
            width: double.infinity,
            fit: BoxFit.cover,
          ),
        ),
      );
    } else {
      return const Padding(
        padding: EdgeInsets.all(24.0),
        child: Center(
          child: Text(
            'No image selected',
            style: TextStyle(color: Colors.grey),
          ),
        ),
      );
    }
  }

  Widget _buildTextForm() {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          TextFormField(
            controller: _titleController,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'Title',
              labelStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter a title';
              }
              return null;
            },
            autofocus: widget.autofocusSave,
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: _descriptionController,
            maxLines: 3,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'Description (Optional)',
              labelStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFooter(AddCardState state) {
    final isLoading = state is AddCardLoading;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      decoration: const BoxDecoration(
        border: Border(top: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF303030),
            ),
            child: const Text('Cancel'),
          ),
          const SizedBox(width: 16),
          ElevatedButton(
            onPressed: !_isSaveEnabled || isLoading || _processingImage
                ? null
                : () {
                    if (_formKey.currentState!.validate() &&
                        _processedImagePath != null) {
                      HapticFeedback.mediumImpact();
                      final now = DateTime.now().millisecondsSinceEpoch;

                      final card = CardEntity(
                        type: 'image',
                        content: _titleController.text.trim(),
                        body: _descriptionController.text.trim(),
                        imagePath: _processedImagePath,
                        spaceId: widget.spaceId, // Add to the specified space
                        createdAt: now,
                        updatedAt: now,
                      );

                      BlocProvider.of<AddCardBloc>(
                        context,
                      ).add(AddNewCard(card));
                    }
                  },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blueAccent,
              disabledBackgroundColor: Colors.blueAccent.withOpacity(0.3),
            ),
            child: isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      strokeWidth: 2,
                    ),
                  )
                : const Text('Save'),
          ),
        ],
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_image_card_to_space_modal.dart.new
=========================================
--- Content Start ---

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_link_card_modal.dart
=========================================
--- Content Start ---
import 'dart:async';
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';
import '../../../utils/url_utils.dart';

class AddLinkCardModal extends StatefulWidget {
  final String? initialUrl;
  final String? initialTitle;
  final bool autofocusSave;
  const AddLinkCardModal({
    super.key,
    this.initialUrl,
    this.initialTitle,
    this.autofocusSave = false,
  });

  @override
  State<AddLinkCardModal> createState() => _AddLinkCardModalState();
}

class _AddLinkCardModalState extends State<AddLinkCardModal> {
  late final TextEditingController _urlController;
  late final TextEditingController _titleController;
  final _formKey = GlobalKey<FormState>();
  late final AddCardBloc _addCardBloc;

  bool _isUrlValid = false;
  bool _isFetching = false;
  String? _fetchError;
  Timer? _debounceTimer;
  bool _userInitiatedSave = false;

  @override
  void initState() {
    super.initState();
    _addCardBloc = AddCardBloc(cardRepository: CardRepository());
    _urlController = TextEditingController(text: widget.initialUrl ?? '');
    _titleController = TextEditingController(text: widget.initialTitle ?? '');
    _urlController.addListener(_onUrlChanged);
    if (widget.initialUrl != null && widget.initialUrl!.trim().isNotEmpty) {
      _isUrlValid = _isValidUrl(widget.initialUrl!);
    }
  }

  @override
  void dispose() {
    _debounceTimer?.cancel();
    _urlController.removeListener(_onUrlChanged);
    _urlController.dispose();
    _titleController.dispose();
    _addCardBloc.close();
    super.dispose();
  }

  void _onUrlChanged() {
    final url = _urlController.text.trim();
    final isValid = _isValidUrl(url);

    if (isValid != _isUrlValid) {
      setState(() {
        _isUrlValid = isValid;
        _fetchError = null;
      });

      // Only fetch if URL is valid
      if (isValid) {
        // Update with normalized URL for better UX
        final normalizedUrl = UrlUtils.normalizeUrl(url);
        if (normalizedUrl != url) {
          // Update text field with properly formatted URL (don't trigger listener)
          _urlController.removeListener(_onUrlChanged);
          _urlController.text = normalizedUrl;
          _urlController.selection = TextSelection.fromPosition(
            TextPosition(offset: normalizedUrl.length),
          );
          _urlController.addListener(_onUrlChanged);
        }

        // Debounce the fetch operation
        _debounceTimer?.cancel();
        _debounceTimer = Timer(const Duration(milliseconds: 500), () {
          _fetchTitle();
        });
      }
    }
  }

  bool _isValidUrl(String url) {
    if (url.isEmpty) return false;

    // More permissive URL validation
    try {
      // First, try to normalize the URL
      String normalizedUrl = url.trim();
      if (!normalizedUrl.startsWith('http://') &&
          !normalizedUrl.startsWith('https://') &&
          !normalizedUrl.startsWith('www.')) {
        // Check if it has a valid TLD format with a dot
        if (!normalizedUrl.contains('.')) {
          return false;
        }
      }

      // Additional validation using RegExp (more permissive)
      final RegExp urlRegExp = RegExp(
        r'^(https?:\/\/)?'
        r'(www\.)?'
        r'[-a-zA-Z0-9@:%._\+~#=]{1,256}'
        r'\.[a-zA-Z0-9()]{1,6}'
        r'([-a-zA-Z0-9()@:%_\+.~#?&//=]*)',
        caseSensitive: false,
        multiLine: false,
      );

      return urlRegExp.hasMatch(url);
    } catch (e) {
      print('URL validation error: $e');
      return false;
    }
  }

  Future<void> _fetchTitle() async {
    if (!_isUrlValid || _isFetching) return;

    setState(() {
      _isFetching = true;
      _fetchError = null;
    });

    try {
      // Use the UrlUtils class for normalized URL
      final url = _urlController.text.trim();
      final normalizedUrl = UrlUtils.normalizeUrl(url);

      // Update the URL field with normalized URL if changed
      if (normalizedUrl != url) {
        _urlController.removeListener(_onUrlChanged);
        _urlController.text = normalizedUrl;
        _urlController.selection = TextSelection.fromPosition(
          TextPosition(offset: normalizedUrl.length),
        );
        _urlController.addListener(_onUrlChanged);
      }

      print('Fetching title for URL: $normalizedUrl');

      // Add event to fetch title
      _addCardBloc.add(FetchTitleRequested(url: normalizedUrl));
    } catch (e) {
      print('Error in _fetchTitle: $e');
      setState(() {
        _fetchError = 'Failed to fetch title: ${e.toString()}';
        _isFetching = false;

        // If we couldn't fetch title but have a valid URL, use domain as fallback
        if (_titleController.text.isEmpty) {
          try {
            final url = Uri.parse(
              UrlUtils.normalizeUrl(_urlController.text.trim()),
            );
            _titleController.text = url.host;
          } catch (_) {
            // If parsing fails, leave title as is
          }
        }
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider.value(
      value: _addCardBloc,
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is TitleFetched) {
            _titleController.text = state.title;
            setState(() {
              _isFetching = false;
            });
          } else if (state is AddCardError) {
            setState(() {
              _fetchError = state.message;
              _isFetching = false;
            });
          } else if (state is AddCardSuccess) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Link saved successfully'),
                behavior: SnackBarBehavior.floating,
              ),
            );
            // Only pop if the user initiated saving via the save button
            if (_userInitiatedSave) {
              Navigator.of(context).pop(true);
            }
          }
        },
        builder: (context, state) {
          return Material(
            // Don't use transparent color for Material widget when using TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Title bar
                    Row(
                      children: [
                        const Text(
                          'New Link Card',
                          style: TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        const Spacer(),
                        IconButton(
                          icon: const Icon(Icons.close, color: Colors.grey),
                          onPressed: () => Navigator.of(context).pop(),
                        ),
                      ],
                    ),

                    const SizedBox(height: 16),

                    // URL input field
                    TextFormField(
                      controller: _urlController,
                      autofocus: true,
                      keyboardType: TextInputType.url,
                      textInputAction: TextInputAction.next,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: 'Enter URL (https://example.com)',
                        hintStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                        suffixIcon: _isFetching
                            ? Container(
                                width: 24,
                                height: 24,
                                padding: const EdgeInsets.all(12),
                                child: const CircularProgressIndicator(
                                  strokeWidth: 2,
                                  valueColor: AlwaysStoppedAnimation<Color>(
                                    Colors.white,
                                  ),
                                ),
                              )
                            : IconButton(
                                icon: Icon(
                                  Icons.refresh,
                                  color: _isUrlValid
                                      ? Colors.orangeAccent
                                      : Colors.grey,
                                ),
                                onPressed: _isUrlValid && !_isFetching
                                    ? _fetchTitle
                                    : null,
                                tooltip: 'Fetch page title',
                              ),
                        errorText: _fetchError,
                        errorMaxLines: 2,
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter a URL';
                        }
                        if (!_isValidUrl(value.trim())) {
                          return 'Please enter a valid URL';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 16),

                    // Title input field
                    TextFormField(
                      controller: _titleController,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        labelText: 'Title',
                        labelStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().isEmpty) {
                          return 'Please enter a title';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 24),

                    // Action buttons
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          style: TextButton.styleFrom(
                            foregroundColor: Colors.grey,
                          ),
                          child: const Text('CANCEL'),
                        ),

                        const SizedBox(width: 16),

                        ElevatedButton(
                          autofocus: widget.autofocusSave,
                          onPressed:
                              (_isUrlValid &&
                                  !_isFetching &&
                                  state is! AddCardLoading)
                              ? () {
                                  if (_formKey.currentState?.validate() ??
                                      false) {
                                    final url = _urlController.text.trim();
                                    final title = _titleController.text.trim();

                                    // Set flag that user initiated this save action
                                    _userInitiatedSave = true;

                                    _addCardBloc.add(
                                      AddLinkCardRequested(
                                        url: url,
                                        title: title,
                                      ),
                                    );
                                  }
                                }
                              : null,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.orangeAccent,
                            foregroundColor: Colors.white,
                          ),
                          child: state is AddCardLoading
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(
                                      Colors.white,
                                    ),
                                  ),
                                )
                              : const Text('SAVE'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_link_card_to_space_modal.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../../../data/repository/card_repository.dart';
import '../../../data/card_entity.dart';

class AddLinkCardToSpaceModal extends StatefulWidget {
  final String? initialUrl;
  final bool autofocusSave;
  final int spaceId;

  const AddLinkCardToSpaceModal({
    super.key,
    this.initialUrl,
    this.autofocusSave = false,
    required this.spaceId,
  });

  @override
  State<AddLinkCardToSpaceModal> createState() =>
      _AddLinkCardToSpaceModalState();
}

class _AddLinkCardToSpaceModalState extends State<AddLinkCardToSpaceModal> {
  late final TextEditingController _urlController;
  late final TextEditingController _titleController;
  late final TextEditingController _descriptionController;
  final _formKey = GlobalKey<FormState>();
  bool _isSaveEnabled = false;
  bool _isAnalyzing = false;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _urlController = TextEditingController(text: widget.initialUrl ?? '');
    _titleController = TextEditingController();
    _descriptionController = TextEditingController();

    _urlController.addListener(_validateInput);
    _titleController.addListener(_validateInput);

    if (widget.initialUrl != null && widget.initialUrl!.trim().isNotEmpty) {
      _analyzeLink();
    }
  }

  @override
  void dispose() {
    _urlController.removeListener(_validateInput);
    _titleController.removeListener(_validateInput);
    _urlController.dispose();
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final hasUrl = _isValidUrl(_urlController.text.trim());
    final hasTitle = _titleController.text.trim().isNotEmpty;
    final isValid = hasUrl && hasTitle;

    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  bool _isValidUrl(String url) {
    if (url.isEmpty) return false;
    final uri = Uri.tryParse(url);
    return uri != null && uri.hasScheme && uri.hasAuthority;
  }

  Future<void> _analyzeLink() async {
    final url = _urlController.text.trim();
    if (!_isValidUrl(url)) return;

    setState(() {
      _isAnalyzing = true;
    });

    try {
      // This is a placeholder for the actual link analysis functionality
      // In a real implementation, we would fetch metadata from the URL
      // For now, we'll just set a title if none exists
      if (_titleController.text.isEmpty) {
        _titleController.text = 'Link to ${Uri.parse(url).host}';
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error analyzing link: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isAnalyzing = false;
        });
      }
    }
  }

  Future<void> _saveCard() async {
    if (!_formKey.currentState!.validate() || _isLoading) return;
    
    setState(() {
      _isLoading = true;
    });

    try {
      final cardRepository = context.read<CardRepository>();
      final now = DateTime.now().millisecondsSinceEpoch;
      
      final card = CardEntity(
        type: 'link',
        content: _titleController.text.trim(),
        body: _descriptionController.text.trim(),
        url: _urlController.text.trim(),
        spaceId: widget.spaceId,
        createdAt: now,
        updatedAt: now,
      );

      await cardRepository.addCard(card);
      
      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: const BoxDecoration(
        color: Color(0xFF1A1A1A),
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            _buildHeader(),
            _buildUrlForm(),
            _buildTitleForm(),
            _buildDescriptionForm(),
            _buildFooter(),
          ],
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        children: [
          const Icon(Icons.link, color: Colors.white),
          const SizedBox(width: 16),
          const Text(
            'Add Link to Space',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const Spacer(),
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white70),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  Widget _buildUrlForm() {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'URL',
            style: TextStyle(
              color: Colors.white70,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          TextFormField(
            controller: _urlController,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              hintText: 'Enter URL...',
              hintStyle: const TextStyle(color: Colors.grey),
              border: const OutlineInputBorder(),
              focusedBorder: const OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: const OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: const EdgeInsets.all(16),
              suffixIcon: _isAnalyzing
                  ? const Padding(
                      padding: EdgeInsets.all(12),
                      child: SizedBox(
                        width: 16,
                        height: 16,
                        child: CircularProgressIndicator(strokeWidth: 2),
                      ),
                    )
                  : IconButton(
                      icon: const Icon(Icons.search, color: Colors.white70),
                      onPressed: () => _analyzeLink(),
                    ),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter a URL';
              }
              if (!_isValidUrl(value.trim())) {
                return 'Please enter a valid URL';
              }
              return null;
            },
            autofocus: widget.initialUrl == null,
            onFieldSubmitted: (_) => _analyzeLink(),
          ),
        ],
      ),
    );
  }

  Widget _buildTitleForm() {
    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Title',
            style: TextStyle(
              color: Colors.white70,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          TextFormField(
            controller: _titleController,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              hintText: 'Enter link title...',
              hintStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter a title';
              }
              return null;
            },
            autofocus: widget.initialUrl != null,
          ),
        ],
      ),
    );
  }

  Widget _buildDescriptionForm() {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Description (optional)',
            style: TextStyle(
              color: Colors.white70,
              fontWeight: FontWeight.w500,
            ),
          ),
          const SizedBox(height: 8),
          TextFormField(
            controller: _descriptionController,
            maxLines: 3,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              hintText: 'Enter description...',
              hintStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      decoration: const BoxDecoration(
        border: Border(top: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF303030),
            ),
            child: const Text('Cancel'),
          ),
          const SizedBox(width: 16),
          ElevatedButton(
            onPressed: !_isSaveEnabled || _isLoading
                ? null
                : () {
                    if (_formKey.currentState!.validate()) {
                      HapticFeedback.mediumImpact();
                      _saveCard();
                    }
                  },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blueAccent,
              disabledBackgroundColor: Colors.blueAccent.withOpacity(0.3),
            ),
            child: _isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      strokeWidth: 2,
                    ),
                  )
                : const Text('Save'),
          ),
        ],
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_link_card_to_space_modal.dart.bak
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';
import '../../../data/card_entity.dart';

class AddLinkCardToSpaceModal extends StatefulWidget {
  final String? initialUrl;
  final bool autofocusSave;
  final int spaceId;

  const AddLinkCardToSpaceModal({
    super.key,
    this.initialUrl,
    this.autofocusSave = false,
    required this.spaceId,
  });

  @override
  State<AddLinkCardToSpaceModal> createState() =>
      _AddLinkCardToSpaceModalState();
}

class _AddLinkCardToSpaceModalState extends State<AddLinkCardToSpaceModal> {
  late final TextEditingController _urlController;
  late final TextEditingController _titleController;
  late final TextEditingController _descriptionController;
  final _formKey = GlobalKey<FormState>();
  bool _isSaveEnabled = false;
  bool _isAnalyzing = false;

  @override
  void initState() {
    super.initState();
    _urlController = TextEditingController(text: widget.initialUrl ?? '');
    _titleController = TextEditingController();
    _descriptionController = TextEditingController();

    _urlController.addListener(_validateInput);
    _titleController.addListener(_validateInput);

    if (widget.initialUrl != null && widget.initialUrl!.trim().isNotEmpty) {
      _analyzeLink();
    }
  }

  @override
  void dispose() {
    _urlController.removeListener(_validateInput);
    _titleController.removeListener(_validateInput);
    _urlController.dispose();
    _titleController.dispose();
    _descriptionController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final hasUrl = _isValidUrl(_urlController.text.trim());
    final hasTitle = _titleController.text.trim().isNotEmpty;
    final isValid = hasUrl && hasTitle;

    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  bool _isValidUrl(String url) {
    if (url.isEmpty) return false;
    final uri = Uri.tryParse(url);
    return uri != null && uri.hasScheme && uri.hasAuthority;
  }

  Future<void> _analyzeLink() async {
    final url = _urlController.text.trim();
    if (!_isValidUrl(url)) return;

    setState(() {
      _isAnalyzing = true;
    });

    try {
      // This is a placeholder for the actual link analysis functionality
      // In a real implementation, we would fetch metadata from the URL
      // For now, we'll just set a title if none exists
      if (_titleController.text.isEmpty) {
        _titleController.text = 'Link to ${Uri.parse(url).host}';
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error analyzing link: $e'),
            backgroundColor: Colors.red,
          ),
        );
      }
    } finally {
      if (mounted) {
        setState(() {
          _isAnalyzing = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => AddCardBloc(
        cardRepository: RepositoryProvider.of<CardRepository>(context),
      ),
      child: BlocListener<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is AddCardSuccess) {
            Navigator.of(context).pop(true);
          } else if (state is AddCardError) {
            ScaffoldMessenger.of(context).showSnackBar(
              SnackBar(
                content: Text('Error: ${state.message}'),
                backgroundColor: Colors.red,
                behavior: SnackBarBehavior.floating,
              ),
            );
          }
        },
        child: BlocBuilder<AddCardBloc, AddCardState>(
          builder: (context, state) {
            return Container(
              padding: EdgeInsets.only(
                bottom: MediaQuery.of(context).viewInsets.bottom,
              ),
              decoration: const BoxDecoration(
                color: Color(0xFF1A1A1A),
                borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  children: [
                    _buildHeader(),
                    _buildTextForm(),
                    _buildFooter(state),
                  ],
                ),
              ),
            );
          },
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        children: [
          const Icon(Icons.link, color: Colors.white),
          const SizedBox(width: 16),
          const Text(
            'Add Link to Space',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const Spacer(),
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white70),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  Widget _buildTextForm() {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          TextFormField(
            controller: _urlController,
            keyboardType: TextInputType.url,
            style: const TextStyle(color: Colors.white),
            decoration: InputDecoration(
              labelText: 'URL',
              labelStyle: const TextStyle(color: Colors.grey),
              border: const OutlineInputBorder(),
              focusedBorder: const OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: const OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: const EdgeInsets.all(16),
              suffixIcon: IconButton(
                icon: const Icon(Icons.search, color: Colors.white70),
                onPressed: _isAnalyzing ? null : _analyzeLink,
                tooltip: 'Analyze Link',
              ),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter a URL';
              } else if (!_isValidUrl(value.trim())) {
                return 'Please enter a valid URL';
              }
              return null;
            },
            autofocus: widget.initialUrl == null,
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: _titleController,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'Title',
              labelStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
            validator: (value) {
              if (value == null || value.trim().isEmpty) {
                return 'Please enter a title';
              }
              return null;
            },
            autofocus: widget.initialUrl != null && widget.autofocusSave,
          ),
          const SizedBox(height: 16),
          TextFormField(
            controller: _descriptionController,
            maxLines: 3,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              labelText: 'Description (Optional)',
              labelStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFooter(AddCardState state) {
    final isLoading = state is AddCardLoading;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      decoration: const BoxDecoration(
        border: Border(top: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF303030),
            ),
            child: const Text('Cancel'),
          ),
          const SizedBox(width: 16),
          ElevatedButton(
            onPressed: !_isSaveEnabled || isLoading || _isAnalyzing
                ? null
                : () {
                    if (_formKey.currentState!.validate()) {
                      HapticFeedback.mediumImpact();
                      final now = DateTime.now().millisecondsSinceEpoch;

                      final card = CardEntity(
                        type: 'link',
                        content: _titleController.text.trim(),
                        body: _descriptionController.text.trim(),
                        url: _urlController.text.trim(),
                        spaceId: widget.spaceId, // Add to the specified space
                        createdAt: now,
                        updatedAt: now,
                      );

                      BlocProvider.of<AddCardBloc>(
                        context,
                      ).add(AddNewCard(card));
                    }
                  },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blueAccent,
              disabledBackgroundColor: Colors.blueAccent.withOpacity(0.3),
            ),
            child: isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      strokeWidth: 2,
                    ),
                  )
                : const Text('Save'),
          ),
        ],
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_link_card_to_space_modal.dart.new
=========================================
--- Content Start ---

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_text_card_modal.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../bloc/add_card/add_card_bloc.dart';
import '../../../bloc/add_card/add_card_event.dart';
import '../../../bloc/add_card/add_card_state.dart';
import '../../../data/repository/card_repository.dart';

class AddTextCardModal extends StatefulWidget {
  final String? initialText;
  final bool autofocusSave;
  const AddTextCardModal({
    super.key,
    this.initialText,
    this.autofocusSave = false,
  });

  @override
  State<AddTextCardModal> createState() => _AddTextCardModalState();
}

class _AddTextCardModalState extends State<AddTextCardModal> {
  late final TextEditingController _textController;
  final _formKey = GlobalKey<FormState>();
  final List<String> _tags = [];
  final _tagController = TextEditingController();
  bool _isSaveEnabled = false;
  bool _userInitiatedSave = false;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController(text: widget.initialText ?? '');
    _textController.addListener(_validateInput);
    if (widget.initialText != null && widget.initialText!.trim().isNotEmpty) {
      _isSaveEnabled = true;
    }
  }

  @override
  void dispose() {
    _textController.removeListener(_validateInput);
    _textController.dispose();
    _tagController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final isValid = _textController.text.trim().length >= 2;
    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  void _addTag() {
    final tag = _tagController.text.trim();
    if (tag.isNotEmpty && !_tags.contains(tag)) {
      setState(() {
        _tags.add(tag);
        _tagController.clear();
      });
    }
  }

  void _removeTag(String tag) {
    setState(() {
      _tags.remove(tag);
    });
  }

  @override
  Widget build(BuildContext context) {
    return BlocProvider(
      create: (_) => AddCardBloc(cardRepository: CardRepository()),
      child: BlocConsumer<AddCardBloc, AddCardState>(
        listener: (context, state) {
          if (state is AddCardSuccess) {
            ScaffoldMessenger.of(context).showSnackBar(
              const SnackBar(
                content: Text('Note saved successfully'),
                behavior: SnackBarBehavior.floating,
              ),
            );
            // Only pop if the user initiated saving via the save button
            if (_userInitiatedSave) {
              Navigator.of(context).pop(true);
            }
          } else if (state is AddCardError) {
            ScaffoldMessenger.of(
              context,
            ).showSnackBar(SnackBar(content: Text('Failed: ${state.message}')));
          }
        },
        builder: (context, state) {
          return Material(
            // Use actual color instead of transparent for Material widget with TextField
            color: const Color(0xFF1A1A1A),
            borderRadius: const BorderRadius.vertical(top: Radius.circular(16)),
            child: Container(
              padding: EdgeInsets.only(
                top: 16,
                left: 16,
                right: 16,
                bottom: MediaQuery.of(context).viewInsets.bottom + 16,
              ),
              child: Form(
                key: _formKey,
                child: Column(
                  mainAxisSize: MainAxisSize.min,
                  crossAxisAlignment: CrossAxisAlignment.stretch,
                  children: [
                    // Title bar with close button
                    Row(
                      children: [
                        const Text(
                          'New Text Card',
                          style: TextStyle(
                            fontSize: 20,
                            fontWeight: FontWeight.bold,
                            color: Colors.white,
                          ),
                        ),
                        const Spacer(),
                        IconButton(
                          icon: const Icon(Icons.close, color: Colors.grey),
                          onPressed: () => Navigator.of(context).pop(),
                        ),
                      ],
                    ),
                    const SizedBox(height: 16),

                    // Note content input
                    TextFormField(
                      controller: _textController,
                      autofocus: true,
                      maxLines: 5,
                      minLines: 3,
                      style: const TextStyle(color: Colors.white),
                      decoration: InputDecoration(
                        hintText: 'What\'s on your mind?',
                        hintStyle: TextStyle(color: Colors.grey[400]),
                        filled: true,
                        fillColor: const Color(0xFF262626),
                        border: OutlineInputBorder(
                          borderRadius: BorderRadius.circular(12),
                          borderSide: BorderSide.none,
                        ),
                        contentPadding: const EdgeInsets.all(16),
                      ),
                      validator: (value) {
                        if (value == null || value.trim().length < 2) {
                          return 'Please enter at least 2 characters';
                        }
                        return null;
                      },
                    ),

                    const SizedBox(height: 16),

                    // Tags input
                    Row(
                      children: [
                        Expanded(
                          child: TextFormField(
                            controller: _tagController,
                            style: const TextStyle(color: Colors.white),
                            decoration: InputDecoration(
                              hintText: 'Add a tag (optional)',
                              hintStyle: TextStyle(color: Colors.grey[400]),
                              filled: true,
                              fillColor: const Color(0xFF262626),
                              border: OutlineInputBorder(
                                borderRadius: BorderRadius.circular(12),
                                borderSide: BorderSide.none,
                              ),
                              contentPadding: const EdgeInsets.symmetric(
                                horizontal: 16,
                                vertical: 12,
                              ),
                              suffixIcon: IconButton(
                                icon: const Icon(
                                  Icons.add_circle,
                                  color: Colors.grey,
                                ),
                                onPressed: _addTag,
                              ),
                            ),
                            onFieldSubmitted: (_) => _addTag(),
                          ),
                        ),
                      ],
                    ),

                    // Tags display
                    if (_tags.isNotEmpty)
                      Container(
                        margin: const EdgeInsets.only(top: 12),
                        height: 32,
                        child: ListView.builder(
                          scrollDirection: Axis.horizontal,
                          itemCount: _tags.length,
                          itemBuilder: (context, index) {
                            return Container(
                              margin: const EdgeInsets.only(right: 8),
                              child: Chip(
                                backgroundColor: Colors.orangeAccent
                                    .withOpacity(0.3),
                                label: Text(
                                  _tags[index],
                                  style: const TextStyle(color: Colors.white),
                                ),
                                deleteIconColor: Colors.white70,
                                onDeleted: () => _removeTag(_tags[index]),
                              ),
                            );
                          },
                        ),
                      ),

                    const SizedBox(height: 24),

                    // Action buttons
                    Row(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        // Cancel button
                        TextButton(
                          onPressed: () => Navigator.of(context).pop(),
                          style: TextButton.styleFrom(
                            foregroundColor: Colors.grey,
                          ),
                          child: const Text('CANCEL'),
                        ),

                        const SizedBox(width: 16),

                        // Save button
                        ElevatedButton(
                          autofocus: widget.autofocusSave,
                          onPressed: _isSaveEnabled && state is! AddCardLoading
                              ? () {
                                  if (_formKey.currentState?.validate() ??
                                      false) {
                                    // Mark that user initiated this save action
                                    _userInitiatedSave = true;

                                    context.read<AddCardBloc>().add(
                                      AddTextCardRequested(
                                        content: _textController.text.trim(),
                                        tags: _tags,
                                      ),
                                    );
                                  }
                                }
                              : null,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: Colors.orangeAccent,
                            disabledBackgroundColor: Colors.grey,
                            foregroundColor: Colors.white,
                            padding: const EdgeInsets.symmetric(
                              horizontal: 24,
                              vertical: 12,
                            ),
                          ),
                          child: state is AddCardLoading
                              ? const SizedBox(
                                  width: 20,
                                  height: 20,
                                  child: CircularProgressIndicator(
                                    strokeWidth: 2,
                                    valueColor: AlwaysStoppedAnimation<Color>(
                                      Colors.white,
                                    ),
                                  ),
                                )
                              : const Text('SAVE'),
                        ),
                      ],
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\add_text_card_to_space_modal.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:provider/provider.dart';

import '../../../data/repository/card_repository.dart';
import '../../../data/card_entity.dart';

class AddTextCardToSpaceModal extends StatefulWidget {
  final String? initialText;
  final bool autofocusSave;
  final int spaceId;

  const AddTextCardToSpaceModal({
    super.key,
    this.initialText,
    this.autofocusSave = false,
    required this.spaceId,
  });

  @override
  State<AddTextCardToSpaceModal> createState() =>
      _AddTextCardToSpaceModalState();
}

class _AddTextCardToSpaceModalState extends State<AddTextCardToSpaceModal> {
  late final TextEditingController _textController;
  final _formKey = GlobalKey<FormState>();
  bool _isSaveEnabled = false;
  bool _isLoading = false;

  @override
  void initState() {
    super.initState();
    _textController = TextEditingController(text: widget.initialText ?? '');
    _textController.addListener(_validateInput);
    if (widget.initialText != null && widget.initialText!.trim().isNotEmpty) {
      _isSaveEnabled = true;
    }
  }

  @override
  void dispose() {
    _textController.removeListener(_validateInput);
    _textController.dispose();
    super.dispose();
  }

  void _validateInput() {
    final isValid = _textController.text.trim().length >= 2;
    if (isValid != _isSaveEnabled) {
      setState(() {
        _isSaveEnabled = isValid;
      });
    }
  }

  Future<void> _saveCard() async {
    if (!_formKey.currentState!.validate() || _isLoading) return;

    setState(() {
      _isLoading = true;
    });

    try {
      final cardRepository = context.read<CardRepository>();
      final now = DateTime.now().millisecondsSinceEpoch;

      final card = CardEntity(
        type: 'text',
        content: _textController.text.trim().split('\n').first,
        body: _textController.text.trim(),
        spaceId: widget.spaceId,
        createdAt: now,
        updatedAt: now,
      );

      await cardRepository.addCard(card);

      if (mounted) {
        Navigator.of(context).pop(true);
      }
    } catch (e) {
      if (mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error: ${e.toString()}'),
            backgroundColor: Colors.red,
            behavior: SnackBarBehavior.floating,
          ),
        );
        setState(() {
          _isLoading = false;
        });
      }
    }
  }

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: EdgeInsets.only(
        bottom: MediaQuery.of(context).viewInsets.bottom,
      ),
      decoration: const BoxDecoration(
        color: Color(0xFF1A1A1A),
        borderRadius: BorderRadius.vertical(top: Radius.circular(16)),
      ),
      child: Form(
        key: _formKey,
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [_buildHeader(), _buildTextForm(), _buildFooter()],
        ),
      ),
    );
  }

  Widget _buildHeader() {
    return Container(
      padding: const EdgeInsets.all(16),
      decoration: const BoxDecoration(
        border: Border(bottom: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        children: [
          const Icon(Icons.text_fields, color: Colors.white),
          const SizedBox(width: 16),
          const Text(
            'Add Text Note to Space',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              fontWeight: FontWeight.w600,
            ),
          ),
          const Spacer(),
          IconButton(
            icon: const Icon(Icons.close, color: Colors.white70),
            onPressed: () => Navigator.of(context).pop(),
          ),
        ],
      ),
    );
  }

  Widget _buildTextForm() {
    return Padding(
      padding: const EdgeInsets.all(16),
      child: Column(
        children: [
          TextFormField(
            controller: _textController,
            maxLines: 10,
            minLines: 5,
            autofocus: true,
            style: const TextStyle(color: Colors.white),
            decoration: const InputDecoration(
              hintText: 'Enter your note...',
              hintStyle: TextStyle(color: Colors.grey),
              border: OutlineInputBorder(),
              focusedBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Colors.blueAccent),
              ),
              enabledBorder: OutlineInputBorder(
                borderSide: BorderSide(color: Color(0xFF303030)),
              ),
              contentPadding: EdgeInsets.all(16),
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildFooter() {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 16),
      decoration: const BoxDecoration(
        border: Border(top: BorderSide(color: Color(0xFF303030), width: 1)),
      ),
      child: Row(
        mainAxisAlignment: MainAxisAlignment.end,
        children: [
          ElevatedButton(
            onPressed: () => Navigator.of(context).pop(),
            style: ElevatedButton.styleFrom(
              backgroundColor: const Color(0xFF303030),
            ),
            child: const Text('Cancel'),
          ),
          const SizedBox(width: 16),
          ElevatedButton(
            onPressed: !_isSaveEnabled || _isLoading
                ? null
                : () {
                    if (_formKey.currentState!.validate()) {
                      HapticFeedback.mediumImpact();
                      _saveCard();
                    }
                  },
            style: ElevatedButton.styleFrom(
              backgroundColor: Colors.blueAccent,
              disabledBackgroundColor: Colors.blueAccent.withOpacity(0.3),
            ),
            child: _isLoading
                ? const SizedBox(
                    width: 20,
                    height: 20,
                    child: CircularProgressIndicator(
                      valueColor: AlwaysStoppedAnimation<Color>(Colors.white),
                      strokeWidth: 2,
                    ),
                  )
                : const Text('Save'),
          ),
        ],
      ),
    );
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\card\card_tile.dart
=========================================
--- Content Start ---


--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\grid ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\card_tile.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'dart:ui';
import 'dart:math' as math;
import 'package:animations/animations.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../../data/card_entity.dart';
import '../../../data/repository/card_repository.dart';
import '../../../ui/screens/card_detail_screen.dart';
import '../../../ui/theme/app_theme.dart';
import '../../../ui/widgets/overlay/card_preview_overlay.dart';

class CardTile extends StatefulWidget {
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const CardTile({super.key, required this.card, this.onTap, this.onDelete});

  @override
  State<CardTile> createState() => _CardTileState();
}

class _CardTileState extends State<CardTile>
    with SingleTickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 120),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.98).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  // Show card preview overlay on long press
  void _showCardPreview(BuildContext context) {
    showCardPreviewOverlay(
      context: context,
      card: widget.card,
      onEdit: () {
        // For now, just open the detail screen which has edit functionality
        if (widget.card.id != null) {
          Navigator.of(context).push(
            MaterialPageRoute(
              builder: (_) => CardDetailScreen(cardId: widget.card.id!),
            ),
          );
        }
      },
      cardRepository: CardRepository(),
    );
  }

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: _scaleAnimation,
      builder: (context, child) {
        return Transform.scale(scale: _scaleAnimation.value, child: child);
      },
      child: OpenContainer(
        transitionType: ContainerTransitionType.fadeThrough,
        transitionDuration: const Duration(milliseconds: 300),
        closedShape: RoundedRectangleBorder(
          borderRadius: BorderRadius.circular(16.0),
        ),
        closedColor: AppTheme.surfaceVariantColor,
        closedElevation: 2,
        openElevation: 0,
        openBuilder: (context, _) => widget.card.id != null
            ? CardDetailScreen(cardId: widget.card.id!)
            : const SizedBox(),
        closedBuilder: (context, openContainer) {
          final VoidCallback opener = openContainer;
          return GestureDetector(
            onTapDown: (_) => _scaleController.forward(),
            onTapUp: (_) => _scaleController.reverse(),
            onTapCancel: () => _scaleController.reverse(),
            onLongPress: () => _showCardPreview(context),
            child: Material(
              color: Colors.transparent,
              child: InkWell(
                onTap: widget.onTap ?? opener,
                borderRadius: BorderRadius.circular(16),
                splashColor: Colors.white10,
                highlightColor: Colors.white10,
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    // Thumbnail area with better aspect ratio
                    AspectRatio(
                      aspectRatio: 4 / 3,
                      child: Container(
                        decoration: BoxDecoration(
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                          color: Colors.black,
                        ),
                        child: ClipRRect(
                          borderRadius: const BorderRadius.only(
                            topLeft: Radius.circular(16),
                            topRight: Radius.circular(16),
                          ),
                          child: Stack(
                            fit: StackFit.expand,
                            children: [
                              // Thumbnail or placeholder
                              _buildThumbnail(),

                              // Gradient overlay for better readability
                              Positioned.fill(
                                child: DecoratedBox(
                                  decoration: BoxDecoration(
                                    gradient: LinearGradient(
                                      begin: Alignment.topCenter,
                                      end: Alignment.bottomCenter,
                                      colors: [
                                        Colors.transparent,
                                        Colors.black.withOpacity(0.6),
                                      ],
                                      stops: const [0.7, 1.0],
                                    ),
                                  ),
                                ),
                              ),

                              // Card type indicator
                              Positioned(
                                top: 8,
                                left: 8,
                                child: _buildTypeIndicator(),
                              ),

                              // Play icon overlay for videos
                              if (widget.card.type == 'video')
                                const Center(
                                  child: CircleAvatar(
                                    backgroundColor: Colors.black45,
                                    radius: 24,
                                    child: Icon(
                                      Icons.play_arrow,
                                      color: Colors.white,
                                      size: 32,
                                    ),
                                  ),
                                ),

                              // Delete button (top-right)
                              if (widget.onDelete != null)
                                Positioned(
                                  top: 8,
                                  right: 8,
                                  child: GestureDetector(
                                    onTap: widget.onDelete,
                                    child: Container(
                                      padding: const EdgeInsets.all(6),
                                      decoration: BoxDecoration(
                                        color: Colors.black.withOpacity(0.6),
                                        shape: BoxShape.circle,
                                        boxShadow: [
                                          BoxShadow(
                                            color: Colors.black.withOpacity(
                                              0.3,
                                            ),
                                            blurRadius: 4,
                                          ),
                                        ],
                                      ),
                                      child: const Icon(
                                        Icons.delete_outline,
                                        size: 16,
                                        color: Colors.white,
                                      ),
                                    ),
                                  ),
                                ),
                            ],
                          ),
                        ),
                      ),
                    ),

                    // Content info area
                    Padding(
                      padding: const EdgeInsets.all(12),
                      child: Column(
                        crossAxisAlignment: CrossAxisAlignment.start,
                        mainAxisSize: MainAxisSize.min,
                        children: [
                          Text(
                            widget.card.content,
                            maxLines: 1,
                            overflow: TextOverflow.ellipsis,
                            style: const TextStyle(
                              color: Colors.white,
                              fontWeight: FontWeight.w500,
                              fontSize: 15,
                            ),
                          ),
                          const SizedBox(height: 4),
                          Row(
                            children: [
                              _buildTypeIcon(),
                              const SizedBox(width: 6),
                              Text(
                                _getFormattedDate(),
                                style: TextStyle(
                                  color: Colors.grey[400],
                                  fontSize: 12,
                                ),
                              ),
                            ],
                          ),
                        ],
                      ),
                    ),
                  ],
                ),
              ),
            ),
          );
        },
      ),
    );
  }

  Widget _buildThumbnail() {
    // Don't use setState at all during build - we'll just render directly
    // The loading state will be updated separately after the widget is built

    print(
      'CardTile: Building thumbnail for card type: ${widget.card.type}, ID: ${widget.card.id}',
    );

    // For images
    if (widget.card.type == 'image') {
      print('CardTile: Found image card, image path: ${widget.card.imagePath}');

      if (widget.card.imagePath != null && widget.card.imagePath!.isNotEmpty) {
        // Log the attempt to load the image
        print(
          'CardTile: Attempting to load image from: ${widget.card.imagePath}',
        );

        // Trigger async verification without blocking the UI
        _verifyImageFile(widget.card.imagePath!);

        // Check synchronously if file exists before trying to load
        final file = File(widget.card.imagePath!);
        if (!widget.card.imagePath!.startsWith('http') && !file.existsSync()) {
          print(
            'CardTile: Image file does not exist at: ${widget.card.imagePath}',
          );
          return _buildPlaceholderWithIcon(Icons.image_not_supported);
        }

        // File exists or is remote, try to display it
        return _buildImageWidget(widget.card.imagePath!);
      } else {
        print('CardTile: WARNING - Image card has null or empty imagePath!');
        return _buildPlaceholderWithIcon(Icons.image_not_supported);
      }
    } // For videos (just showing thumbnail)
    if (widget.card.type == 'video' && widget.card.imagePath != null) {
      return _buildImageWidget(widget.card.imagePath!);
    }

    // For links with preview image
    if (widget.card.type == 'link' && widget.card.url != null) {
      if (widget.card.imagePath != null) {
        return _buildImageWidget(widget.card.imagePath!);
      }

      // Link without image - placeholder with link icon
      return _buildPlaceholderWithIcon(Icons.link);
    }

    // For text cards - show text snippet on gradient background
    if (widget.card.type == 'text') {
      return Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              AppTheme.primaryColor.withOpacity(0.7),
              AppTheme.primaryColor,
            ],
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              widget.card.body?.substring(
                    0,
                    widget.card.body!.length > 50
                        ? 50
                        : widget.card.body!.length,
                  ) ??
                  widget.card.content,
              maxLines: 4,
              textAlign: TextAlign.center,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 15,
                fontWeight: FontWeight.w400,
              ),
            ),
          ),
        ),
      );
    }

    // Default placeholder
    return _buildPlaceholderWithIcon(Icons.note);
  }

  // Verify image file exists and log the result
  Future<void> _verifyImageFile(String path) async {
    try {
      final file = File(path);
      final exists = await file.exists();
      print('CardTile: Image file exists? $exists at path: $path');
      if (!exists) {
        print('CardTile: WARNING - Image file not found: $path');
      } else {
        final size = await file.length();
        print('CardTile: Image file size: ${size / 1024}KB');
      }
    } catch (e) {
      print('CardTile: Error checking image file: $e');
    }
  }

  Widget _buildImageWidget(String path) {
    print('CardTile: Attempting to display image from path: $path');

    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      print('CardTile: Loading remote image');
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.cover,
        placeholder: (context, url) => _buildShimmerEffect(),
        errorWidget: (context, url, error) {
          print('CardTile: Error loading remote image: $error');
          return _buildPlaceholderWithIcon(Icons.broken_image);
        },
        fadeInDuration: const Duration(milliseconds: 300),
      );
    }

    // Local file
    print('CardTile: Loading local file image');
    try {
      final file = File(path);
      final exists = file.existsSync();
      print('CardTile: File exists? $exists at path: $path');

      // If the file doesn't exist, immediately show the placeholder
      if (!exists) {
        print('CardTile: File does not exist, showing placeholder');
        return _buildPlaceholderWithIcon(Icons.broken_image);
      }

      // Check file size
      final size = file.lengthSync();
      print('CardTile: File size: ${size / 1024}KB');

      if (size == 0) {
        print('CardTile: File is empty, showing placeholder');
        return _buildPlaceholderWithIcon(Icons.broken_image);
      }

      // Attempt to load the image file
      return Image.file(
        file,
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          print('CardTile: Error loading local image: $error');
          return _buildPlaceholderWithIcon(Icons.broken_image);
        },
        frameBuilder: (context, child, frame, wasSynchronouslyLoaded) {
          if (frame == null) {
            return _buildShimmerEffect(); // Show shimmer while loading
          }
          return child; // Show the image once loaded
        },
      );
    } catch (e) {
      print('CardTile: Exception loading local image: $e');
      return _buildPlaceholderWithIcon(Icons.broken_image);
    }
  }

  Widget _buildShimmerEffect() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[800]!,
      highlightColor: Colors.grey[700]!,
      child: Container(color: Colors.grey[800]),
    );
  }

  Widget _buildPlaceholderWithIcon(IconData icon) {
    return Container(
      color: AppTheme.surfaceVariantColor,
      child: Center(child: Icon(icon, size: 42, color: Colors.grey[400])),
    );
  }

  String _getFormattedDate() {
    final date = DateTime.fromMillisecondsSinceEpoch(widget.card.createdAt);
    final now = DateTime.now();

    // Today
    if (date.year == now.year &&
        date.month == now.month &&
        date.day == now.day) {
      return 'Today ${_formatTime(date)}';
    }

    // Yesterday
    final yesterday = now.subtract(const Duration(days: 1));
    if (date.year == yesterday.year &&
        date.month == yesterday.month &&
        date.day == yesterday.day) {
      return 'Yesterday ${_formatTime(date)}';
    }

    // Within a week
    if (now.difference(date).inDays < 7) {
      return '${_getDayName(date)} ${_formatTime(date)}';
    }

    // Older
    return '${date.day}/${date.month}/${date.year}';
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  String _getDayName(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Mon';
      case 2:
        return 'Tue';
      case 3:
        return 'Wed';
      case 4:
        return 'Thu';
      case 5:
        return 'Fri';
      case 6:
        return 'Sat';
      case 7:
        return 'Sun';
      default:
        return '';
    }
  }

  Widget _buildTypeIndicator() {
    Color backgroundColor;
    String label;

    switch (widget.card.type) {
      case 'image':
        backgroundColor = Colors.blue.withOpacity(0.8);
        label = 'IMAGE';
        break;
      case 'video':
        backgroundColor = Colors.red.withOpacity(0.8);
        label = 'VIDEO';
        break;
      case 'link':
        backgroundColor = Colors.purple.withOpacity(0.8);
        label = 'LINK';
        break;
      case 'text':
        backgroundColor = AppTheme.primaryColor.withOpacity(0.8);
        label = 'TEXT';
        break;
      default:
        backgroundColor = Colors.grey.withOpacity(0.8);
        label = 'NOTE';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 3),
        ],
      ),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildTypeIcon() {
    IconData iconData;
    Color iconColor;

    switch (widget.card.type) {
      case 'image':
        iconData = Icons.image_outlined;
        iconColor = Colors.blue;
        break;
      case 'video':
        iconData = Icons.videocam_outlined;
        iconColor = Colors.red;
        break;
      case 'link':
        iconData = Icons.link;
        iconColor = Colors.purple;
        break;
      case 'text':
        iconData = Icons.text_snippet_outlined;
        iconColor = AppTheme.primaryColor;
        break;
      default:
        iconData = Icons.note_outlined;
        iconColor = Colors.grey;
    }

    return Icon(iconData, size: 12, color: iconColor);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\card_tile_new.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'dart:ui';
import 'package:animations/animations.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:flutter/material.dart';
import 'package:shimmer/shimmer.dart';
import '../../../data/card_entity.dart';
import '../../../services/youtube_service.dart';
import '../../../ui/screens/card_detail_screen.dart';
import '../../../ui/theme/app_theme.dart';

class CardTile extends StatefulWidget {
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const CardTile({super.key, required this.card, this.onTap, this.onDelete});

  @override
  State<CardTile> createState() => _CardTileState();
}

class _CardTileState extends State<CardTile>
    with SingleTickerProviderStateMixin {
  late AnimationController _scaleController;
  late Animation<double> _scaleAnimation;

  @override
  void initState() {
    super.initState();
    _scaleController = AnimationController(
      duration: const Duration(milliseconds: 120),
      vsync: this,
    );
    _scaleAnimation = Tween<double>(begin: 1.0, end: 0.98).animate(
      CurvedAnimation(parent: _scaleController, curve: Curves.easeInOut),
    );
  }

  @override
  void dispose() {
    _scaleController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    // Create a stateless wrapper around OpenContainer to avoid setState during build
    return _StatelessCardWrapper(
      scaleAnimation: _scaleAnimation,
      scaleController: _scaleController,
      card: widget.card,
      onTap: widget.onTap,
      onDelete: widget.onDelete,
    );
  }
}

// Stateless wrapper to avoid setState during build issues
class _StatelessCardWrapper extends StatelessWidget {
  final Animation<double> scaleAnimation;
  final AnimationController scaleController;
  final CardEntity card;
  final VoidCallback? onTap;
  final VoidCallback? onDelete;

  const _StatelessCardWrapper({
    required this.scaleAnimation,
    required this.scaleController,
    required this.card,
    this.onTap,
    this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return AnimatedBuilder(
      animation: scaleAnimation,
      builder: (context, child) {
        return Transform.scale(scale: scaleAnimation.value, child: child);
      },
      child: _buildOpenContainer(context),
    );
  }

  Widget _buildOpenContainer(BuildContext context) {
    return OpenContainer(
      transitionType: ContainerTransitionType.fadeThrough,
      transitionDuration: const Duration(milliseconds: 300),
      closedShape: RoundedRectangleBorder(
        borderRadius: BorderRadius.circular(16.0),
      ),
      closedColor: AppTheme.surfaceVariantColor,
      closedElevation: 2,
      openElevation: 0,
      openBuilder: (context, _) {
        if (card.id != null) {
          return CardDetailScreen(cardId: card.id!);
        }
        return const SizedBox();
      },
      closedBuilder: (context, openContainer) {
        return GestureDetector(
          onTapDown: (_) => scaleController.forward(),
          onTapUp: (_) => scaleController.reverse(),
          onTapCancel: () => scaleController.reverse(),
          child: Material(
            color: Colors.transparent,
            child: InkWell(
              onTap: onTap ?? openContainer,
              borderRadius: BorderRadius.circular(16),
              splashColor: Colors.white10,
              highlightColor: Colors.white10,
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Thumbnail area with better aspect ratio
                  AspectRatio(
                    aspectRatio: 4 / 3,
                    child: Container(
                      decoration: BoxDecoration(
                        borderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(16),
                          topRight: Radius.circular(16),
                        ),
                        color: Colors.black,
                      ),
                      child: ClipRRect(
                        borderRadius: const BorderRadius.only(
                          topLeft: Radius.circular(16),
                          topRight: Radius.circular(16),
                        ),
                        child: Stack(
                          fit: StackFit.expand,
                          children: [
                            // Thumbnail or placeholder
                            _buildThumbnail(),

                            // Gradient overlay for better readability
                            Positioned.fill(
                              child: DecoratedBox(
                                decoration: BoxDecoration(
                                  gradient: LinearGradient(
                                    begin: Alignment.topCenter,
                                    end: Alignment.bottomCenter,
                                    colors: [
                                      Colors.transparent,
                                      Colors.black.withOpacity(0.6),
                                    ],
                                    stops: const [0.7, 1.0],
                                  ),
                                ),
                              ),
                            ),

                            // Card type indicator (top-left corner)
                            Positioned(
                              top: 8,
                              left: 8,
                              child: _buildTypeIndicator(),
                            ),

                            // Play icon overlay for videos
                            if (card.type == 'video')
                              const Center(
                                child: CircleAvatar(
                                  backgroundColor: Colors.black45,
                                  radius: 24,
                                  child: Icon(
                                    Icons.play_arrow,
                                    color: Colors.white,
                                    size: 32,
                                  ),
                                ),
                              ),

                            // Delete button (positioned in top-right corner)
                            if (onDelete != null)
                              Positioned(
                                top: 8,
                                right: 8,
                                child: GestureDetector(
                                  onTap: onDelete,
                                  child: Container(
                                    padding: const EdgeInsets.all(6),
                                    decoration: BoxDecoration(
                                      color: Colors.black.withOpacity(0.6),
                                      shape: BoxShape.circle,
                                      boxShadow: [
                                        BoxShadow(
                                          color: Colors.black.withOpacity(0.3),
                                          blurRadius: 4,
                                        ),
                                      ],
                                    ),
                                    child: const Icon(
                                      Icons.delete_outline,
                                      size: 16,
                                      color: Colors.white,
                                    ),
                                  ),
                                ),
                              ),
                          ],
                        ),
                      ),
                    ),
                  ),

                  // Content info area with better styling
                  Padding(
                    padding: const EdgeInsets.all(12),
                    child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      mainAxisSize: MainAxisSize.min,
                      children: [
                        // Card title with ellipsis
                        Text(
                          card.content,
                          maxLines: 1,
                          overflow: TextOverflow.ellipsis,
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w500,
                            fontSize: 15,
                          ),
                        ),

                        // Optional subtext (date)
                        const SizedBox(height: 4),
                        Row(
                          children: [
                            _buildTypeIcon(),
                            const SizedBox(width: 6),
                            Text(
                              _getFormattedDate(),
                              style: TextStyle(
                                color: Colors.grey[400],
                                fontSize: 12,
                              ),
                            ),
                          ],
                        ),
                      ],
                    ),
                  ),
                ],
              ),
            ),
          ),
        );
      },
    );
  }

  Widget _buildThumbnail() {
    // For images
    if (card.type == 'image' && card.imagePath != null) {
      return _buildImageWidget(card.imagePath!);
    }

    // For videos (just showing thumbnail)
    if (card.type == 'video' && card.imagePath != null) {
      return _buildImageWidget(card.imagePath!);
    }

    // For links with preview image
    if (card.type == 'link' && card.url != null) {
      // YouTube link with thumbnail
      final youtubeService = YouTubeService(
  apiKey: 'REDACTED_API_KEY',
      );
      if (youtubeService.isYoutubeUrl(card.url!)) {
        // YouTube link indicator
        if (card.imagePath != null) {
          // Just display the thumbnail without the play button overlay
          return _buildImageWidget(card.imagePath!);
        }
      }

      // Regular link with image
      if (card.imagePath != null) {
        return _buildImageWidget(card.imagePath!);
      }

      // Link without image - placeholder with link icon
      return _buildPlaceholderWithIcon(Icons.link);
    }

    // For text cards - show text snippet on gradient background
    if (card.type == 'text') {
      return Container(
        decoration: BoxDecoration(
          gradient: LinearGradient(
            begin: Alignment.topCenter,
            end: Alignment.bottomCenter,
            colors: [
              AppTheme.primaryColor.withOpacity(0.7),
              AppTheme.primaryColor,
            ],
          ),
        ),
        child: Center(
          child: Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              card.body?.substring(
                    0,
                    card.body!.length > 50 ? 50 : card.body!.length,
                  ) ??
                  card.content,
              maxLines: 4,
              textAlign: TextAlign.center,
              overflow: TextOverflow.ellipsis,
              style: const TextStyle(
                color: Colors.white,
                fontSize: 15,
                fontWeight: FontWeight.w400,
              ),
            ),
          ),
        ),
      );
    }

    // Default placeholder
    return _buildPlaceholderWithIcon(Icons.note);
  }

  Widget _buildImageWidget(String path) {
    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.cover,
        placeholder: (context, url) => _buildShimmerEffect(),
        errorWidget: (context, url, error) =>
            _buildPlaceholderWithIcon(Icons.broken_image),
        fadeInDuration: const Duration(milliseconds: 300),
      );
    }

    // Local file
    try {
      return Image.file(
        File(path),
        fit: BoxFit.cover,
        errorBuilder: (context, error, stackTrace) {
          return _buildPlaceholderWithIcon(Icons.broken_image);
        },
      );
    } catch (e) {
      return _buildPlaceholderWithIcon(Icons.broken_image);
    }
  }

  Widget _buildShimmerEffect() {
    return Shimmer.fromColors(
      baseColor: Colors.grey[800]!,
      highlightColor: Colors.grey[700]!,
      child: Container(color: Colors.grey[800]),
    );
  }

  Widget _buildPlaceholderWithIcon(IconData icon) {
    return Container(
      color: AppTheme.surfaceVariantColor,
      child: Center(child: Icon(icon, size: 42, color: Colors.grey[400])),
    );
  }

  String _getFormattedDate() {
    final date = DateTime.fromMillisecondsSinceEpoch(card.createdAt);
    final now = DateTime.now();

    // Today
    if (date.year == now.year &&
        date.month == now.month &&
        date.day == now.day) {
      return 'Today ${_formatTime(date)}';
    }

    // Yesterday
    final yesterday = now.subtract(const Duration(days: 1));
    if (date.year == yesterday.year &&
        date.month == yesterday.month &&
        date.day == yesterday.day) {
      return 'Yesterday ${_formatTime(date)}';
    }

    // Within a week
    if (now.difference(date).inDays < 7) {
      return '${_getDayName(date)} ${_formatTime(date)}';
    }

    // Older
    return '${date.day}/${date.month}/${date.year}';
  }

  String _formatTime(DateTime date) {
    final hour = date.hour.toString().padLeft(2, '0');
    final minute = date.minute.toString().padLeft(2, '0');
    return '$hour:$minute';
  }

  String _getDayName(DateTime date) {
    switch (date.weekday) {
      case 1:
        return 'Mon';
      case 2:
        return 'Tue';
      case 3:
        return 'Wed';
      case 4:
        return 'Thu';
      case 5:
        return 'Fri';
      case 6:
        return 'Sat';
      case 7:
        return 'Sun';
      default:
        return '';
    }
  }

  Widget _buildTypeIndicator() {
    Color backgroundColor;
    String label;

    switch (card.type) {
      case 'image':
        backgroundColor = Colors.blue.withOpacity(0.8);
        label = 'IMAGE';
        break;
      case 'video':
        backgroundColor = Colors.red.withOpacity(0.8);
        label = 'VIDEO';
        break;
      case 'link':
        backgroundColor = Colors.purple.withOpacity(0.8);
        label = 'LINK';
        break;
      case 'text':
        backgroundColor = AppTheme.primaryColor.withOpacity(0.8);
        label = 'TEXT';
        break;
      default:
        backgroundColor = Colors.grey.withOpacity(0.8);
        label = 'NOTE';
    }

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: backgroundColor,
        borderRadius: BorderRadius.circular(4),
        boxShadow: [
          BoxShadow(color: Colors.black.withOpacity(0.3), blurRadius: 3),
        ],
      ),
      child: Text(
        label,
        style: const TextStyle(
          color: Colors.white,
          fontSize: 10,
          fontWeight: FontWeight.bold,
          letterSpacing: 0.5,
        ),
      ),
    );
  }

  Widget _buildTypeIcon() {
    IconData iconData;
    Color iconColor;

    switch (card.type) {
      case 'image':
        iconData = Icons.image_outlined;
        iconColor = Colors.blue;
        break;
      case 'video':
        iconData = Icons.videocam_outlined;
        iconColor = Colors.red;
        break;
      case 'link':
        iconData = Icons.link;
        iconColor = Colors.purple;
        break;
      case 'text':
        iconData = Icons.text_snippet_outlined;
        iconColor = AppTheme.primaryColor;
        break;
      default:
        iconData = Icons.note_outlined;
        iconColor = Colors.grey;
    }

    return Icon(iconData, size: 12, color: iconColor);
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\focusable_card_tile.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\grid\main_grid_view.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import 'package:shimmer/shimmer.dart';

import '../../../bloc/main_grid/main_grid_bloc.dart';
import '../../../bloc/main_grid/main_grid_event.dart';
import '../../../bloc/main_grid/main_grid_state.dart';
import '../../../data/card_entity.dart';
import '../../../ui/theme/app_theme.dart';
// Use the new implementation to fix setState during build issues
import 'card_tile_new.dart';

class MainGridView extends StatefulWidget {
  const MainGridView({super.key});

  @override
  State<MainGridView> createState() => _MainGridViewState();
}

class _MainGridViewState extends State<MainGridView> {
  final _scrollController = ScrollController();
  bool _isBottomLoading = false;

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_isNearBottom && !_isBottomLoading) {
      setState(() => _isBottomLoading = true);
      context.read<MainGridBloc>().add(const LoadMoreCards());
      Future.delayed(const Duration(seconds: 1), () {
        if (mounted) setState(() => _isBottomLoading = false);
      });
    }
  }

  bool get _isNearBottom {
    if (!_scrollController.hasClients) return false;
    final maxScroll = _scrollController.position.maxScrollExtent;
    final currentScroll = _scrollController.offset;
    // Load more when reached 80% of the scroll
    return currentScroll >= (maxScroll * 0.8);
  }

  @override
  Widget build(BuildContext context) {
    return BlocBuilder<MainGridBloc, MainGridState>(
      builder: (context, state) {
        if (state is MainGridInitial) {
          // Trigger loading when first built
          context.read<MainGridBloc>().add(const LoadCards());
          return _buildLoadingView();
        } else if (state is MainGridLoading && state.isFirstLoad) {
          return _buildLoadingView();
        } else if (state is MainGridError) {
          return _buildErrorView(state.message);
        } else if (state is MainGridLoaded) {
          return _buildGridView(state);
        }

        // Fallback for any other state
        return _buildLoadingView();
      },
    );
  }

  Widget _buildLoadingView() {
    // Calculate columns based on screen width (3 columns for tablets, 4 for large screens)
    final width = MediaQuery.of(context).size.width;
    final crossAxisCount = width > 1200
        ? 4
        : width > 600
        ? 3
        : 2;

    return Container(
      color: AppTheme.surfaceColor,
      child: CustomScrollView(
        slivers: [
          // Shimmer header
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.fromLTRB(16, 16, 16, 4),
              child: Shimmer.fromColors(
                baseColor: AppTheme.cardColor,
                highlightColor: AppTheme.cardColor.withOpacity(0.5),
                child: Container(
                  height: 48,
                  decoration: BoxDecoration(
                    color: Colors.white24,
                    borderRadius: BorderRadius.circular(8),
                  ),
                ),
              ),
            ),
          ),

          // Shimmer grid of loading cards
          SliverPadding(
            padding: const EdgeInsets.all(12.0),
            sliver: SliverGrid(
              gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                crossAxisCount: crossAxisCount,
                childAspectRatio: 0.7,
                mainAxisSpacing: 12.0,
                crossAxisSpacing: 12.0,
              ),
              delegate: SliverChildBuilderDelegate(
                (context, index) {
                  return Shimmer.fromColors(
                    baseColor: AppTheme.cardColor,
                    highlightColor: AppTheme.cardColor.withOpacity(0.5),
                    child: Container(
                      decoration: BoxDecoration(
                        color: Colors.white24,
                        borderRadius: BorderRadius.circular(12),
                      ),
                    ),
                  );
                },
                childCount:
                    crossAxisCount * 4, // Show 4 rows of shimmering cards
              ),
            ),
          ),

          // Add loading indicator at bottom
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.all(24.0),
              child: Center(
                child: Column(
                  children: [
                    const SizedBox(
                      width: 32,
                      height: 32,
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(
                          AppTheme.primaryColor,
                        ),
                        strokeWidth: 2.5,
                      ),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Loading your cards...',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              ),
            ),
          ),

          // Bottom padding for navigation
          const SliverToBoxAdapter(child: SizedBox(height: 80)),
        ],
      ),
    );
  }

  Widget _buildErrorView(String message) {
    return Container(
      color: AppTheme.surfaceColor,
      child: Center(
        child: Padding(
          padding: const EdgeInsets.all(24.0),
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: [
              // Animated error icon with a subtle bounce effect
              TweenAnimationBuilder<double>(
                tween: Tween<double>(begin: 0.0, end: 1.0),
                duration: const Duration(milliseconds: 500),
                curve: Curves.elasticOut,
                builder: (context, value, child) {
                  return Transform.scale(
                    scale: value,
                    child: Container(
                      padding: const EdgeInsets.all(16),
                      decoration: BoxDecoration(
                        color: AppTheme.errorColor.withOpacity(0.2),
                        shape: BoxShape.circle,
                      ),
                      child: const Icon(
                        Icons.error_outline_rounded,
                        color: AppTheme.errorColor,
                        size: 48,
                      ),
                    ),
                  );
                },
              ),
              const SizedBox(height: 24),
              Text(
                'Error',
                style: Theme.of(
                  context,
                ).textTheme.titleLarge?.copyWith(color: AppTheme.errorColor),
              ),
              const SizedBox(height: 8),
              Text(
                message,
                style: Theme.of(
                  context,
                ).textTheme.bodyMedium?.copyWith(color: Colors.white70),
                textAlign: TextAlign.center,
              ),
              const SizedBox(height: 32),
              ElevatedButton.icon(
                style: ElevatedButton.styleFrom(
                  backgroundColor: AppTheme.primaryColor,
                  foregroundColor: Colors.white,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 24,
                    vertical: 12,
                  ),
                  elevation: 4,
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(20),
                  ),
                ),
                onPressed: () {
                  // Add a small haptic feedback if available
                  HapticFeedback.mediumImpact();
                  context.read<MainGridBloc>().add(const LoadCards());
                },
                icon: const Icon(Icons.refresh),
                label: const Text('Try Again'),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGridView(MainGridLoaded state) {
    final cards = state.cards;
    // Calculate columns based on screen width (3 columns for tablets, 4 for large screens)
    final width = MediaQuery.of(context).size.width;
    final crossAxisCount = width > 1200
        ? 4
        : width > 600
        ? 3
        : 2;

    if (cards.isEmpty) {
      return _buildEmptyView(state.isSearchResult);
    }

    return Container(
      color: AppTheme.surfaceColor,
      child: RefreshIndicator(
        color: AppTheme.primaryColor,
        backgroundColor: AppTheme.surfaceVariantColor,
        onRefresh: () async {
          context.read<MainGridBloc>().add(const LoadCards(refresh: true));
          // Wait for refresh to complete
          await Future.delayed(const Duration(milliseconds: 800));
        },
        child: CustomScrollView(
          physics: const AlwaysScrollableScrollPhysics(),
          controller: _scrollController,
          slivers: [
            // Search indicator if showing search results
            if (state.isSearchResult && state.searchQuery != null)
              SliverToBoxAdapter(
                child: Container(
                  color: AppTheme.surfaceVariantColor,
                  padding: const EdgeInsets.symmetric(
                    horizontal: 16.0,
                    vertical: 12.0,
                  ),
                  margin: const EdgeInsets.only(bottom: 8),
                  child: Row(
                    children: [
                      Icon(
                        Icons.search,
                        color: AppTheme.primaryColor,
                        size: 18,
                      ),
                      const SizedBox(width: 12),
                      Expanded(
                        child: Text(
                          'Results for "${state.searchQuery}"',
                          style: const TextStyle(
                            color: Colors.white,
                            fontWeight: FontWeight.w500,
                          ),
                        ),
                      ),
                      IconButton(
                        icon: const Icon(
                          Icons.close,
                          color: Colors.white70,
                          size: 18,
                        ),
                        onPressed: () => context.read<MainGridBloc>().add(
                          const ClearSearch(),
                        ),
                      ),
                    ],
                  ),
                ),
              ),

            // Grid of cards with improved spacing
            SliverPadding(
              padding: const EdgeInsets.all(12.0),
              sliver: SliverGrid(
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: crossAxisCount,
                  childAspectRatio: 0.7, // Card aspect ratio (more vertical)
                  mainAxisSpacing: 12.0,
                  crossAxisSpacing: 12.0,
                ),
                delegate: SliverChildBuilderDelegate(
                  (context, index) => _buildCardItem(cards[index]),
                  childCount: cards.length,
                ),
              ),
            ),

            // Shimmer loading indicator for pagination
            if (!state.hasReachedMax && cards.isNotEmpty)
              SliverToBoxAdapter(
                child: Padding(
                  padding: const EdgeInsets.symmetric(vertical: 20.0),
                  child: Center(
                    child: Shimmer.fromColors(
                      baseColor: Colors.grey[800]!,
                      highlightColor: Colors.grey[700]!,
                      child: Column(
                        children: [
                          Container(
                            width: 160,
                            height: 12,
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                          const SizedBox(height: 8),
                          Container(
                            width: 120,
                            height: 12,
                            decoration: BoxDecoration(
                              color: Colors.white,
                              borderRadius: BorderRadius.circular(8),
                            ),
                          ),
                        ],
                      ),
                    ),
                  ),
                ),
              ),

            // Bottom padding to ensure cards are above bottom navigation bar
            const SliverToBoxAdapter(child: SizedBox(height: 80)),
          ],
        ),
      ),
    );
  }

  Widget _buildEmptyView(bool isSearchResult) {
    return Container(
      color: Theme.of(context).scaffoldBackgroundColor,
      child: Center(
        child: AnimatedSwitcher(
          duration: const Duration(milliseconds: 300),
          switchInCurve: Curves.easeInOut,
          switchOutCurve: Curves.easeInOut,
          child: Column(
            key: ValueKey<bool>(isSearchResult),
            mainAxisSize: MainAxisSize.min,
            children: [
              AnimatedScale(
                scale: 1.0,
                duration: const Duration(milliseconds: 300),
                curve: Curves.elasticOut,
                child: isSearchResult
                    ? Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.search_off,
                          color: AppTheme.primaryColor,
                          size: 64,
                        ),
                      )
                    : Container(
                        padding: const EdgeInsets.all(16),
                        decoration: BoxDecoration(
                          color: Theme.of(context).colorScheme.surface,
                          shape: BoxShape.circle,
                        ),
                        child: const Icon(
                          Icons.photo_library,
                          color: AppTheme.primaryColor,
                          size: 64,
                        ),
                      ),
              ),

              const SizedBox(height: 24),

              Text(
                isSearchResult ? 'No results found' : 'No media cards yet.',
                style: Theme.of(context).textTheme.titleLarge,
              ),

              const SizedBox(height: 12),

              Text(
                isSearchResult
                    ? 'Try a different search term'
                    : 'Tap + to create one.',
                textAlign: TextAlign.center,
                style: Theme.of(context).textTheme.bodyMedium,
              ),

              if (isSearchResult) ...[
                const SizedBox(height: 32),
                ElevatedButton.icon(
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.primaryColor,
                    foregroundColor: AppTheme.onPrimaryColor,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 24,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                  onPressed: () =>
                      context.read<MainGridBloc>().add(const ClearSearch()),
                  icon: const Icon(Icons.clear),
                  label: const Text('Clear Search'),
                ),
              ],
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildCardItem(CardEntity card) {
    return CardTile(
      card: card,
      onTap: () {
        if (card.id != null) {
          Navigator.pushNamed(context, '/cardDetail', arguments: card.id).then((
            result,
          ) {
            if (result == true) {
              // Refresh the grid if card was deleted
              context.read<MainGridBloc>().add(const LoadCards(refresh: true));
            }
          });
        }
      },
      onDelete: () {
        _showDeleteConfirmation(card);
      },
    );
  }

  void _showDeleteConfirmation(CardEntity card) {
    // Get the bloc reference before the dialog
    final mainGridBloc = BlocProvider.of<MainGridBloc>(context);

    showDialog(
      context: context,
      builder: (dialogContext) {
        return BlocProvider.value(
          value: mainGridBloc,
          child: Builder(
            builder: (builderContext) {
              // Ensure we have a proper Material widget ancestor
              return Material(
                type: MaterialType.transparency,
                child: AlertDialog(
                  shape: RoundedRectangleBorder(
                    borderRadius: BorderRadius.circular(16),
                  ),
                  backgroundColor: AppTheme.surfaceVariantColor,
                  title: const Text(
                    'Delete Card',
                    style: TextStyle(
                      color: Colors.white,
                      fontWeight: FontWeight.bold,
                    ),
                    textAlign: TextAlign.center,
                  ),
                  content: Text(
                    'Are you sure you want to delete "${card.content}"?',
                    style: const TextStyle(color: Colors.white70),
                    textAlign: TextAlign.center,
                  ),
                  actions: [
                    TextButton(
                      onPressed: () => Navigator.of(dialogContext).pop(),
                      style: TextButton.styleFrom(foregroundColor: Colors.grey),
                      child: const Text('CANCEL'),
                    ),
                    ElevatedButton(
                      onPressed: () {
                        if (card.id != null) {
                          // Use the builderContext which has access to the provided bloc
                          builderContext.read<MainGridBloc>().add(
                            CardDeleted(card.id!),
                          );
                        }
                        Navigator.of(dialogContext).pop();
                      },
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.redAccent,
                        foregroundColor: Colors.white,
                      ),
                      child: const Text('DELETE'),
                    ),
                  ],
                ),
              );
            },
          ),
        );
      },
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\modals ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_image_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_link_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\modals\add_text_card_modal.dart
=========================================
--- Content Start ---


--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\overlay ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\overlay\card_preview_overlay.dart
=========================================
--- Content Start ---
import 'dart:ui';
import 'dart:io';
import 'package:flutter/material.dart';
import 'package:cached_network_image/cached_network_image.dart';
import 'package:intl/intl.dart';
import '../../../data/card_entity.dart';
import '../../../data/repository/card_repository.dart';
import '../../../ui/theme/app_theme.dart';
import '../../../utils/url_utils.dart';

/// Shows a fullscreen preview overlay when a card is long-pressed
class CardPreviewOverlay extends StatelessWidget {
  final CardEntity card;
  final VoidCallback onEdit;
  final CardRepository cardRepository;

  const CardPreviewOverlay({
    super.key,
    required this.card,
    required this.onEdit,
    required this.cardRepository,
  });

  @override
  Widget build(BuildContext context) {
    return Material(
      type: MaterialType.transparency,
      child: GestureDetector(
        onTap: () => Navigator.of(context).pop(),
        child: Stack(
          children: [
            // Blurred background
            BackdropFilter(
              filter: ImageFilter.blur(sigmaX: 10, sigmaY: 10),
              child: Container(
                color: Colors.black.withOpacity(0.4),
                width: double.infinity,
                height: double.infinity,
              ),
            ),

            // Main content with dismiss behavior
            Center(
              child: GestureDetector(
                onTap: () {},
                child: DismissibleCardPreview(
                  card: card,
                  onDismissed: () => Navigator.of(context).pop(),
                  onEdit: onEdit,
                  cardRepository: cardRepository,
                ),
              ),
            ),
          ],
        ),
      ),
    );
  }
}

class DismissibleCardPreview extends StatelessWidget {
  final CardEntity card;
  final VoidCallback? onDismissed;
  final VoidCallback onEdit;
  final CardRepository cardRepository;

  const DismissibleCardPreview({
    super.key,
    required this.card,
    this.onDismissed,
    required this.onEdit,
    required this.cardRepository,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      // Avoid triggering tap on the parent overlay
      onTap: () {},
      child: Dismissible(
        key: Key('preview-${card.id}'),
        direction: DismissDirection.down,
        onDismissed: (_) {
          if (onDismissed != null) {
            onDismissed!();
          }
        },
        child: Column(
          mainAxisSize: MainAxisSize.min,
          children: [
            // Card Preview Content
            Hero(
              tag: 'card-${card.id}',
              child: Container(
                constraints: BoxConstraints(
                  maxWidth: MediaQuery.of(context).size.width * 0.85,
                  maxHeight: MediaQuery.of(context).size.height * 0.7,
                ),
                decoration: BoxDecoration(
                  color: AppTheme.surfaceVariantColor,
                  borderRadius: BorderRadius.circular(24),
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.3),
                      blurRadius: 15,
                      offset: const Offset(0, 5),
                    ),
                  ],
                ),
                child: ClipRRect(
                  borderRadius: BorderRadius.circular(24),
                  child: _buildCardPreview(context),
                ),
              ),
            ),

            const SizedBox(height: 20),

            // Actions Row
            Row(
              mainAxisSize: MainAxisSize.min,
              children: [
                // Edit button
                ElevatedButton.icon(
                  onPressed: () {
                    Navigator.of(context).pop();
                    onEdit();
                  },
                  icon: const Icon(Icons.edit),
                  label: const Text('Edit'),
                  style: ElevatedButton.styleFrom(
                    backgroundColor: AppTheme.primaryColor,
                    foregroundColor: AppTheme.onPrimaryColor,
                    padding: const EdgeInsets.symmetric(
                      horizontal: 20,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                ),

                const SizedBox(width: 16),

                // Delete button
                OutlinedButton.icon(
                  onPressed: () => _showDeleteConfirmation(context),
                  icon: const Icon(Icons.delete),
                  label: const Text('Delete'),
                  style: OutlinedButton.styleFrom(
                    foregroundColor: Colors.red.shade600,
                    side: BorderSide(color: Colors.red.shade600),
                    padding: const EdgeInsets.symmetric(
                      horizontal: 20,
                      vertical: 12,
                    ),
                    shape: RoundedRectangleBorder(
                      borderRadius: BorderRadius.circular(20),
                    ),
                  ),
                ),
              ],
            ),

            const SizedBox(height: 16),

            // Created date
            Text(
              'Created: ${DateFormat('MMM d, yyyy').format(DateTime.fromMillisecondsSinceEpoch(card.createdAt))}',
              style: TextStyle(color: Colors.grey.shade400, fontSize: 12),
            ),
          ],
        ),
      ),
    );
  }

  // Build the appropriate preview based on card type
  Widget _buildCardPreview(BuildContext context) {
    switch (card.type) {
      case 'text':
        return _buildTextCardPreview(context);
      case 'image':
        return _buildImageCardPreview(context);
      case 'link':
        return _buildLinkCardPreview(context);
      default:
        return _buildTextCardPreview(context);
    }
  }

  // Text card preview
  Widget _buildTextCardPreview(BuildContext context) {
    return Container(
      width: double.infinity,
      padding: const EdgeInsets.all(24),
      child: SingleChildScrollView(
        child: Text(
          card.content,
          style: const TextStyle(
            fontSize: 18,
            color: Colors.white,
            height: 1.5,
          ),
        ),
      ),
    );
  }

  // Image card preview
  Widget _buildImageCardPreview(BuildContext context) {
    final imagePath = card.imagePath;

    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.7,
      ),
      child: SingleChildScrollView(
        physics: const ClampingScrollPhysics(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Image
            if (imagePath != null && imagePath.isNotEmpty)
              _buildImageWidget(imagePath)
            else
              const SizedBox(
                height: 240,
                child: Center(
                  child: Icon(
                    Icons.image_not_supported,
                    size: 64,
                    color: Colors.grey,
                  ),
                ),
              ),

            // Caption if any
            Padding(
              padding: const EdgeInsets.all(16),
              child: Text(
                card.content,
                style: const TextStyle(color: Colors.white, fontSize: 16),
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Helper method to build image widget based on path
  Widget _buildImageWidget(String path) {
    // Remote image (URL starts with http)
    if (path.startsWith('http')) {
      return CachedNetworkImage(
        imageUrl: path,
        fit: BoxFit.contain,
        width: double.infinity,
        placeholder: (context, url) =>
            const Center(child: CircularProgressIndicator()),
        errorWidget: (context, url, error) => const Center(
          child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
        ),
      );
    }

    // Local file
    try {
      return Image.file(
        File(path),
        fit: BoxFit.contain,
        width: double.infinity,
        errorBuilder: (context, error, stackTrace) {
          return const Center(
            child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
          );
        },
      );
    } catch (e) {
      return const Center(
        child: Icon(Icons.broken_image, size: 64, color: Colors.grey),
      );
    }
  }

  // Link card preview
  Widget _buildLinkCardPreview(BuildContext context) {
    return Container(
      constraints: BoxConstraints(
        maxHeight: MediaQuery.of(context).size.height * 0.5,
      ),
      width: double.infinity,
      child: SingleChildScrollView(
        physics: const ClampingScrollPhysics(),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            // Link icon or placeholder
            Container(
              height: 120,
              color: Colors.grey.shade800,
              child: const Center(
                child: Icon(Icons.link, size: 48, color: Colors.white54),
              ),
            ),

            // Content and URL
            Padding(
              padding: const EdgeInsets.all(16),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  // Content as title
                  Text(
                    card.content,
                    style: const TextStyle(
                      fontSize: 18,
                      fontWeight: FontWeight.bold,
                      color: Colors.white,
                    ),
                  ),

                  const SizedBox(height: 8),

                  // URL - clickable
                  if (card.url != null && card.url!.isNotEmpty)
                    GestureDetector(
                      onTap: () => _launchUrlFromPreview(context, card.url!),
                      child: Text(
                        card.url!,
                        style: TextStyle(
                          fontSize: 14,
                          color: Colors.blue.shade300,
                          decoration: TextDecoration.underline,
                        ),
                      ),
                    ),

                  // Add Open URL button
                  if (card.url != null && card.url!.isNotEmpty) ...[
                    const SizedBox(height: 16),
                    ElevatedButton.icon(
                      onPressed: () =>
                          _launchUrlFromPreview(context, card.url!),
                      icon: const Icon(Icons.open_in_browser),
                      label: const Text('Open Link'),
                      style: ElevatedButton.styleFrom(
                        backgroundColor: Colors.blue.shade700,
                        foregroundColor: Colors.white,
                        padding: const EdgeInsets.symmetric(
                          horizontal: 16,
                          vertical: 10,
                        ),
                        shape: RoundedRectangleBorder(
                          borderRadius: BorderRadius.circular(8),
                        ),
                      ),
                    ),
                  ],
                ],
              ),
            ),
          ],
        ),
      ),
    );
  }

  // Launch URL with proper error handling
  Future<void> _launchUrlFromPreview(
    BuildContext context,
    String urlString,
  ) async {
    print('Using UrlUtils to launch URL from preview: $urlString');
    await UrlUtils.launchUrl(urlString, context: context, showError: true);
  }

  // Show delete confirmation dialog
  void _showDeleteConfirmation(BuildContext context) {
    showDialog(
      context: context,
      builder: (dialogContext) => Material(
        type: MaterialType.transparency,
        child: AlertDialog(
          backgroundColor: AppTheme.surfaceVariantColor,
          shape: RoundedRectangleBorder(
            borderRadius: BorderRadius.circular(16),
          ),
          title: const Text(
            'Delete Card',
            style: TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
            textAlign: TextAlign.center,
          ),
          content: Text(
            'Are you sure you want to delete "${card.content.length > 30 ? card.content.substring(0, 30) + '...' : card.content}"?',
            style: const TextStyle(color: Colors.white70),
            textAlign: TextAlign.center,
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(dialogContext).pop(),
              style: TextButton.styleFrom(foregroundColor: Colors.grey),
              child: const Text('CANCEL'),
            ),
            ElevatedButton(
              onPressed: () {
                Navigator.of(dialogContext).pop();
                _deleteCard(context);
              },
              style: ElevatedButton.styleFrom(
                backgroundColor: Colors.redAccent,
                foregroundColor: Colors.white,
              ),
              child: const Text('DELETE'),
            ),
          ],
        ),
      ),
    );
  }

  // Delete the card
  void _deleteCard(BuildContext context) async {
    if (card.id == null) return;

    try {
      await cardRepository.deleteCard(card.id!);
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Card deleted successfully'),
            backgroundColor: Colors.green,
          ),
        );
        Navigator.of(context).pop(); // Close the preview overlay
      }
    } catch (e) {
      if (context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Error deleting card: ${e.toString()}'),
            backgroundColor: Colors.red,
          ),
        );
      }
    }
  }
}

// Helper function to show the card preview overlay
void showCardPreviewOverlay({
  required BuildContext context,
  required CardEntity card,
  required VoidCallback onEdit,
  required CardRepository cardRepository,
}) {
  showGeneralDialog(
    context: context,
    barrierDismissible: true,
    barrierColor: Colors.black54,
    barrierLabel: 'Dismiss',
    transitionDuration: const Duration(milliseconds: 200),
    pageBuilder: (context, animation1, animation2) {
      return CardPreviewOverlay(
        card: card,
        onEdit: onEdit,
        cardRepository: cardRepository,
      );
    },
    transitionBuilder: (context, animation, secondaryAnimation, child) {
      return FadeTransition(
        opacity: animation,
        child: ScaleTransition(
          scale: CurvedAnimation(
            parent: animation,
            curve: Curves.easeOut,
          ).drive(Tween<double>(begin: 0.95, end: 1.0)),
          child: child,
        ),
      );
    },
  );
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\ui\widgets\tabs ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\ui\widgets\tabs\spaces_tab.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:flutter_bloc/flutter_bloc.dart';

import '../../../blocs/spaces/spaces_bloc.dart';
import '../../../data/repository/space_repository.dart';
import '../spaces_panel.dart';

class SpacesTab extends StatelessWidget {
  const SpacesTab({super.key});

  @override
  Widget build(BuildContext context) {
    return BlocProvider<SpacesBloc>(
      create: (context) =>
          SpacesBloc(spaceRepository: context.read<SpaceRepository>())
            ..add(const LoadSpaces()),
      child: const SpacesPanel(),
    );
  }
}

--- Content End ---

--- Directory: D:\SDPProject\retainly\lib\src\utils ---

=========================================
File Path: D:\SDPProject\retainly\lib\src\utils\image_storage.dart
=========================================
--- Content Start ---
import 'dart:io';
import 'dart:typed_data';
import 'package:path_provider/path_provider.dart';
import 'package:uuid/uuid.dart';
import 'package:image/image.dart' as img;

class ImageStorage {
  ImageStorage();

  Future<Directory> _imagesDir() async {
    final dir = await getApplicationDocumentsDirectory();
    final images = Directory('${dir.path}/images');
    if (!await images.exists()) {
      await images.create(recursive: true);
    }
    return images;
  }

  Future<(File original, File thumbnail)> saveImageWithThumbnail(
    File input,
  ) async {
    print('saveImageWithThumbnail: Processing image from ${input.path}');

    final images = await _imagesDir();
    final id = const Uuid().v4();

    try {
      // First check if the file exists
      if (!await input.exists()) {
        throw Exception('Input file does not exist: ${input.path}');
      }

      // Try to read the file multiple ways in case one fails
      Uint8List? bytes;

      try {
        bytes = await input.readAsBytes();
        print('saveImageWithThumbnail: Read ${bytes.length} bytes from input');
      } catch (e) {
        print(
          'saveImageWithThumbnail: Error reading file with readAsBytes: $e',
        );
        // Try an alternate method (reading through a stream)
        try {
          final byteData = await input.readAsBytes();
          bytes = byteData;
          print(
            'saveImageWithThumbnail: Read ${bytes.length} bytes with alternate method',
          );
        } catch (e2) {
          print('saveImageWithThumbnail: All file reading methods failed: $e2');
          rethrow;
        }
      }

      if (bytes.isEmpty) {
        throw Exception('Image file is empty');
      }

      // Try to decode the image, with fallback options
      img.Image? decoded;
      try {
        decoded = img.decodeImage(bytes);
      } catch (e) {
        print('saveImageWithThumbnail: Standard decode failed: $e');
        // Try alternative decoders if the main one fails
        try {
          if (bytes.length > 2 && bytes[0] == 0xFF && bytes[1] == 0xD8) {
            // JPEG magic bytes
            decoded = img.decodeJpg(bytes);
          } else if (bytes.length > 8 &&
              bytes[0] == 0x89 &&
              bytes[1] == 0x50 &&
              bytes[2] == 0x4E &&
              bytes[3] == 0x47) {
            // PNG magic bytes
            decoded = img.decodePng(bytes);
          } else {
            // Try all formats as a last resort
            decoded = img.decodeImage(bytes);
          }
        } catch (e2) {
          print('saveImageWithThumbnail: All decode attempts failed: $e2');
        }
      }

      if (decoded == null) {
        throw Exception('Unsupported image format or corrupt image data');
      }

      print(
        'saveImageWithThumbnail: Successfully decoded image: ${decoded.width}x${decoded.height}',
      );

      // Save original as JPEG
      final originalPath = '${images.path}/$id.jpg';
      final originalBytes = img.encodeJpg(decoded, quality: 90);

      if (originalBytes.isEmpty) {
        throw Exception('Failed to encode image as JPEG');
      }

      print(
        'saveImageWithThumbnail: Encoded original image: ${originalBytes.length} bytes',
      );

      final originalFile = await File(
        originalPath,
      ).writeAsBytes(originalBytes, flush: true);

      print(
        'saveImageWithThumbnail: Saved original file to ${originalFile.path}',
      );

      // Thumbnail max width 400
      final resized = decoded.width > 400
          ? img.copyResize(decoded, width: 400)
          : decoded;
      final thumbPath = '${images.path}/${id}_thumb.jpg';
      final thumbBytes = img.encodeJpg(resized, quality: 80);
      final thumbFile = await File(
        thumbPath,
      ).writeAsBytes(thumbBytes, flush: true);

      print('saveImageWithThumbnail: Saved thumbnail to ${thumbFile.path}');

      // Verify files were created successfully
      if (!await originalFile.exists() || !await thumbFile.exists()) {
        throw Exception('Failed to save image files');
      }

      return (originalFile, thumbFile);
    } catch (e) {
      print('saveImageWithThumbnail ERROR: $e');

      // Clean up any partial files
      final originalPath = '${images.path}/$id.jpg';
      final thumbPath = '${images.path}/${id}_thumb.jpg';

      try {
        final originalFile = File(originalPath);
        if (await originalFile.exists()) {
          await originalFile.delete();
        }

        final thumbFile = File(thumbPath);
        if (await thumbFile.exists()) {
          await thumbFile.delete();
        }
      } catch (cleanupError) {
        print('Error during cleanup: $cleanupError');
      }

      rethrow;
    }
  }

  Future<void> deleteImagePair(String originalPath) async {
    try {
      final file = File(originalPath);
      if (await file.exists()) {
        await file.delete();
      }
      final thumbPath = originalPath.replaceFirst(
        RegExp(r'(\.jpg|\.jpeg|\.png)\$'),
        '_thumb.jpg',
      );
      final thumb = File(thumbPath);
      if (await thumb.exists()) {
        await thumb.delete();
      }
    } catch (_) {
      // ignore
    }
  }

  // New method to save an image from a file and return the path
  Future<String> saveImageFromFile(File input) async {
    try {
      print('ImageStorage: Saving image from file ${input.path}');

      // First verify the input file exists and has data
      if (!await input.exists()) {
        throw Exception('Input image file does not exist: ${input.path}');
      }

      final fileSize = await input.length();
      if (fileSize == 0) {
        throw Exception('Input image file is empty: ${input.path}');
      }

      print('ImageStorage: File exists with size: $fileSize bytes');

      final (originalFile, thumbFile) = await saveImageWithThumbnail(input);

      // Verify output file was created
      if (!await originalFile.exists()) {
        throw Exception('Failed to create image file at: ${originalFile.path}');
      }

      print('ImageStorage: Image saved successfully');
      print('ImageStorage: Original image path: ${originalFile.path}');
      print('ImageStorage: Thumbnail path: ${thumbFile.path}');
      print(
        'ImageStorage: Original file size: ${await originalFile.length()} bytes',
      );

      // Double-check the saved image is readable by reading a few bytes
      try {
        await originalFile.openRead(0, 10).first;
        print('ImageStorage: Verified file is readable');
      } catch (e) {
        print('ImageStorage: WARNING - File may be corrupted: $e');
      }

      return originalFile.path;
    } catch (e) {
      print('ImageStorage: ERROR saving image - $e');
      rethrow;
    }
  }
}

--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\utils\shared_content_manager.dart
=========================================
--- Content Start ---


--- Content End ---


=========================================
File Path: D:\SDPProject\retainly\lib\src\utils\url_utils.dart
=========================================
--- Content Start ---
import 'package:flutter/material.dart';
import 'package:url_launcher/url_launcher.dart' as url_launcher;

class UrlUtils {
  /// Normalizes a URL string and ensures it has a proper scheme
  static String normalizeUrl(String urlString) {
    if (urlString.isEmpty) {
      return urlString;
    }

    String normalizedUrl = urlString.trim();

    // Handle common URL schemes
    if (normalizedUrl.startsWith('www.')) {
      normalizedUrl = 'https://$normalizedUrl';
    } else if (!normalizedUrl.contains('://')) {
      // Check if it might be an email
      if (RegExp(r'^[^@\s]+@[^@\s]+\.[^@\s]+$').hasMatch(normalizedUrl)) {
        normalizedUrl = 'mailto:$normalizedUrl';
      }
      // Check if it might be a phone number
      else if (RegExp(r'^\+?[\d\s\-()]{5,}$').hasMatch(normalizedUrl)) {
        normalizedUrl =
            'tel:${normalizedUrl.replaceAll(RegExp(r'[\s\-()]'), '')}';
      }
      // Default to https for web URLs
      else {
        normalizedUrl = 'https://$normalizedUrl';
      }
    }

    return normalizedUrl;
  }

  /// Launches a URL with proper error handling and fallbacks
  static Future<bool> launchUrl(
    String urlString, {
    required BuildContext context,
    bool showError = true,
  }) async {
    try {
      if (urlString.isEmpty) {
        throw Exception('URL is empty');
      }

      // Enhanced URL normalization
      String normalizedUrl = normalizeUrl(urlString);
      print('Normalized URL: $normalizedUrl');

      try {
        final Uri url = Uri.parse(normalizedUrl);
        print('Parsed URI: $url');

        // Force launch with external application for web URLs
        final url_launcher.LaunchMode mode =
            (url.scheme == 'mailto' || url.scheme == 'tel')
            ? url_launcher.LaunchMode.platformDefault
            : url_launcher.LaunchMode.externalApplication;

        final bool result = await url_launcher.launchUrl(url, mode: mode);

        if (!result) {
          throw Exception('Could not launch URL: $normalizedUrl');
        }

        print('URL launch successful');
        return true;
      } catch (e) {
        print('Error during URL parsing/launching: $e');

        // Try a more permissive approach
        try {
          // Just try to launch with the original URL as a fallback
          final fallbackUrl = Uri.parse('https://${urlString.trim()}');
          final result = await url_launcher.launchUrl(
            fallbackUrl,
            mode: url_launcher.LaunchMode.externalApplication,
          );

          if (result) {
            print('Fallback URL launch successful');
            return true;
          }
        } catch (fallbackError) {
          print('Fallback launch also failed: $fallbackError');
        }

        throw Exception('Failed to open link');
      }
    } catch (e) {
      print('Error launching URL: $e');

      // Show error if requested
      if (showError && context.mounted) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(
            content: Text('Could not open URL: ${e.toString()}'),
            backgroundColor: Colors.red.shade700,
            behavior: SnackBarBehavior.floating,
          ),
        );
      }

      return false;
    }
  }
}

--- Content End ---

